<!doctype html><html lang=zh-cn class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.91.2">
<link rel=canonical type=text/html href=https://xiaoping378.gitee.io/docs/4-cloud/containers/>
<link rel=alternate type=application/rss+xml href=https://xiaoping378.gitee.io/docs/4-cloud/containers/index.xml>
<meta name=robots content="noindex, nofollow">
<link rel="shortcut icon" href=/favicons/favicon.ico>
<title>容器篇 | 现代技能栈</title>
<meta name=description content="主要记录容器相关技能。 
">
<meta property="og:title" content="容器篇">
<meta property="og:description" content="主要记录容器相关技能。 
">
<meta property="og:type" content="website">
<meta property="og:url" content="https://xiaoping378.gitee.io/docs/4-cloud/containers/"><meta property="og:site_name" content="现代技能栈">
<meta itemprop=name content="容器篇">
<meta itemprop=description content="主要记录容器相关技能。 
"><meta name=twitter:card content="summary">
<meta name=twitter:title content="容器篇">
<meta name=twitter:description content="主要记录容器相关技能。 
">
<link rel=preload href=/scss/main.min.9f63fcc1b5f091883eb4c0c66b7bddf337a299d08451443230a201303e53b01c.css as=style>
<link href=/scss/main.min.9f63fcc1b5f091883eb4c0c66b7bddf337a299d08451443230a201303e53b01c.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<script src=/js/lunr.min.js integrity=sha384-vRQ9bDyE0Wnu+lMfm57BlYLO0/XauFuKpVsZPs7KEDwYKktWi5+Kz3MP8++DFlRY crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-217913492-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo></span><span class="text-uppercase font-weight-bold">现代技能栈</span>
</a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/about/><span>关于</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class="nav-link active" href=/docs/><span class=active>文档</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/blog/><span>博客</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/community/><span>社区</span></a>
</li>
</ul>
</div>
<div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off data-offline-search-index-json-src=/offline-search-index.7be96b374cb7ce076722c2616916aeef.json data-offline-search-base-href=/ data-offline-search-max-results=10>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/docs/4-cloud/containers/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>容器篇</h1>
<div class=lead>主要记录容器相关技能。</div>
<ul>
<li>1: <a href=#pg-0e1c458550e81115eef23fe2096cb693>百宝箱脚本</a></li>
<li>2: <a href=#pg-a59f23af47640c766c1d4987191915d8>docker网络</a></li>
<li>3: <a href=#pg-4d3b593744ec493d8b3725d4f1180867>Swarm篇</a></li>
<ul>
<li>3.1: <a href=#pg-1505cb7ba0742792d48614ad7b82e973>构建生产环境级的docker Swarm集群-1</a></li>
<li>3.2: <a href=#pg-d909113e9543ac3fe911d0a23fec6fd2>构建生产环境级的docker Swarm集群-2</a></li>
<li>3.3: <a href=#pg-2ff8ed6e755645d7ae818d9b0fcbb120>构建生产环境级的docker Swarm集群-3</a></li>
</ul>
<li>4: <a href=#pg-37045fcceebb8772a7634ea2fe9730e1>从docker迁移到containerd</a></li>
</ul>
<div class=content>
<div class="pageinfo pageinfo-primary">
<p>容器基础界还在不断向前发展，持续更新认知。</p>
</div>
<p>自15年开始接触容器，当时容器就是Docker，Docker就是容器，当然现在docker仍是主流的容器runtime方案，随着k8s的规模落地，生态也在潜移默化的变化着，此篇会把以前编写的一些文章挪移到此处，顺便开启新的认知。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0e1c458550e81115eef23fe2096cb693>1 - 百宝箱脚本</h1>
<div class=lead>记录常用命令脚本。</div>
<ul>
<li>备份所有docker镜像</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir -p images <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>cd</span> images
<span style=color:#a2f;font-weight:700>for</span> image in <span style=color:#b44>`</span>docker images | grep -v REPOSITORY | awk <span style=color:#b44>&#39;{print $1&#34;:&#34;$2}&#39;</span><span style=color:#b44>`</span>; <span style=color:#a2f;font-weight:700>do</span>
    <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;saving the image of </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>image</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>
    docker save <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>image</span><span style=color:#b68;font-weight:700>}</span> &gt;  <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>image</span>////-<span style=color:#b68;font-weight:700>}</span>.tar
    <span style=color:#a2f>echo</span> -e <span style=color:#b44>&#34;finished saving the image of \033[32m </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>image</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44> \033[0m&#34;</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><ul>
<li>批量加载本地tar镜像</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f;font-weight:700>for</span> image in <span style=color:#b44>`</span>ls *.tar<span style=color:#b44>`</span>; <span style=color:#a2f;font-weight:700>do</span>
    <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;loading the image of </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>image</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>
    docker load &lt; <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>image</span><span style=color:#b68;font-weight:700>}</span>
    <span style=color:#a2f>echo</span> -e <span style=color:#b44>&#34;finished loading the image of \033[32m </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>image</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44> \033[0m&#34;</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><ul>
<li>批量杀死僵尸进程</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ps -A -o stat,ppid,pid,cmd | grep -e <span style=color:#b44>&#39;^[Zz]&#39;</span> | awk <span style=color:#b44>&#39;{print $2}&#39;</span> | xargs <span style=color:#a2f>kill</span> -9
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a59f23af47640c766c1d4987191915d8>2 - docker网络</h1>
<div class=lead>介绍docker自带的几种网络模型</div>
<p>自去年就开始推动公司业务使用docker了， 至今也一年多了，但对docker网络的认知一直一知半解。。。</p>
<p>主要是太忙，加上线上业务也没出过关于网络吞吐性能方面的问题，就没太大动力去搞明白， 现在闲下来了，搞之！</p>
<h3 id=环境声明>环境声明</h3>
<ul>
<li>以下内容只针对OS: Ubuntu16.04 docker: 1.10.3的环境， 写本文时docker最新的release版本是1.11.2，还有什么CoreOS，Unikernel 之类的（表示都没玩过）。</li>
</ul>
<blockquote>
<p>docker更新迭代速度太快了，公司业务只用到基本功能，所以没动力跟进它的更新了
各种新时代下的产物频出啊， CoreOS为linux的发行版， 没需求，好遗憾.</p>
</blockquote>
<h3 id=docker的网络模式>docker的网络模式</h3>
<p>一开始安装完docker， 它就会默认创建3个网络， 使用__docker network ls__查看</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  blog git:<span style=color:#666>(</span>master<span style=color:#666>)</span> docker network ls
NETWORK ID          NAME                DRIVER
46416a43fbc6        bridge              bridge              
45398901e9f0        none                null                
9440a8140e68        host                host
</code></pre></div><p>当启动一个容器时， 默认使用bridge模式， 可以通过 --net 指定其它模式。</p>
<p>下面先简要说明下各自的概念</p>
<ul>
<li>bridge 模式</li>
</ul>
<p>容器间之所以能通信，就靠宿主机上的docker0了， docker0就是bridge模式下默认创建的虚拟设备名称</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  blog git:<span style=color:#666>(</span>master<span style=color:#666>)</span> ✗ ifconfig docker0
docker0   Link encap:Ethernet  HWaddr 02:42:49:56:7c:3b  
          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:49ff:fe56:7c3b/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:78103 errors:0 dropped:0 overruns:0 frame:0
          TX packets:47578 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:17485434 <span style=color:#666>(</span>17.4 MB<span style=color:#666>)</span>  TX bytes:82163889 <span style=color:#666>(</span>82.1 MB<span style=color:#666>)</span>
</code></pre></div><p>ifocnfig可以看到很多信息， mac地址，IP等这些也可以通过参数指定成别的。</p>
<ul>
<li>none模式</li>
</ul>
<p>none网络模式下的容器里是缺少网络接口的，例如eth0等，但会有一个lo设备。</p>
<p>没用过也没见过这样的业务场景， 不做过多说明</p>
<ul>
<li>host模式</li>
</ul>
<p>容器直接操作宿主机的网络栈， 无疑是性能最好的网络模式， 可以认为是无带宽损耗的。</p>
<h3 id=细说bridge模式>细说bridge模式</h3>
<p>这也是我们线上正在在用的网络模式。</p>
<p>bridge模式主要利用了iptables的Masquerading和DNAT功能。</p>
<p>未完。。。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d3b593744ec493d8b3725d4f1180867>3 - Swarm篇</h1>
<div class=lead>Docker内置容器编排方案，，，（弃用）。</div>
<div class="pageinfo pageinfo-primary">
<p>Docker内置容器编排方案</p>
</div>
<p>当年的swarm、k8s、mesos三大系统竞争之激烈，现在都归于k8s了。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1505cb7ba0742792d48614ad7b82e973>3.1 - 构建生产环境级的docker Swarm集群-1</h1>
<div class=lead>构建生产环境级的docker Swarm集群。</div>
<p>此文档适用于低于1.12版本的docker，之后swarm已内置于docker-engine里。</p>
<ol>
<li>硬件需求</li>
</ol>
<p>至少5台PC服务器, 分别如下作用</p>
<ul>
<li>manager0</li>
<li>manager1</li>
<li>consul0</li>
<li>node0</li>
<li>node1</li>
</ul>
<ol start=2>
<li>每台PC上安装docker-engine</li>
</ol>
<p>一台一台的ssh上去执行，或者使用ansible批量部署工具。</p>
<p>安装docker-engine</p>
<pre tabindex=0><code>curl -sSL https://get.docker.com/ | sh
</code></pre><p>启动之，并使之监听2375端口</p>
<pre tabindex=0><code>sudo docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
</code></pre><p>亦可修改配置，使之永久生效</p>
<pre tabindex=0><code>mkdir /etc/systemd/system/docker.service.d
cat &lt;&lt;EOF &gt;&gt;/etc/systemd/system/docker.service.d/docker.conf
[Service]
  ExecStart=
  ExecStart=/usr/bin/docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --dns 180.76.76.76  --insecure-registry registry.cecf.com -g /home/Docker/docker
EOF
</code></pre><ol start=3>
<li>启动discovery后台</li>
</ol>
<p>在consul0上启动consul服务，manager用其来认证node连接并存储node状态， 理应建立discovery的高可用，这里简化之</p>
<pre tabindex=0><code>docker run -d -p 8500:8500 --name=consul progrium/consul -server -bootstrap
</code></pre><ol start=4>
<li>创建Swarm集群</li>
</ol>
<p>在manager0上创建the primary manager， 自行替换manager0_ip和consul0_ip的真实IP地址。</p>
<pre tabindex=0><code>docker run -d -p 4000:4000 swarm manage -H :4000 --replication --advertise &lt;manager0_ip&gt;:4000 consul://&lt;consul0_ip&gt;:8500
</code></pre><p>在manager1上启动replica manger</p>
<pre tabindex=0><code>docker run -d -p 4000:4000 swarm manage -H :4000 --replication --advertise &lt;manager1_ip&gt;:4000 consul://&lt;consul0_ip&gt;:8500
</code></pre><p>--replication</p>
<ol start=5>
<li>在node上执行加入集群操作</li>
</ol>
<p>分别在node0和node1上执行加入集群操作</p>
<pre tabindex=0><code>docker run -d swarm join --advertise=&lt;node_ip&gt;:2375 consul://&lt;consul0_ip&gt;:8500
</code></pre><ol start=6>
<li>在manger0上查看集群状态</li>
</ol>
<pre tabindex=0><code>docker -H :4000 info
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d909113e9543ac3fe911d0a23fec6fd2>3.2 - 构建生产环境级的docker Swarm集群-2</h1>
<div class=lead>构建生产环境级的docker Swarm集群。</div>
<p>此文档适用于不低于1.12版本的docker，因为swarm已内置于docker-engine里。</p>
<ol>
<li>硬件需求</li>
</ol>
<p>这里以5台PC服务器为例, 分别如下作用</p>
<ul>
<li>manager0</li>
<li>manager1</li>
<li>node0</li>
<li>node1</li>
<li>node2</li>
</ul>
<ol start=2>
<li>每台PC上安装docker-engine</li>
</ol>
<p>一台一台的ssh上去执行，或者使用ansible批量部署工具。</p>
<p>安装docker-engine</p>
<pre tabindex=0><code>curl -sSL https://get.docker.com/ | sh
</code></pre><p>启动之，并使之监听2375端口</p>
<pre tabindex=0><code>sudo docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
</code></pre><p>亦可修改配置，使之永久生效</p>
<pre tabindex=0><code>mkdir /etc/systemd/system/docker.service.d
cat &lt;&lt;EOF &gt;&gt;/etc/systemd/system/docker.service.d/docker.conf
[Service]
  ExecStart=
  ExecStart=/usr/bin/docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --dns 180.76.76.76  --insecure-registry registry.cecf.com -g /home/Docker/docker
EOF
</code></pre><p>如果开启了防火墙，需要开启如下端口</p>
<ul>
<li><strong>TCP port 2377</strong> for cluster management communications</li>
<li><strong>TCP</strong> and <strong>UDP port 7946</strong> for communication among nodes</li>
<li><strong>TCP</strong> and <strong>UDP port 4789</strong> for overlay network traffic</li>
</ul>
<ol start=3>
<li>创建swarm</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker swarm init --advertise-addr &lt;MANAGER-IP&gt;
</code></pre></div><p>我的实例里如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#666>[</span>root@manager0 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic># docker swarm init --advertise-addr 10.42.0.243</span>
Swarm initialized: current node <span style=color:#666>(</span>e5eqi0lue90uidzsfddeqwfl8<span style=color:#666>)</span> is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --token SWMTKN-1-3iskhw3lsc9pkdtijj1d23lg9tp7duj18f477i5ywgezry7zlt-dfwjbsjleoajcdj13psu702s6 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    10.42.0.243:2377

To add a manager to this swarm, run <span style=color:#b44>&#39;docker swarm join-token manager&#39;</span> and follow the instructions.
</code></pre></div><p>使用 <code>--advertise-addr</code> 来声明manager0的IP，其他的nodes必须可以和此IP互通，
一旦完整初始化，此node即是manger又是worker node.</p>
<p>通过<code>docker info</code>来查看</p>
<pre tabindex=0><code>$ docker info

Containers: 2
Running: 0
Paused: 0
Stopped: 2
  ...snip...
Swarm: active
  NodeID: e5eqi0lue90uidzsfddeqwfl8
  Is Manager: true
  Managers: 1
  Nodes: 1
  ...snip...
</code></pre><p>通过<code>docker node ls</code>来查看集群的node信息</p>
<pre tabindex=0><code>[root@manager0 ~]# docker node ls
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
e5eqi0lue90uidzsfddeqwfl8 *  manager0  Ready   Active        Leader

</code></pre><p>这里的<code>*</code>来指明docker client正在链接在这个node上。</p>
<ol start=4>
<li>加入swarm集群</li>
</ol>
<p>执行在manager0上产生<code>docker swarm init</code>产生的结果即可</p>
<p>如果当时没记录下来，还可以在manager上补看
想把node以worker身份加入，在manager0上执行下面的命令来补看。</p>
<pre tabindex=0><code>docker swarm join-token worker
</code></pre><p>想把node以manager身份加入，在manager0上执行下面的命令来来补看。</p>
<pre tabindex=0><code>docker swarm join-token manager
</code></pre><p>为了manager的高可用，我这里需要在manager1上执行</p>
<pre tabindex=0><code>docker swarm join \
--token SWMTKN-1-3iskhw3lsc9pkdtijj1d23lg9tp7duj18f477i5ywgezry7zlt-86dk7l9usp1yh4uc3rjchf2hu \
10.42.0.243:2377
</code></pre><p>我这里就是依次在node0-2上执行</p>
<pre tabindex=0><code>docker swarm join \
  --token SWMTKN-1-3iskhw3lsc9pkdtijj1d23lg9tp7duj18f477i5ywgezry7zlt-dfwjbsjleoajcdj13psu702s6 \
  10.42.0.243:2377
</code></pre><p>这样node就会加入之前我们创建的swarm集群里。</p>
<p>再通过<code>docker node ls</code>来查看现在的集群情况， swarm的集群里是以node为实例的</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#666>[</span>root@manager0 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic># docker node ls</span>
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
0tr5fu8ebi27cp2ot210t67fx    manager1  Ready   Active        Reachable
46irkik4idjk8rjy7pqjb84x0    node1     Ready   Active
79hlu1m7x9p4cc4npa4xjuax3    node0     Ready   Active
9535h8ow82s8mzuw5kud2mwl3    consul0   Ready   Active
e5eqi0lue90uidzsfddeqwfl8 *  manager0  Ready   Active        Leader
</code></pre></div><p>这里MANAFER标明各node的身份，空即为worker身份。</p>
<ol start=5>
<li>部署服务</li>
</ol>
<pre tabindex=0><code>Usage:	docker service COMMAND

Manage Docker services

Options:
      --help   Print usage

Commands:
  create      Create a new service
  inspect     Display detailed information on one or more services
  ps          List the tasks of a service
  ls          List services
  rm          Remove one or more services
  scale       Scale one or multiple services
  update      Update a service
</code></pre><p>部署示例如下：</p>
<pre tabindex=0><code>docker service create --replicas 2 --name helloworld alpine ping 300.cn
</code></pre><p><code>docker service ls</code>罗列swarm集群的所有services
<code>docker service ps helloworld</code>查看service部署到了哪个node上
<code>docker service inspect helloworld</code> 查看service 资源、状态等具体信息
<code>docker servcie scale helloworld=5</code>来扩容service的个数
<code>docker service rm helloworld</code> 来删除service
<code>docker service update</code> 来实现更新service的各项属性，包括滚动升级等。</p>
<p>可更新的属性包含如下：</p>
<pre tabindex=0><code>Usage:	docker service update [OPTIONS] SERVICE

Update a service

Options:
      --args string                    Service command args
      --constraint-add value           Add or update placement constraints (default [])
      --constraint-rm value            Remove a constraint (default [])
      --container-label-add value      Add or update container labels (default [])
      --container-label-rm value       Remove a container label by its key (default [])
      --endpoint-mode string           Endpoint mode (vip or dnsrr)
      --env-add value                  Add or update environment variables (default [])
      --env-rm value                   Remove an environment variable (default [])
      --help                           Print usage
      --image string                   Service image tag
      --label-add value                Add or update service labels (default [])
      --label-rm value                 Remove a label by its key (default [])
      --limit-cpu value                Limit CPUs (default 0.000)
      --limit-memory value             Limit Memory (default 0 B)
      --log-driver string              Logging driver for service
      --log-opt value                  Logging driver options (default [])
      --mount-add value                Add or update a mount on a service
      --mount-rm value                 Remove a mount by its target path (default [])
      --name string                    Service name
      --publish-add value              Add or update a published port (default [])
      --publish-rm value               Remove a published port by its target port (default [])
      --replicas value                 Number of tasks (default none)
      --reserve-cpu value              Reserve CPUs (default 0.000)
      --reserve-memory value           Reserve Memory (default 0 B)
      --restart-condition string       Restart when condition is met (none, on-failure, or any)
      --restart-delay value            Delay between restart attempts (default none)
      --restart-max-attempts value     Maximum number of restarts before giving up (default none)
      --restart-window value           Window used to evaluate the restart policy (default none)
      --stop-grace-period value        Time to wait before force killing a container (default none)
      --update-delay duration          Delay between updates
      --update-failure-action string   Action on update failure (pause|continue) (default &quot;pause&quot;)
      --update-parallelism uint        Maximum number of tasks updated simultaneously (0 to update all at once) (default 1)
  -u, --user string                    Username or UID
      --with-registry-auth             Send registry authentication details to swarm agents
  -w, --workdir string                 Working directory inside the container
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2ff8ed6e755645d7ae818d9b0fcbb120>3.3 - 构建生产环境级的docker Swarm集群-3</h1>
<div class=lead>构建生产环境级的docker Swarm集群。</div>
<p>如前文所述，默认已经搭建好环境，基于docker1.12版本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#666>[</span>root@manager0 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic># docker node ls</span>
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
0bbmd3r7aphs374qaea4zcieo    node2     Ready   Active
3qmxzyauc0bz4kjqvld9uogz5    manager1  Ready   Active        Reachable
5ewbdtvaopj4ltwqx0a4i65nt *  manager0  Ready   Drain         Leader
5oxxpgk69fnwe5w210kovrqi9    node1     Ready   Active
7s1ilay2wkjgt09bp2z0743m7    node0     Ready   Active
</code></pre></div><ol>
<li>创建第一个服务，以redis为例
swarm里容器间通信需要使用overlay模式，所以需要提前建立一个</li>
</ol>
<pre tabindex=0><code>docker network create -d overlay  --subnet 10.254.0.0/16 --gateway  10.254.0.1 mynet1
docker service create --name redis --network mynet1 redis
</code></pre><ol start=2>
<li>在manager上查看服务部署情况</li>
</ol>
<pre tabindex=0><code>[root@manager0 ~]# docker service ps redis
ID                         NAME     IMAGE  NODE   DESIRED STATE  CURRENT STATE           ERROR
9avksjfqr2gxm413dfrezrmgr  redis.1  redis  node1  Running        Running 17 seconds ago
</code></pre><p>实例里，同样可以去node1上用<code>docker ps</code>查看</p>
<p>以上只是最基本的集群创建服务的用法，从中可见，swarm的的调度基本单元是task, 没有pod的概念，一个task可以简单理解成一个docker run的结果。目前swarm里也不支持compose。</p>
<p>docker官方称，以后会支持vm、pod的调度单元，具体日期未知。</p>
<ol start=3>
<li>服务调度策略</li>
</ol>
<p>使用<code>docker service create</code>创建服务， 这其中选择再哪个节点部署，docker 提供了三种调度策略；</p>
<ul>
<li>spread: 默认策略，尽量均匀分布，找容器数少的结点调度</li>
<li>binpack: 和spread相反，尽量把一个结点占满再用其他结点</li>
<li>random: 随机</li>
</ul>
<ol start=4>
<li>服务的高可用和load-balance</li>
</ol>
<p>通过<code>--replicas</code>参数可以设置服务容器的数量，已达到高可用状态；</p>
<pre tabindex=0><code>#创建多副本
docker service update --replicas 4 redis

#查看副本部署情况
[root@manager0 ~]# docker service ps redis
ID                         NAME     IMAGE  NODE      DESIRED STATE  CURRENT STATE               ERROR
9avksjfqr2gxm413dfrezrmgr  redis.1  redis  node1     Running        Running 13 minutes ago      
0olv1sfz6d79wdnorw7jgoyri  redis.2  redis  manager1  Running        Running about a minute ago  
f3n6deesjlkxu4k48lzabieus  redis.3  redis  node2     Running        Preparing 3 minutes ago     
80bzarvkiytpv1690sla6unt2  redis.4  redis  node0     Running        Running about a minute ago

#验证多可用， 总共4个副本，docker内置的DNS服务会默认使用round-robin调度策略来解析主机。
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&gt; set user 1
OK
redis:6379&gt; exit
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&gt; get user
(nil)
redis:6379&gt; set user 2
OK
redis:6379&gt; exit
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&gt; get user
(nil)
redis:6379&gt; set user 3
OK
redis:6379&gt; exit
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&gt; get user
(nil)
redis:6379&gt; set user 4
OK
redis:6379&gt; exit
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&gt; get user
&quot;1&quot;
redis:6379&gt;

</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-37045fcceebb8772a7634ea2fe9730e1>4 - 从docker迁移到containerd</h1>
<div class=lead>记录从docker迁移到containerd的事项</div>
<div class="pageinfo pageinfo-primary">
<p>记录个人从docker迁移到containerd的事项</p>
</div>
<h2 id=介绍>介绍</h2>
<p><a href=https://github.com/containerd/containerd>https://github.com/containerd/containerd</a></p>
<p>TODO.</p>
<h2 id=安装containerd>安装containerd</h2>
<p>下载必要组件：https://github.com/containerd/nerdctl/releases，</p>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="个人邮箱 xiaoping378@163.com" aria-label="个人邮箱 xiaoping378@163.com">
<a class=text-white target=_blank rel=noopener href=mailto:xiaoping378@163.com aria-label="个人邮箱 xiaoping378@163.com">
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=微博 aria-label=微博>
<a class=text-white target=_blank rel=noopener href=https://weibo.com/xiaoping378 aria-label=微博>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=知乎 aria-label=知乎>
<a class=text-white target=_blank rel=noopener href=https://www.zhihu.com/people/xiaoping378 aria-label=知乎>
<i class="fab fa-zhihu"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel=noopener href=https://github.com/xiaoping378/xiaoping378.github.io aria-label=GitHub>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank rel=noopener href=https://example.org/slack aria-label=Slack>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list">
<a class=text-white target=_blank rel=noopener href=https://example.org/mail aria-label="Developer mailing list">
<i class="fa fa-envelope"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2022 xiaoping378 保留所有权利</small>
<small class=ml-1><a href=# target=_blank rel=noopener>隐私政策</a></small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA==" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script>
<script src=/js/deflate.js></script>
<script src=/js/main.min.e016890ed6b0c42f5af3410eb57ac626a192a868609aee68cefe1e0f84a50b13.js integrity="sha256-4BaJDtawxC9a80EOtXrGJqGSqGhgmu5ozv4eD4SlCxM=" crossorigin=anonymous></script>
</body>
</html>