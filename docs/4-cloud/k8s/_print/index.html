<!doctype html><html lang=zh-cn class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.91.2">
<link rel=canonical type=text/html href=https://xiaoping378.github.io/docs/4-cloud/k8s/>
<link rel=alternate type=application/rss+xml href=https://xiaoping378.github.io/docs/4-cloud/k8s/index.xml>
<meta name=robots content="noindex, nofollow">
<link rel="shortcut icon" href=/favicons/favicon.ico>
<title>Kubernetes | 现代技能栈</title>
<meta name=description content="俗称k8s，在往容器云PaaS平台方向演进。 
">
<meta property="og:title" content="Kubernetes">
<meta property="og:description" content="俗称k8s，在往容器云PaaS平台方向演进。 
">
<meta property="og:type" content="website">
<meta property="og:url" content="https://xiaoping378.github.io/docs/4-cloud/k8s/"><meta property="og:site_name" content="现代技能栈">
<meta itemprop=name content="Kubernetes">
<meta itemprop=description content="俗称k8s，在往容器云PaaS平台方向演进。 
"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Kubernetes">
<meta name=twitter:description content="俗称k8s，在往容器云PaaS平台方向演进。 
">
<link rel=preload href=/scss/main.min.9f63fcc1b5f091883eb4c0c66b7bddf337a299d08451443230a201303e53b01c.css as=style>
<link href=/scss/main.min.9f63fcc1b5f091883eb4c0c66b7bddf337a299d08451443230a201303e53b01c.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<script src=/js/lunr.min.js integrity=sha384-vRQ9bDyE0Wnu+lMfm57BlYLO0/XauFuKpVsZPs7KEDwYKktWi5+Kz3MP8++DFlRY crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-217913492-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo></span><span class="text-uppercase font-weight-bold">现代技能栈</span>
</a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/about/><span>关于</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class="nav-link active" href=/docs/><span class=active>文档</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/blog/><span>博客</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/community/><span>社区</span></a>
</li>
</ul>
</div>
<div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off data-offline-search-index-json-src=/offline-search-index.c677633ec58ce3a9a9b81b07aac54f38.json data-offline-search-base-href=/ data-offline-search-max-results=10>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/docs/4-cloud/k8s/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>Kubernetes</h1>
<div class=lead>俗称k8s，在往容器云PaaS平台方向演进。</div>
<ul>
<li>1: <a href=#pg-f4385dd84140bf058c6b2a60389b58bb>源码部署K8S</a></li>
<li>2: <a href=#pg-eac7def2dc8112b0573f9105edb534f5>离线安装kubernetes</a></li>
<li>3: <a href=#pg-1592af4da4743e978bc3f2eba7c81eae>k8s的各组件和特性扫盲</a></li>
<li>4: <a href=#pg-a2415cefef7c5296c0a415526765a948>Helm模板介绍</a></li>
<li>5: <a href=#pg-b781642b41630a327a3a5151285908a0>k8s的监控方案</a></li>
<li>6: <a href=#pg-e7d513396d808a4808b498da552726e0>配置harbor默认https访问</a></li>
<li>7: <a href=#pg-9defb3943138a8ddf6afc76610480f39>DEIS 开源PAAS平台实践</a></li>
<li>8: <a href=#pg-e3c9486bfc693b58c1c315d2c7cde322>k3s实践-01</a></li>
<li>9: <a href=#pg-03baa014ac348ea7e2865ceaf8dacda4>kubeshere 自研-01</a></li>
<li>10: <a href=#pg-8d71550d3ee2751c7f80b3cef9ae8232>TKEStack all-in-one入坑指南</a></li>
</ul>
<div class=content>
<div class="pageinfo pageinfo-primary">
<p>主要介绍k8s的核心功能和周边生态</p>
</div>
</div>
</div>
<div class=td-content>
<h1 id=pg-f4385dd84140bf058c6b2a60389b58bb>1 - 源码部署K8S</h1>
<div class=lead>基于源码本地运行k8s集群</div>
<div class="pageinfo pageinfo-primary">
<p>此文应该不能运行成功了，，，陈年老文，有待验证。</p>
</div>
<h4 id=一-先介绍最省事的部署方法-直接从官网下release版本安装>一. 先介绍最省事的部署方法，直接从官网下release版本安装:</h4>
<p>git clone 代码步骤省略 ...</p>
<ol>
<li>下载各依赖的release版本</li>
</ol>
<p>通过修改配置文件 <strong>cluster/centos/config-build.sh</strong>， 可自定义（k8s, docker, flannel, etcd）各自的下载地址和版本， 不同的版本的依赖可能会需要小改下脚本（版本变更有些打包路径发生了变化，兼容性问题）</p>
<pre tabindex=0><code>cd cluster/centos &amp;&amp; ./build.sh all
</code></pre><ol start=2>
<li>安装并启动k8s集群环境</li>
</ol>
<p>通过修改配置文件 <strong>cluster/centos/config-default.sh</strong>，定义你环境里的设备的IP和其他参数，推荐运行脚本前先通过ssh-copy-id做好免密钥认证；</p>
<pre tabindex=0><code>export KUBERNETES_PROVIDER=centos &amp;&amp; cluster/kube-up.sh
</code></pre><h4 id=二-源码级编译安装>二. 源码级编译安装</h4>
<p>本步骤基于上一大步来说,
先来看下载各依赖的release后，cluster/centos下目录发生了什么变化</p>
<p><img src=/k8s-binaries-tree.png alt></p>
<p>多了一个binaries的目录，里面是各master和minion上各依赖的二进制文件， 所以我们只要源码编译的结果，替换到这里来， 然后继续上一大步的第2小步即可。</p>
<p>这里说下，本地编译k8s的话，需要设置安装godep，然后命令本地化。</p>
<pre tabindex=0><code>export PATH=$PATH:$GOPATH/bin
</code></pre><p>最后只需要去源码根目录下执行， 编译结果在_output目录下</p>
<pre tabindex=0><code>make
</code></pre><p>替换到相应的binaries目录下，重新运行kube-up.sh即可。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eac7def2dc8112b0573f9105edb534f5>2 - 离线安装kubernetes</h1>
<div class=lead>介绍离线安装k8s 1.5版本</div>
<div class="pageinfo pageinfo-primary">
<p>虽然距离当前主流版本已经差之千里，但其中的思想仍记得借鉴。</p>
</div>
<p>经常遇到全新初始安装k8s集群的问题，所以想着搞成离线模式，本着最小依赖原则，提高安装速度</p>
<p>基于Centos7-1511-minimal, 非此版本脚本应该会运行出错，自行修改吧</p>
<p>本离线安装所有的依赖都打包放到了<a href=https://pan.baidu.com/s/1i5jusip>百度网盘</a></p>
<p>为了便于维护，已建立独立项目<a href=https://github.com/xiaoping378/k8s-deploy>k8s-deploy</a></p>
<h2 id=第一步>第一步</h2>
<p>基本思路是，在k8s-deploy目录下，临时启个http server， node节点上会从此拉取所依赖镜像和rpms</p>
<pre tabindex=0><code># python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 ...

</code></pre><p>windows上可以用hfs临时启个http server， 自行百度如何使用</p>
<h2 id=master侧>master侧</h2>
<p>运行以下命令，初始化master</p>
<p>192.168.56.1:8000 是我的http-server, 注意要将k8s-deploy.sh 里的HTTP-SERVER变量也改下</p>
<pre tabindex=0><code>curl -L http://192.168.56.1:8000/k8s-deploy.sh | bash -s master
</code></pre><h2 id=minion侧>minion侧</h2>
<p>视自己的情况而定</p>
<pre tabindex=0><code>curl -L http://192.168.56.1:8000/k8s-deploy.sh |  bash -s join --token=6669b1.81f129bc847154f9 192.168.56.100
</code></pre><h2 id=总结>总结</h2>
<p>整个脚本实现比较简单， 坑都在脚本里解决了。脚本文件在<a href=https://gist.github.com/xiaoping378/3a129aa6c81eaecae199a50236ad8bf7>这里</a></p>
<p>就一个master-up和node-up， 基本一个函数只做一件事，很清晰，可以自己查看具体过程。</p>
<p>1.5 与 1.3给我感觉最大的变化是网络部分， 1.5启用了cni网络插件
不需要像以前一样非要把flannel和docker绑在一起了（先启flannel才能启docker）。</p>
<p>具体可以看这里
<a href=https://github.com/containernetworking/cni/blob/master/Documentation/flannel.md>https://github.com/containernetworking/cni/blob/master/Documentation/flannel.md</a></p>
<p>master侧如果是单核的话，会因资源不足， dns安装失败。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1592af4da4743e978bc3f2eba7c81eae>3 - k8s的各组件和特性扫盲</h1>
<div class=lead>主要介绍k8s中的各核心组件和特性</div>
<div class="pageinfo pageinfo-primary">
<p>了解一个工具的特性可以从它的参数入手</p>
</div>
<h2 id=api-server>api-server</h2>
<p>在k8s内发挥的网关和api</p>
<p>CSR特性</p>
<h2 id=网络>网络</h2>
<h3 id=flannel>flannel</h3>
<ul>
<li>
<p>flannel的设计就是为集群中所有节点能重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，
并让属于不同节点上的容器能够直接通过内网IP通信。</p>
</li>
<li>
<p>实际上就是给每个节点的docker重新设置容器上可分配的IP段， <code>--bip</code>的妙用。
这恰好迎合了k8s的设计，即一个pod（container）在集群中拥有唯一、可路由到的IP，带来的好处就是减少跨主机容器间通信要port mapping的复杂性。</p>
</li>
<li>
<p>原理</p>
<ul>
<li>flannle需要运行一个叫flanned的agent，其用etcd来存储网络配置、已经分配的子网、和辅助信息（主机IP),如下</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#666>[</span>root@master1 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic># etcdctl ls /coreos.com/network</span>
/coreos.com/network/config
/coreos.com/network/subnets
<span style=color:#666>[</span>root@master1 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic>#</span>
<span style=color:#666>[</span>root@master1 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic># etcdctl get /coreos.com/network/config</span>
<span style=color:#666>{</span><span style=color:#b44>&#34;Network&#34;</span>:<span style=color:#b44>&#34;172.16.0.0/16&#34;</span><span style=color:#666>}</span>
<span style=color:#666>[</span>root@master1 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic>#</span>
<span style=color:#666>[</span>root@master1 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic># etcdctl ls /coreos.com/network/subnets</span>
/coreos.com/network/subnets/172.16.29.0-24
/coreos.com/network/subnets/172.16.40.0-24
/coreos.com/network/subnets/172.16.60.0-24
<span style=color:#666>[</span>root@master1 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic>#</span>
<span style=color:#666>[</span>root@master1 ~<span style=color:#666>]</span><span style=color:#080;font-style:italic># etcdctl get  /coreos.com/network/subnets/172.16.29.0-24</span>
<span style=color:#666>{</span><span style=color:#b44>&#34;PublicIP&#34;</span>:<span style=color:#b44>&#34;192.168.1.129&#34;</span><span style=color:#666>}</span>
</code></pre></div><ul>
<li>
<p>flannel0 还负责解封装报文,或者创建路由。
flannel有多种方式可以完成报文的转发。</p>
<ul>
<li>UDP</li>
<li>vxlan</li>
<li>host-gw</li>
<li>aws-vpc</li>
<li>gce</li>
<li>alloc</li>
</ul>
<p>下图是经典的UDP封装方式数据流图
<img src=/flannel-packet-01.png alt=UDP></p>
</li>
</ul>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a2415cefef7c5296c0a415526765a948>4 - Helm模板介绍</h1>
<div class=lead>主要介绍k8s生态中应用打包的工具helm</div>
<h3 id=概要>概要</h3>
<ul>
<li>
<p>Helm是一个管理kubernetes集群内应用的工具，提供了一系列管理应用的快捷方式，例如 inspect， install， upgrade， delete等，经验可以沿用以前apt，yum，homebrew的,区别就是helm管理的是kubernetes集群内的应用。</p>
</li>
<li>
<p>还有一个概念必须得提，就是<code>chart</code>， 它代表的就是被helm管理的应用包，里面具体就是放一些预先配置的Kubernetes资源(pod, rc, deployment, service, ingress)，一个包描述文件(<code>Chart.yaml</code>), 还可以通过指定依赖来组织成更复杂的应用，支持go template语法，可参数化模板，让使用者定制化安装
charts可以存放在本地，也可以放在远端，这点理解成yum仓很合适。。。</p>
</li>
</ul>
<p>这里有个<a href=https://kubeapps.com>应用市场</a> ，里面罗列了各种应用charts。由开源项目<a href=https://github.com/helm/monocular>monocular</a>支撑</p>
<p>下面主要介绍helm的基本使用流程和具体场景的实践。</p>
<h3 id=初始化k8s集群v1-6-2>初始化k8s集群v1.6.2</h3>
<p>先来准备k8s环境，可以通过<a href=https://github.com/xiaoping378/k8s-deploy>k8s-deploy</a>项目来离线安装高可用kubernetes集群，我这里是单机演示环境。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm init --kubernetes-version v1.6.2 --pod-network-cidr 12.240.0.0/12

<span style=color:#080;font-style:italic>#方便命令自动补全</span>
<span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>

<span style=color:#080;font-style:italic>#安装cni网络</span>
cp /etc/kubernetes/admin.conf <span style=color:#b8860b>$HOME</span>/.kube/config
kubectl apply -f kube-flannel-rbac.yml
kubectl apply -f kube-flannel.yml

<span style=color:#080;font-style:italic>#使能master可以被调度</span>
kubectl taint node --all  node-role.kubernetes.io/master-

<span style=color:#080;font-style:italic>#安装ingress-controller, 边界路由作用</span>
kubectl create -f ingress-traefik-rbac.yml
kubectl create -f ingress-traefik-deploy.yml
</code></pre></div><p>这样一个比较完整的k8s环境就具备了，另外监控和日志不在此文的讨论范围内。</p>
<h3 id=初始化helm环境>初始化Helm环境</h3>
<p>由于刚才创建的k8s集群默认启用RBAC机制，个人认为这个特性是k8s真正走向成熟的一大标志，废话不表，为了helm可以安装任何应用，我们先给他最高权限。</p>
<pre tabindex=0><code>kubectl create serviceaccount helm --namespace kube-system
kubectl create clusterrolebinding cluster-admin-helm --clusterrole=cluster-admin --serviceaccount=kube-system:helm
</code></pre><p>初始化helm，如下执行，会在kube-system namepsace里安装一个tiller服务端，这个服务端就是用来解析helm语义的，后台再转成api-server的API执行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  helm init --service-account helm
<span style=color:#b8860b>$HELM_HOME</span> has been configured at /home/xxp/.helm.
Tiller <span style=color:#666>(</span>the helm server side component<span style=color:#666>)</span> has been installed into your Kubernetes Cluster.
Happy Helming!

➜  helm version
Client: &amp;version.Version<span style=color:#666>{</span>SemVer:<span style=color:#b44>&#34;v2.4.1&#34;</span>, GitCommit:<span style=color:#b44>&#34;46d9ea82e2c925186e1fc620a8320ce1314cbb02&#34;</span>, GitTreeState:<span style=color:#b44>&#34;clean&#34;</span><span style=color:#666>}</span>
Server: &amp;version.Version<span style=color:#666>{</span>SemVer:<span style=color:#b44>&#34;v2.4.1&#34;</span>, GitCommit:<span style=color:#b44>&#34;46d9ea82e2c925186e1fc620a8320ce1314cbb02&#34;</span>, GitTreeState:<span style=color:#b44>&#34;clean&#34;</span><span style=color:#666>}</span>

<span style=color:#080;font-style:italic>#命令行补全</span>
➜  <span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>helm completion zsh<span style=color:#666>)</span>
</code></pre></div><h3 id=安装第一个应用>安装第一个应用</h3>
<p>初始化Helm后，默认就导入了2个repos，后面安装和搜索应用时，都是从这2个仓里出的，当然也可以自己通过<code>helm repo add</code>添加本地私有仓</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  helm repo list
NAME  URL
stable	https://kubernetes-charts.storage.googleapis.com
<span style=color:#a2f>local</span> http://127.0.0.1:8879/charts
</code></pre></div><p>其实上面的repo仓的索引信息是存放在<code>~/.helm/repository</code>的, 类似/etc/yum.repos.d/的作用</p>
<p>helm的使用基本流程如下:</p>
<ul>
<li>helm search: 搜索自己想要安装的应用（chart）</li>
<li>helm fetch: 下载应用（chart）到本地，可以忽略此步</li>
<li>helm install: 安装应用</li>
<li>helm ls: 查看已安装的应用情况</li>
</ul>
<p>这里举例安装redis</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  helm install stable/redis --set persistence.enabled<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div><p>如上，如果网络给力的话，很快就会装上最新的redis版本，Helm安装应用，目前有四种方式：</p>
<ul>
<li><code>helm install stable/mariadb</code> 通过chart仓来安装</li>
<li><code>helm install ./nginx-1.2.3.tgz</code> 通过本地打包后的压缩chart包来安装</li>
<li><code>helm install ./nginx</code> 通过本地的chart目录来安装</li>
<li><code>helm install https://example.com/charts/nginx-1.2.3.tgz</code> 通过绝对网络地址来安装chart压缩包</li>
</ul>
<h3 id=实战演示>实战演示</h3>
<p>主要从<code>制作自己的chart</code>， <code>构建自己的repo</code>， <code>组装复杂应用的实战</code>三方面来演示</p>
<h4 id=制作自己的chart>制作自己的chart</h4>
<p>helm有一个很好的引导教程模板, 如下会自动创建一个通用的应用模板</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  helm create myapp
Creating myapp

➜  tree myapp
myapp
├── charts  //此应用包的依赖包定义（如果有的话，也会是类似此包的目录结构）
├── Chart.yaml  // 包的描述文件
├── templates  // 包的主体目录
│   ├── deployment.yaml  // kubernetes里的deployment yaml文件
│   ├── _helpers.tpl  // 模板里如果复杂的话，可能需要函数或者其他数据结构，这里就是定义的地方
│   ├── ingress.yaml // kubernetes里的ingress yaml文件
│   ├── NOTES.txt // 想提供给使用者的一些注意事项，一般提供install后，如何访问之类的信息
│   └── service.yaml // kubernetes里的service yaml文件
└── values.yaml // 参数的默认值

<span style=color:#666>2</span> directories, <span style=color:#666>7</span> files
</code></pre></div><p>如上操作，我们就有了一个<code>myapp</code>的应用，目录结构如上，来看看看values.yaml的内容, 这个里面就是模板里可定制参数的默认值</p>
<p>很容易看到，kubernetes里的rc实例数，镜像名，servie配置，路由ingress配置都可以轻松定制。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-YAML data-lang=YAML><span style=color:#080;font-style:italic># Default values for myapp.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># This is a YAML-formatted file.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Declare variables to be passed into your templates.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>replicaCount</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tag</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>internalPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Used to create Ingress record (should used with service.type: ClusterIP).</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- chart-example.local<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># kubernetes.io/ingress.class: nginx</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># kubernetes.io/tls-acme: &#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Secrets must be manually created in the namespace.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - secretName: chart-example-tls</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#   hosts:</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#     - chart-example.local</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span></code></pre></div><p>note.</p>
<blockquote>
<p>一般拿到一个现有的app chart后，这个文件是必看的，通过<code>helm fetch myapp</code>会得到一个类似上面目录的压缩包</p>
</blockquote>
<p>我们可以通过 <code>--set</code>或传入values.yaml文件来定制化安装，</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 安装myapp模板： 启动2个实例，并可通过ingress对外提供myapp.192.168.31.49.xip.io的域名访问</span>
➜  helm install --name myapp --set <span style=color:#b8860b>replicaCount</span><span style=color:#666>=</span>2,ingress.enabled<span style=color:#666>=</span>true,ingress.hosts<span style=color:#666>={</span>myapp.192.168.31.49.xip.io<span style=color:#666>}</span> ./myapp

➜  helm ls
NAME                  	REVISION	UPDATED                 	STATUS  	CHART      	NAMESPACE
exasperated-rottweiler	<span style=color:#666>1</span>       	Wed May <span style=color:#666>10</span> 13:58:56 2017	DEPLOYED	redis-0.5.2	default  
myapp                 	<span style=color:#666>1</span>       	Wed May <span style=color:#666>10</span> 21:46:51 2017	DEPLOYED	myapp-0.1.0	default

<span style=color:#080;font-style:italic>#通过传入yml文件来安装</span>
<span style=color:#080;font-style:italic>#helm install --name myapp -f myvalues.yaml ./myapp</span>
</code></pre></div><h4 id=构建私有charts-repo>构建私有charts repo</h4>
<p>通过 <code>helm repo list</code>, 得知默认的local repo地址是<code>http://127.0.0.1:8879/charts</code>， 可以简单的通过<code>helm serve</code>来操作，再或者自己起个web server也是一样的。</p>
<p>这里举例，把刚才创建的myapp放到本地仓里</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  helm search myapp
No results found
➜
➜  <span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>helm completion zsh<span style=color:#666>)</span>
➜    
➜  helm package myapp
➜  
➜  helm serve &amp;
<span style=color:#666>[</span>1<span style=color:#666>]</span> <span style=color:#666>10619</span>
➜  Regenerating index. This may take a moment.
Now serving you on 127.0.0.1:8879

➜  deis helm search myapp
NAME       	VERSION	DESCRIPTION                
local/myapp	0.1.0  	A Helm chart <span style=color:#a2f;font-weight:700>for</span> Kubernetes
</code></pre></div><p>目前个人感觉体验不太好的是，私有仓里的app必须以tar包的形式存在。</p>
<h4 id=构建复杂应用>构建复杂应用</h4>
<p>透过例子学习，会加速理解，我们从deis里的workflow应用来介绍</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  ~ helm repo add deis https://charts.deis.com/workflow
<span style=color:#b44>&#34;deis&#34;</span> has been added to your repositories
➜  ~
➜  ~ helm search workflow                               
NAME         	VERSION	DESCRIPTION  
deis/workflow	v2.14.0	Deis Workflow
➜  ~
➜  ~ helm fetch deis/workflow --untar
➜  ~ helm dep list workflow
NAME                    	VERSION	REPOSITORY                                      	STATUS  
builder                 	v2.10.1	https://charts.deis.com/builder                 	unpacked
slugbuilder             	v2.4.12	https://charts.deis.com/slugbuilder             	unpacked
dockerbuilder           	v2.7.2 	https://charts.deis.com/dockerbuilder           	unpacked
controller              	v2.14.0	https://charts.deis.com/controller              	unpacked
slugrunner              	v2.3.0 	https://charts.deis.com/slugrunner              	unpacked
database                	v2.5.3 	https://charts.deis.com/database                	unpacked
fluentd                 	v2.9.0 	https://charts.deis.com/fluentd                 	unpacked
redis                   	v2.2.6 	https://charts.deis.com/redis                   	unpacked
logger                  	v2.4.3 	https://charts.deis.com/logger                  	unpacked
minio                   	v2.3.5 	https://charts.deis.com/minio                   	unpacked
monitor                 	v2.9.0 	https://charts.deis.com/monitor                 	unpacked
nsqd                    	v2.2.7 	https://charts.deis.com/nsqd                    	unpacked
registry                	v2.4.0 	https://charts.deis.com/registry                	unpacked
registry-proxy          	v1.3.0 	https://charts.deis.com/registry-proxy          	unpacked
registry-token-refresher	v1.1.2 	https://charts.deis.com/registry-token-refresher	unpacked
router                  	v2.12.1	https://charts.deis.com/router                  	unpacked
workflow-manager        	v2.5.0 	https://charts.deis.com/workflow-manager        	unpacked

➜  ~ ls workflow
charts  Chart.yaml  requirements.lock  requirements.yaml  templates  values.yaml
</code></pre></div><p>如上操作，我们会得到一个巨型应用，实际上便是deis出品的workflow开源paas平台，具体这个平台的介绍下次有机会再分享</p>
<p>整个大型应用是通过 wofkflow/requirements.yaml组织起来的，所有依赖的chart放到charts目录，然后charts目录里就是些类似myapp的小应用</p>
<p>更复杂的应用，甚至有人把openstack用helm安装到Kubernetes上，感兴趣的可以参考<a href=https://github.com/openstack/openstack-helm>这里</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b781642b41630a327a3a5151285908a0>5 - k8s的监控方案</h1>
<div class=lead>主要介绍k8s生态中的监控方案</div>
<h2 id=方案选型>方案选型</h2>
<p>如果已存在完善的监控系统的话，推荐使用k8s原生的<strong>heapster</strong>，比较轻量，容易集成。</p>
<p>我选择的是<strong>prometheus</strong>, 它是比较完善的云平台级监控方案，继k8s之后同样已被列入<a href=https://cncf.io/projects>云计算基金会</a>项目, 除了具备heapster的能力之外，还支持监控广泛的应用(mysql, JMX, HAProxy等)和灵活的告警的能力，并具备多IDC federation的能力，兼容多种开源监控系统（StatsD, Ganglia, collectd, nagios等）。</p>
<p>本文主要参考</p>
<ul>
<li><a href=https://github.com/kubernetes/heapster/issues/645>prometheus和heapster开发者之间的对话</a></li>
<li>CoreOS的blog<a href=https://coreos.com/blog/monitoring-kubernetes-with-prometheus.html>Monitoring Kubernetes with Prometheus</a></li>
</ul>
<p>下面分别介绍下两种方案</p>
<h3 id=heapster>heapster</h3>
<ul>
<li>
<p>heapster的介绍:</p>
<p>通过向kubelet拉取stats的方式， 可提供15分钟内的缓存供k8s的dashboard用，也支持第三方存储，如influxdb等，还具备REST API(经我实验，这个API还不完善 <a href=https://github.com/kubernetes/heapster/issues/1155>缺少diskIO API</a>).</p>
</li>
<li>
<p>heapster的监控范围</p>
<p>可监控的内容包括集群内的Container, Pod, Node 和 Namespace的性能或配置信息，
目前container级别还不支持网络和硬盘信息，具体性能项如下</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Metric Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>cpu/limit</td>
<td>CPU hard limit in millicores.</td>
</tr>
<tr>
<td>cpu/node_capacity</td>
<td>Cpu capacity of a node.</td>
</tr>
<tr>
<td>cpu/node_allocatable</td>
<td>Cpu allocatable of a node.</td>
</tr>
<tr>
<td>cpu/node_reservation</td>
<td>Share of cpu that is reserved on the node allocatable.</td>
</tr>
<tr>
<td>cpu/node_utilization</td>
<td>CPU utilization as a share of node allocatable.</td>
</tr>
<tr>
<td>cpu/request</td>
<td>CPU request (the guaranteed amount of resources) in millicores.</td>
</tr>
<tr>
<td>cpu/usage</td>
<td>Cumulative CPU usage on all cores.</td>
</tr>
<tr>
<td>cpu/usage_rate</td>
<td>CPU usage on all cores in millicores.</td>
</tr>
<tr>
<td>filesystem/usage</td>
<td>Total number of bytes consumed on a filesystem.</td>
</tr>
<tr>
<td>filesystem/limit</td>
<td>The total size of filesystem in bytes.</td>
</tr>
<tr>
<td>filesystem/available</td>
<td>The number of available bytes remaining in a the filesystem</td>
</tr>
<tr>
<td>memory/limit</td>
<td>Memory hard limit in bytes.</td>
</tr>
<tr>
<td>memory/major_page_faults</td>
<td>Number of major page faults.</td>
</tr>
<tr>
<td>memory/major_page_faults_rate</td>
<td>Number of major page faults per second.</td>
</tr>
<tr>
<td>memory/node_capacity</td>
<td>Memory capacity of a node.</td>
</tr>
<tr>
<td>memory/node_allocatable</td>
<td>Memory allocatable of a node.</td>
</tr>
<tr>
<td>memory/node_reservation</td>
<td>Share of memory that is reserved on the node allocatable.</td>
</tr>
<tr>
<td>memory/node_utilization</td>
<td>Memory utilization as a share of memory allocatable.</td>
</tr>
<tr>
<td>memory/page_faults</td>
<td>Number of page faults.</td>
</tr>
<tr>
<td>memory/page_faults_rate</td>
<td>Number of page faults per second.</td>
</tr>
<tr>
<td>memory/request</td>
<td>Memory request (the guaranteed amount of resources) in bytes.</td>
</tr>
<tr>
<td>memory/usage</td>
<td>Total memory usage.</td>
</tr>
<tr>
<td>memory/working_set</td>
<td>Total working set usage. Working set is the memory being used and not easily dropped by the kernel.</td>
</tr>
<tr>
<td>network/rx</td>
<td>Cumulative number of bytes received over the network.</td>
</tr>
<tr>
<td>network/rx_errors</td>
<td>Cumulative number of errors while receiving over the network.</td>
</tr>
<tr>
<td>network/rx_errors_rate</td>
<td>Number of errors while receiving over the network per second.</td>
</tr>
<tr>
<td>network/rx_rate</td>
<td>Number of bytes received over the network per second.</td>
</tr>
<tr>
<td>network/tx</td>
<td>Cumulative number of bytes sent over the network</td>
</tr>
<tr>
<td>network/tx_errors</td>
<td>Cumulative number of errors while sending over the network</td>
</tr>
<tr>
<td>network/tx_errors_rate</td>
<td>Number of errors while sending over the network</td>
</tr>
<tr>
<td>network/tx_rate</td>
<td>Number of bytes sent over the network per second.</td>
</tr>
<tr>
<td>uptime</td>
<td>Number of milliseconds since the container was started.</td>
</tr>
</tbody>
</table>
<h3 id=prometheus>Prometheus</h3>
<p>Prometheus集成了数据采集，存储，异常告警多项功能，是一款一体化的完整方案。 它针对大规模的集群环境设计了拉取式的数据采集方式、多维度数据存储格式以及服务发现等创新功能。</p>
<h4 id=功能特点>功能特点：</h4>
<pre><code>* 多维数据模型（有metric名称和键值对确定的时间序列）
* 灵活的查询语言
* 不依赖分布式存储
* 通过pull方式采集时间序列，通过http协议传输
* 支持通过中介网关的push时间序列的方式
* 监控数据通过服务或者静态配置来发现
* 支持多维度可视化分析和dashboard等
</code></pre>
<h4 id=组件介绍>组件介绍：</h4>
<p>这个生态里包含的组件，大多是可选的：
* 核心prometheus server提供收集和存储时间序列数据
* 大量的<a href=https://prometheus.io/docs/instrumenting/clientlibs/>client libraries</a>来支持应用业务代码的探针
* 适用于短时任务的push gateway
* 基于Rails/SQL语句的可视化分析
* 特殊用途的exporter（包括HAProxy、StatsD、Ganglia等）
* 用于报警的alertmanager
* 支持命令行查询的工具
* 其他工具
大多数的组件都是用Go语言来完成的，使得它们方便构建和部署。</p>
<h4 id=架构图>架构图：</h4>
<p><img src=/prometheus-architecture.png alt=架构图></p>
<p>Promethues直接或通过短期Jobs的中介网关拉取收集指标。 它在本地存储所有抓取的数据样本，并对数据进行规则匹配检测，这样可以基于现有数据创建新的时间系列指标或生成警报。
PromDash或其他API使用者对收集的数据进行可视化。</p>
<h4 id=引入prometheus对k8s的影响>引入Prometheus对k8s的影响</h4>
<p>下图是Redhat研发人员的回答</p>
<p><img src=/prometheus-affect-k8s.png alt=promethue-affect-k8s></p>
<p>并不会对k8s产生太大的影响，其主要是通过api-server来发现需要监控的目标，然后会周期性的通过各个Node上kubelet来拉取数据。
更详细的讨论见<a href=https://github.com/prometheus/prometheus/pull/905>这里</a></p>
<h3 id=部署prometheus>部署Prometheus</h3>
<p>下文是基于<a href=https://github.com/xiaoping378/k8s-monitor>k8s-monitor项目</a>来说的</p>
<p><a href=https://prometheus.io/>Prometheus</a> is an open-source monitoring solution that includes the gathering of metrics, their storage in an internal time series database as well as querying and alerting based on that data.</p>
<p>It offers a lot of integrations incl. Docker, Kubernetes, etc.</p>
<p>Prometheus can also visualize your data. However, in this recipe we include another open-source tool, <a href=http://grafana.org/>Grafana</a>, for the visualization part, as it offers a more powerful and flexible way to generate visuals and dashboards.</p>
<p>If you just want to get Prometheus and Grafana up and running you can deploy the whole recipe with a single command instead of going through all steps detailed out below:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create --filename manifests/
</code></pre></div><h2 id=deploying-prometheus>Deploying Prometheus</h2>
<p>First, we need to create the configuration for our Prometheus. For this we use a Config Map, which we later mount into our Prometheus pod to configure it. This way we can change the configuration without having to redeploy Prometheus itself.</p>
<p><code>kubectl create --filename manifests/prometheus-core-configmap.yaml</code></p>
<p>Then, we create a service to be able to access Prometheus.</p>
<p><code>kubectl create --filename manifests/prometheus-core-service.yaml</code></p>
<p>Finally, we can deploy Prometheus itself.</p>
<p><code>kubectl create --filename manifests/prometheus-core-deployment.yaml</code></p>
<p>Further, we need the Prometheus Node Exporter deployed to each node. For this we use a Daemon Set and a fronting service for Prometheus to be able to access the node exporters.</p>
<pre tabindex=0><code>kubectl create --filename manifests/prometheus-node-exporter-service.yaml
kubectl create --filename manifests/prometheus-node-exporter-daemonset.yaml
</code></pre><p>Wait a bit for all the pods to come up. Then Prometheus should be ready and running. We can check the Prometheus targets at <a href=https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/prometheus/targets>https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/prometheus/targets</a></p>
<p><img src=/prometheus_targets.png alt="Prometheus Targets"></p>
<h2 id=deploying-alertmanager>Deploying Alertmanager</h2>
<p>we need to create the configuration for our Alertmanager. For this we use a Config Map, which we later mount into our Alertmanager pod to configure it. This way we can change the configuration without having to redeploy Alertmanager itself.</p>
<p><code>kubectl create --filename manifests/prometheus-alert-configmap.yaml</code></p>
<p>Then, we create a service to be able to access Alertmanager.</p>
<p><code>kubectl create --filename manifests/prometheus-alert-service.yaml</code></p>
<p>Finally, we can deploy Alertmanager itself.</p>
<p><code>kubectl create --filename manifests/prometheus-alert-deployment.yaml</code></p>
<p>Wait a bit for all the pods to come up. Then Alertmanager should be ready and running. We can check the Alertmanager targets at
<a href=https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/alertmanager/>https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/alertmanager/</a></p>
<p><img src=/alertmanager.png alt=Alertmanager></p>
<h2 id=deploying-grafana>Deploying Grafana</h2>
<p>Now that we have Prometheus up and running we can deploy Grafana to have a nicer frontend for our metrics.</p>
<p>Again, we create a service to be able to access Grafana and a deployment to manage the pods.</p>
<pre tabindex=0><code>kubectl create --filename manifests/grafana-services.yaml
kubectl create --filename manifests/grafana-deployment.yaml
</code></pre><p>Wait a bit for Grafana to come up. Then you can access Grafana at <a href=https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/grafana/>https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/grafana/</a></p>
<h2 id=setting-up-grafana>Setting Up Grafana</h2>
<p>TLDR: If you don't want to go through all the manual steps below you can let the following job use the API to configure Grafana to a similar state.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create --filename manifests/grafana-import-dashboards-job.yaml
</code></pre></div><p>Once we're in Grafana we need to first configure <a href=https://grafana.net/plugins/prometheus>Prometheus</a> as a data source.</p>
<ul>
<li><code>Grafana UI / Data Sources / Add data source</code>
<ul>
<li><code>Name</code>: <code>prometheus</code></li>
<li><code>Type</code>: <code>Prometheus</code></li>
<li><code>Url</code>: <code>http://prometheus:9090</code></li>
<li><code>Add</code></li>
</ul>
</li>
</ul>
<p><img src=/grafana_datasource.png alt="Grafana Datasource"></p>
<p>Then go to the Dashboards tab and import the <a href=https://grafana.net/dashboards/2>Prometheus Stats dashboard</a>, which shows the status of Prometheus itself.</p>
<p><img src=/grafana_datasource_dashboard.png alt="Grafana Datasource Dashboard"></p>
<p>You can check it out to see how your Prometheus is doing.</p>
<p><img src=/grafana_prometheus_stats.png alt="Grafana Datasource Dashboard"></p>
<p>Last, but not least we can import a sample <a href=https://grafana.net/dashboards/597>Kubernetes cluster monitoring dashboard</a>, to get a first overview over our cluster metrics.</p>
<ul>
<li><code>Grafana UI / Dashboards / Import</code>
<ul>
<li><code>Grafana.net Dashboard</code>: <code>https://grafana.net/dashboards/597</code></li>
<li><code>Load</code></li>
<li><code>Prometheus</code>: <code>prometheus</code></li>
<li><code>Save & Open</code></li>
</ul>
</li>
</ul>
<p><img src=/grafana_import_dashboard.png alt="Grafana Import Dashboard"></p>
<p>Voilá. You have a nice first dashboard with metrics of your Kubernetes cluster.</p>
<p><img src=/grafana_cluster_overview.png alt="Grafana Import Dashboard"></p>
<h2 id=next-steps>Next Steps</h2>
<p>Next, you should get into the <a href=http://docs.grafana.org/>Grafana</a> and <a href=https://prometheus.io/docs/introduction/overview/>Prometheus</a> documentations to get to know the tools and either build your own dashboards or extend the samples from above.</p>
<p>You can also check out grafana.net for some more example <a href=https://grafana.net/dashboards>dashboards</a> and <a href=https://grafana.net/plugins>plugins</a>.</p>
<p>More Alertmanager documentations in <a href=https://prometheus.io/docs/alerting/overview/>here</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e7d513396d808a4808b498da552726e0>6 - 配置harbor默认https访问</h1>
<div class=lead>主要介绍k8s生态中镜像仓的https访问方案</div>
<p>因为使用自签证书（reg.300.cn），所以需要把中间过程生成的ca.crt拷贝到需要pull/push的node上 (懒的翻译了，很详细的文档，已验证OK)</p>
<p>Because Harbor does not ship with any certificates, it uses HTTP by default to serve registry requests. This makes it relatively simple to configure. However, it is highly recommended that security be enabled for any production environment. Harbor has an Nginx instance as a reverse proxy for all services, you can configure Nginx to enable https.</p>
<p>##Getting a certificate</p>
<p>Assuming that your registry's <strong>hostname</strong> is <strong>reg.yourdomain.com</strong>, and that its DNS record points to the host where you are running Harbor. You first should get a certificate from a CA. The certificate usually contains a .crt file and a .key file, for example, <strong>yourdomain.com.crt</strong> and <strong>yourdomain.com.key</strong>.</p>
<p>In a test or development environment, you may choose to use a self-signed certificate instead of the one from a CA. The below commands generate your own certificate:</p>
<ol>
<li>Create your own CA certificate:</li>
</ol>
<pre tabindex=0><code>  openssl req \
    -newkey rsa:4096 -nodes -sha256 -keyout ca.key \
    -x509 -days 365 -out ca.crt
</code></pre><ol start=2>
<li>Generate a Certificate Signing Request:</li>
</ol>
<p>If you use FQDN like <strong>reg.yourdomain.com</strong> to connect your registry host, then you must use <strong>reg.yourdomain.com</strong> as CN (Common Name).
Otherwise, if you use IP address to connect your registry host, CN can be anything like your name and so on:</p>
<pre tabindex=0><code>  openssl req \
    -newkey rsa:4096 -nodes -sha256 -keyout yourdomain.com.key \
    -out yourdomain.com.csr
</code></pre><ol start=3>
<li>Generate the certificate of your registry host:</li>
</ol>
<p>On Ubuntu, the config file of openssl locates at <strong>/etc/ssl/openssl.cnf</strong>. Refer to openssl document for more information. The default CA directory of openssl is called demoCA. Let's create necessary directories and files:</p>
<pre tabindex=0><code>  mkdir demoCA
  cd demoCA
  touch index.txt
  echo '01' &gt; serial
  cd ..
</code></pre><p>If you're using FQDN like <strong>reg.yourdomain.com</strong> to connect your registry host, then run this command to generate the certificate of your registry host:</p>
<pre tabindex=0><code>  openssl ca -in yourdomain.com.csr -out yourdomain.com.crt -cert ca.crt -keyfile ca.key -outdir .
</code></pre><p>If you're using <strong>IP</strong> to connect your registry host, you may instead run the command below:</p>
<pre tabindex=0><code>
  echo subjectAltName = IP:your registry host IP &gt; extfile.cnf

  openssl ca -in yourdomain.com.csr -out yourdomain.com.crt -cert ca.crt -keyfile ca.key -extfile extfile.cnf -outdir .
</code></pre><p>##Configuration of Nginx
After obtaining the <strong>yourdomain.com.crt</strong> and <strong>yourdomain.com.key</strong> files, change the directory to Deploy/config/nginx in Harbor project.</p>
<pre tabindex=0><code>  cd Deploy/config/nginx
</code></pre><p>Create a new directory cert/, if it does not exist. Then copy <strong>yourdomain.com.crt</strong> and <strong>yourdomain.com.key</strong> to cert/, e.g. :</p>
<pre tabindex=0><code>  cp yourdomain.com.crt cert/
  cp yourdomain.com.key cert/
</code></pre><p>Rename the existing configuration file of Nginx:</p>
<pre tabindex=0><code>  mv nginx.conf nginx.conf.bak
</code></pre><p>Copy the template <strong>nginx.https.conf</strong> as the new configuration file:</p>
<pre tabindex=0><code>  cp nginx.https.conf nginx.conf
</code></pre><p>Edit the file nginx.conf and replace two occurrences of <strong>harbordomain.com</strong> to your own host name, such as reg.yourdomain.com . If you use a customized port rather than the default port 443, replace the port "443" in the line "rewrite ^/(.*) https://$server_name:443/$1 permanent;" as well. Please refer to the <a href=https://github.com/vmware/harbor/blob/master/docs/installation_guide.md>installation guide</a> for other required steps of port customization.</p>
<pre tabindex=0><code>  server {
    listen 443 ssl;
    server_name harbordomain.com;

    ...

  server {
    listen 80;
    server_name harbordomain.com;
    rewrite ^/(.*) https://$server_name:443/$1 permanent;
</code></pre><p>Then look for the SSL section to make sure the files of your certificates match the names in the config file. Do not change the path of the files.</p>
<pre tabindex=0><code>    ...

    # SSL
    ssl_certificate /etc/nginx/cert/yourdomain.com.crt;
    ssl_certificate_key /etc/nginx/cert/yourdomain.com.key;
</code></pre><p>Save your changes in nginx.conf.</p>
<p>##Installation of Harbor
Next, edit the file Deploy/harbor.cfg , update the hostname and the protocol:</p>
<pre tabindex=0><code>  #set hostname
  hostname = reg.yourdomain.com
  #set ui_url_protocol
  ui_url_protocol = https
</code></pre><p>Generate configuration files for Harbor:</p>
<pre tabindex=0><code>./prepare
</code></pre><p>If Harbor is already running, stop and remove the existing instance. Your image data remain in the file system</p>
<pre tabindex=0><code>  docker-compose stop
  docker-compose rm
</code></pre><p>Finally, restart Harbor:</p>
<pre tabindex=0><code>  docker-compose up -d
</code></pre><p>After setting up HTTPS for Harbor, you can verify it by the following steps:</p>
<ol>
<li>
<p>Open a browser and enter the address: <a href=https://reg.yourdomain.com>https://reg.yourdomain.com</a> . It should display the user interface of Harbor.</p>
</li>
<li>
<p>On a machine with Docker daemon, make sure the option "-insecure-registry" does not present, and you must copy ca.crt generated in the above step to <strong>/etc/docker/certs.d/yourdomain.com</strong>(or your registry host IP), if the directory does not exist, create it.
If you mapped nginx port 443 to another port, then you should instead create the directory /etc/docker/certs.d/yourdomain.com:port(or your registry host IP:port). Then run any docker command to verify the setup, e.g.</p>
</li>
</ol>
<pre tabindex=0><code>  docker login reg.yourdomain.com
</code></pre><p>If you've mapped nginx 443 port to another, you need to add the port to login, like below:</p>
<pre tabindex=0><code>  docker login reg.yourdomain.com:port
</code></pre><p>##Troubleshooting</p>
<ol>
<li>
<p>You may get an intermediate certificate from a certificate issuer. In this case, you should merge the intermediate certificate with your own certificate to create a certificate bundle. You can achieve this by the below command:</p>
<pre tabindex=0><code>cat intermediate-certificate.pem &gt;&gt; yourdomain.com.crt
</code></pre></li>
<li>
<p>On some systems where docker daemon runs, you may need to trust the certificate at OS level.
On Ubuntu, this can be done by below commands:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>cp youdomain.com.crt /usr/local/share/ca-certificates/reg.yourdomain.com.crt
update-ca-certificates
</code></pre></div><p>On Red Hat (CentOS etc), the commands are:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>cp yourdomain.com.crt /etc/pki/ca-trust/source/anchors/reg.yourdomain.com.crt
update-ca-trust
</code></pre></div></li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9defb3943138a8ddf6afc76610480f39>7 - DEIS 开源PAAS平台实践</h1>
<div class=lead>DEIS 开源的PAAS平台实践总结。</div>
<p>DEIS（目前已被微软收购）的workflow是开源的Paas平台，基于kubernetes做了一层面向开发者的CLI和接口，做到了让开发者对容器无感知的情况下快速的开发和部署线上应用。</p>
<blockquote>
<p>workflow是 on top of k8s的，所有组件默认全是跑在pod里的，不像openshift那样对k8s的侵入性很大。</p>
</blockquote>
<p>特性如下：</p>
<ul>
<li>S2I(自动识别源码直接编译成镜像)</li>
<li>日志聚合</li>
<li>应用管理（发布，回滚）</li>
<li>认证&授权机制</li>
<li>边界路由</li>
</ul>
<p><img src=/Workflow_Detail.png alt=Workflow_Detail></p>
<p>下面从环境搭建，安装workflow及其基本使用做个梳理。</p>
<h3 id=初始化k8s集群>初始化k8s集群</h3>
<p>可以通过<a href=https://github.com/xiaoping378/k8s-deploy>k8s-deploy</a>项目来离线安装高可用kubernetes集群，我这里是单机演示环境。</p>
<pre><code>kubeadm init --kubernetes-version v1.6.2 --pod-network-cidr 12.240.0.0/12
#方便命令自动补全
source &lt;(kubectl completion zsh)

#安装cni网络
cp /etc/kubernetes/admin.conf $HOME/.kube/config
kubectl apply -f kube-flannel-rbac.yml
kubectl apply -f kube-flannel.yml

#使能master可以被调度
kubectl taint node --all  node-role.kubernetes.io/master-

#安装ingress-controller, 边界路由作用
kubectl create -f ingress-traefik-rbac.yml
kubectl create -f ingress-traefik-deploy.yml
</code></pre>
<h3 id=初始化helm>初始化helm</h3>
<p>helm相当于kubernetes里的包管理器，类似yum和apt的作用，只不过它操作的是charts（各种k8s yaml文件的集合，额外还有Chart.yaml -- 包的描述文件）可以理解为基于k8s的应用模板管理类工具， 后面会用它来安装workflow到上面跑起来的k8s集群里。</p>
<p>从k8s 1.6之后，kubeadm安装的集群，默认会开启RBAC机制，为了让helm可以安装任何应用，我们这里赋予tiller cluster-admin权限</p>
<pre><code>kubectl create serviceaccount helm --namespace kube-system
kubectl create clusterrolebinding cluster-admin-helm --clusterrole=cluster-admin --serviceaccount=kube-system:helm
</code></pre>
<p>初始化helm：</p>
<pre><code>➜  helm init --service-account helm
$HELM_HOME has been configured at /home/xxp/.helm.

Tiller (the helm server side component) has been installed into your Kubernetes Cluster.
Happy Helming!

➜  helm version
Client: &amp;version.Version{SemVer:&quot;v2.4.1&quot;, GitCommit:&quot;46d9ea82e2c925186e1fc620a8320ce1314cbb02&quot;, GitTreeState:&quot;clean&quot;}
Server: &amp;version.Version{SemVer:&quot;v2.4.1&quot;, GitCommit:&quot;46d9ea82e2c925186e1fc620a8320ce1314cbb02&quot;, GitTreeState:&quot;clean&quot;}
</code></pre>
<p>安装后，默认导入了2个repos，后面安装和搜索应用时，都是从这2个仓里出的，当然也可以自己通过<code>helm repo add</code>添加本地私有仓</p>
<pre><code>➜  helm repo list
NAME  	URL                                             
stable	https://kubernetes-charts.storage.googleapis.com
local 	http://127.0.0.1:8879/charts                    
</code></pre>
<p>helm的使用基本流程如下:</p>
<ul>
<li>helm search: 搜索自己想要安装的应用（chart）</li>
<li>helm fetch: 下载应用（chart）到本地，可以忽略此步</li>
<li>helm install: 安装应用</li>
<li>helm list: 查看已安装的应用情况</li>
</ul>
<h3 id=安装workflow>安装workflow</h3>
<p>添加workflow的repo仓</p>
<pre><code>helm repo add deis https://charts.deis.com/workflow
</code></pre>
<p>开始安装workflow，因为RBAC的原因，同样要赋予workflow各组件相应的权限，yml文件在[这里]（https://gist.github.com/xiaoping378/798c39e0b607be4130db655f4873bd24）</p>
<pre><code>kubectl apply -f workflow-rbac.yml --namespace deis

helm install deis/workflow --name workflow --namespace deis \
  --set global.experimental_native_ingress=true,controller.platform_domain=192.168.31.49.xip.io
</code></pre>
<p>其中会拉取所需镜像，不出意外会有如下结果：</p>
<pre><code>➜  kubectl --namespace=deis get pods
NAME                                     READY     STATUS    RESTARTS   AGE
deis-builder-1134410811-11xpp            1/1       Running   0          46m
deis-controller-2000207379-5wr10         1/1       Running   1          46m
deis-database-244447703-v2sh9            1/1       Running   0          46m
deis-logger-2533678197-pzmbs             1/1       Running   2          46m
deis-logger-fluentd-08hms                1/1       Running   0          42m
deis-logger-redis-1307646428-fz1kk       1/1       Running   0          46m
deis-minio-3195500219-tv7wz              1/1       Running   0          46m
deis-monitor-grafana-59098797-mdqh1      1/1       Running   0          46m
deis-monitor-influxdb-168332144-24ngs    1/1       Running   0          46m
deis-monitor-telegraf-vgbr9              1/1       Running   0          41m
deis-nsqd-1042535208-40fkm               1/1       Running   0          46m
deis-registry-2249489191-2jz3p           1/1       Running   2          46m
deis-registry-proxy-qsqc2                1/1       Running   0          46m
deis-router-3258454730-3rfpq             1/1       Running   0          41m
deis-workflow-manager-3582051402-m11zn   1/1       Running   0          46m
</code></pre>
<h3 id=注册管理用户>注册管理用户</h3>
<p>由于我们是本地ingress-controller, 必须保障deis-builder.$host可以被解析, 自行创建ingress of deis-builder.</p>
<pre><code>kubectl apply -f deis-buidler-ingress.yml
</code></pre>
<p>确保traefik有如下状态：</p>
<p><img src=/traefik-status.png alt=traefik-status></p>
<p>如下操作注册，默认第一个用户为管理员用户，可操作所有其他用户。</p>
<pre><code>➜  ~ kubectl get --namespace deis ingress
NAME                                 HOSTS                               ADDRESS   PORTS     AGE
builder-api-server-ingress-http      deis-builder.192.168.31.49.xip.io             80        18m
controller-api-server-ingress-http   deis.192.168.31.49.xip.io                     80        1h
➜  ~
➜  ~ deis register deis.192.168.31.49.xip.io
username: admin  
password:
password (confirm):
email: xiaoping378@163.com
Registered admin
Logged in as admin
Configuration file written to /home/xxp/.deis/client.json
➜  ~
➜  ~ deis whoami
You are admin at http://deis.192.168.31.49.xip.io
</code></pre>
<h3 id=部署第一个应用>部署第一个应用</h3>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e3c9486bfc693b58c1c315d2c7cde322>8 - k3s实践-01</h1>
<div class=lead>k3s的安装及基本工作方式解读</div>
<div class="pageinfo pageinfo-primary">
<p>本文主要介绍k3s的安装和核心组件解读。</p>
</div>
<p>k3s是all-in-one的轻量k8s发行版，把所有k8s组件打包成一个不到100M的二进制文件了。具备如下显著特点：</p>
<ul>
<li>打包成单一二进制</li>
<li>默认集成了sqlite3来替代etcd，也可以指定其他数据库：etcd3、mysql、postgres。</li>
<li>默认内置Coredns、Metrics Server、Flannel、Traefik ingress、Local-path-provisioner等</li>
<li>默认启用了TLS加密通信。</li>
</ul>
<h2 id=安装>安装</h2>
<p>官方提供了一键安装脚本<a href=https://get.k3s.io>install.sh</a> ，执行<code>curl -sfL https://get.k3s.io | sh -</code>可一键安装server端。此命令会从<code>https://update.k3s.io/v1-release/channels/stable</code>取到最新的稳定版安装，可以通过<code>INSTALL_K3S_VERSION</code>环境变量指定版本，本文将以1.19为例。</p>
<p><strong>启动 k3s server端(master节点).</strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -sfL https://get.k3s.io | <span style=color:#b8860b>INSTALL_K3S_VERSION</span><span style=color:#666>=</span>v1.19.16+k3s1 sh -
</code></pre></div><blockquote>
<p>由于网络原因，可能会失败，自行想办法<a href=https://github.com/k3s-io/k3s/releases/download/v1.19.16+k3s1/k3s>下载</a>下来，放置 <code>/usr/local/bin/k3s</code>，附上执行权限<code>chmod a+x /usr/local/bin/k3s</code>, 然后上面的命令加上<code>INSTALL_K3S_SKIP_DOWNLOAD=true</code>再执行一遍即可。</p>
</blockquote>
<blockquote>
<p>安装里log里会输出一些重要信息: <code>kubectl、crictl、卸载脚本、systemd service</code></p>
</blockquote>
<p>不出意外，k3s server会被systemd启动，执行命令查看<code>systemctl status k3s</code>或者通过软链的kubectl验证是否启动成功：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  kubectl get no
NAME            STATUS   ROLES    AGE     VERSION
gitlab-server   Ready    master   6m43s   v1.19.16+k3s1
</code></pre></div><p><strong>(Optional)</strong> 启动 k3s agent端 (添加worker节点).</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -sfL https://get.k3s.io | <span style=color:#b8860b>K3S_URL</span><span style=color:#666>=</span>https://172.25.11.130:6443 <span style=color:#b8860b>K3S_TOKEN</span><span style=color:#666>=</span>bulabula <span style=color:#b8860b>INSTALL_K3S_VERSION</span><span style=color:#666>=</span>v1.19.16+k3s1 sh -
</code></pre></div><ul>
<li><code>K3S_TOKEN</code>内容需要从server端的<code>/var/lib/rancher/k3s/server/node-token</code>文件取出</li>
<li><code>K3S_URL</code>中的IP是master节点的IP。</li>
</ul>
<h2 id=集群访问>集群访问</h2>
<p>默认kubectl通过localhost访问本地集群，所以上文敲kubectl是没问题的，如果要被外部访问或者纳管的话，可以把kubeconfig文件拷走，默认路径是 <code>/etc/rancher/k3s/k3s.yaml</code>
。记得修改文件内的server字段，改成外部可访问到的IP。</p>
<h2 id=架构说明>架构说明</h2>
<p>TODO.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-03baa014ac348ea7e2865ceaf8dacda4>9 - kubeshere 自研-01</h1>
<div class=lead>自研系列文章整理。</div>
<div class="pageinfo pageinfo-primary">
<p>kubesphere 自研环境篇</p>
</div>
<h2 id=心态>心态</h2>
<p>首先调整心态，这是一个新的生态，秉承学习的心态。</p>
<h2 id=准备环境>准备环境</h2>
<ul>
<li>clone代码</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/kubesphere/kubesphere.git
</code></pre></div><ul>
<li>准备开发环境</li>
</ul>
<p><a href=https://github.com/kubesphere/community/blob/master/developer-guide/development/quickstart.md>启动快速开发环境</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8d71550d3ee2751c7f80b3cef9ae8232>10 - TKEStack all-in-one入坑指南</h1>
<div class=lead>TkeStack的all-in-one安装、多租户和多集群管理功能解读。</div>
<div class="pageinfo pageinfo-primary">
<p>本文主要介绍当前最新版本TkeStack 1.8.1 的TKEStack的all-in-one安装、多租户和多集群管理功能解读。</p>
</div>
<h2 id=安装实录>安装实录</h2>
<p>官方推荐至少需要2节点方可安装，配置如下，<strong>硬盘空间</strong>一定要保障。也支持ALL-in-ONE的方式安装，但有BUG。</p>
<p><img src=/images/TKEStack-allinone-2022-01-25-08-47-30.png alt></p>
<h2 id=启动init服务>启动init服务</h2>
<p>启动init服务，即安装tke-installer和registry服务，安装命令行如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>arch</span><span style=color:#666>=</span>amd64 <span style=color:#b8860b>version</span><span style=color:#666>=</span>v1.8.1 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> wget https://tke-release-1251707795.cos.ap-guangzhou.myqcloud.com/tke-installer-linux-<span style=color:#b8860b>$arch</span>-<span style=color:#b8860b>$version</span>.run<span style=color:#666>{</span>,.sha256<span style=color:#666>}</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> sha256sum --check --status tke-installer-linux-<span style=color:#b8860b>$arch</span>-<span style=color:#b8860b>$version</span>.run.sha256 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> chmod +x tke-installer-linux-<span style=color:#b8860b>$arch</span>-<span style=color:#b8860b>$version</span>.run <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    <span style=color:#666>&amp;&amp;</span> ./tke-installer-linux-<span style=color:#b8860b>$arch</span>-<span style=color:#b8860b>$version</span>.run  
</code></pre></div><p>如上命令执行后，会下载8G左右的安装包，并执行解压后的install.sh脚本，启动3个容器：1个为tke-installer和另2个为registry仓，且为containerd容器，需要使用<code>nerdctl [images | ps]</code>等命令查看相关信息。</p>
<p>通过查看脚本，上文启动的本地registry的启动命令等效如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>nerdctl run --name registry-https -d --net<span style=color:#666>=</span>host --restart<span style=color:#666>=</span>always -p 443:443 <span style=color:#b62;font-weight:700>\ </span> 
    -v /opt/tke-installer/registry:/var/lib/registry <span style=color:#b62;font-weight:700>\ </span> 
    -v registry-certs:/certs <span style=color:#b62;font-weight:700>\ </span> 
    -e <span style=color:#b8860b>REGISTRY_HTTP_ADDR</span><span style=color:#666>=</span>0.0.0.0:443 <span style=color:#b62;font-weight:700>\ </span> 
    -e <span style=color:#b8860b>REGISTRY_HTTP_TLS_CERTIFICATE</span><span style=color:#666>=</span>/certs/server.crt <span style=color:#b62;font-weight:700>\ </span> 
    -e <span style=color:#b8860b>REGISTRY_HTTP_TLS_KEY</span><span style=color:#666>=</span>/certs/server.key  <span style=color:#b62;font-weight:700>\ </span> 
    tkestack/registry-amd64:2.7.1  
</code></pre></div><p>还有个http 80的registry，这里不贴了，后面的部分坑，就是这里埋下的，预先占用了节点的80和443端口，后面tke的gateway pod会启动失败。</p>
<h2 id=启动tke集群>启动TKE集群</h2>
<p>上章节执行完后，会启动tke-installer（一个web操作台），通过访问本地8080端口，可访问界面操作安装global集群。按照官方指引操作就行，此处不表。另外需要说明的是在安装过程中，如果要查看本地容器，不能使用<code>docker ps</code>了，需要使用<code>nerdctl -n k8s.io ps</code>。整个安装过程是使用ansible和kubeadm完成的，kubelet是通过systemd启动的，k8s组件为静态pod。</p>
<p>因为我是使用的ALL-in-ONE安装，遇到了不少问题，可详见FAQ如何解决。安装成功后会提示如下指引：
<img src=/images/TKEStack-allinone-2022-01-25-09-10-56.png alt></p>
<p>默认初始安装后，很多pod是双副本的，我这里仅是验证功能使用，全部改成了单副本。</p>
<h2 id=多租户管理>多租户管理</h2>
<p>tkestack采用<a href=/docs/3-devops/casbin>Casbin框架</a>实现的权限管理功能，默认集成的Model，查看<a href=https://github.com/tkestack/tke/blob/a024c064880d9180dc8b6d615ffc58b64bb7f903/api/auth/types.go#L633>源码</a>得知：</p>
<pre tabindex=0><code class=language-Conf data-lang=Conf>[request_definition]
r = sub, dom, obj, act
[policy_definition]
p = sub, dom, obj, act, eft
[role_definition]
g = _, _, _
[policy_effect]
e = some(where (p.eft == allow)) &amp;&amp; !some(where (p.eft == deny))
[matchers]
m = g(r.sub, p.sub, r.dom) &amp;&amp; keyMatchCustom(r.obj, p.obj) &amp;&amp; keyMatchCustom(r.act, p.act)
</code></pre><p>实现了多租户级的RBAC权限模型。</p>
<h2 id=faq>FAQ</h2>
<h3 id=安装过程出现循环等待apiserver启动>安装过程出现循环等待apiserver启动</h3>
<pre tabindex=0><code class=language-log data-lang=log>2022-01-19 14:43:32.225 error   tke-installer.ClusterProvider.OnCreate.EnsureKubeadmInitPhaseWaitControlPlane   check healthz error {&quot;statusCode&quot;: 0, &quot;error&quot;: &quot;Get \&quot;https://****:6443/healthz?timeout=30s\&quot;: net/http: TLS handshake timeout&quot;}
</code></pre><p>我这里是因为在installer上指定的master的IP为外网IP（我使用外网IP是有原因的，穷... 后面需要跨云厂商组集群），通过查看kubelet日志提示本机找不到IP，如下开启网卡多IP，可通过。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ip addr add 118.*.*.* dev eth0
</code></pre></div><h3 id=gateway-pod启动失败>Gateway POD启动失败</h3>
<p>我这里是因为init节点和gobal master节点，共用了一个，本registry服务占用了80和443端口，需要修改gateway hostNetwork为false，另外可以通过修改svc 为nodePort，还需要修改targetPort，官方现在这里有bug，不知道为指到944*的端口上，我这里设置的30080来访问安装好的集群。</p>
<h3 id=页面登录错误unregistered-redirect-uri>页面登录错误Unregistered redirect_uri</h3>
<p>官方没有相关说明，一切都是ALL-in-ONE的原因，我改动了默认集群console的访问端口为30080。。。 通过查看源码发现是每次认证时dex会校验tke-auth-api向它注册过的合法client地址。于是我就修改了tke命名空间下tke-auth-api的相关configmap：</p>
<p><img src=/images/TKEStack-allinone-2022-01-25-09-47-16.png alt></p>
<p>重启tke-auth-api后，问题依旧存在，继续源码走查，发现这玩意儿叫init真的只发挥一次作用，改完配置，不会重新读取，细读逻辑发现etcd中不存在这个key，会重新读取写入一次，于是决定删除etcd中的相关key。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>etcdctl --cacert<span style=color:#666>=</span>/etc/kubernetes/pki/etcd/ca.crt --cert<span style=color:#666>=</span>/etc/kubernetes/pki/apiserver-etcd-client.crt --key<span style=color:#666>=</span>/etc/kubernetes/pki/apiserver-etcd-client.key del /tke/auth-api/client/default  --prefix
</code></pre></div><h3 id=添加节点的过程中failed-无法删除节点重试>添加节点的过程中failed，无法删除节点重试</h3>
<p>ssh信息设置完后，如果中间出问题，会陷入无限重试...</p>
<p><img src=/images/TKEStack-allinone-2022-01-25-09-48-43.png alt></p>
<p>遇事不决，看日志，找不到日志，看源码...</p>
<p>通过翻找源码，发现是<code>platform</code>相关组件在负责，查看相关日志<code>kubectl -n logs tke-platform-controller-*** --tail 100 -f</code>，定位问题，我这里是以前各种安装的残留信息，导致添加节点初始化失败。删除之... 解决。</p>
<p>为避免添加节点<code>no clean</code>再次出现问题，建议预先执行下<a href=https://tke-release-1251707795.cos.ap-guangzhou.myqcloud.com/tools/clean.sh>clean.sh</a>脚本。</p>
<h2 id=小技巧>小技巧</h2>
<p>如下使用，可以愉快的敲命令了，因为我是用oh-my-zsh的shell主题(没有自动加载kubectl plugin)，kubectl的命令补全使用zsh，可根据实际情况调整。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>nerdctl completion bash<span style=color:#666>)</span>  
<span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span> 
</code></pre></div>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="个人邮箱 xiaoping378@163.com" aria-label="个人邮箱 xiaoping378@163.com">
<a class=text-white target=_blank rel=noopener href=mailto:xiaoping378@163.com aria-label="个人邮箱 xiaoping378@163.com">
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=微博 aria-label=微博>
<a class=text-white target=_blank rel=noopener href=https://weibo.com/xiaoping378 aria-label=微博>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=知乎 aria-label=知乎>
<a class=text-white target=_blank rel=noopener href=https://www.zhihu.com/people/xiaoping378 aria-label=知乎>
<i class="fab fa-zhihu"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel=noopener href=https://github.com/xiaoping378/xiaoping378.github.io aria-label=GitHub>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank rel=noopener href=https://example.org/slack aria-label=Slack>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list">
<a class=text-white target=_blank rel=noopener href=https://example.org/mail aria-label="Developer mailing list">
<i class="fa fa-envelope"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2022 xiaoping378 保留所有权利</small>
<small class=ml-1><a href=# target=_blank rel=noopener>隐私政策</a></small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA==" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script>
<script src=/js/deflate.js></script>
<script src=/js/main.min.e016890ed6b0c42f5af3410eb57ac626a192a868609aee68cefe1e0f84a50b13.js integrity="sha256-4BaJDtawxC9a80EOtXrGJqGSqGhgmu5ozv4eD4SlCxM=" crossorigin=anonymous></script>
</body>
</html>