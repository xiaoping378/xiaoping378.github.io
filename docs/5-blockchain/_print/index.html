<!doctype html><html lang=zh-cn class=no-js>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.91.2">
<link rel=canonical type=text/html href=https://xiaoping378.github.io/docs/5-blockchain/>
<link rel=alternate type=application/rss+xml href=https://xiaoping378.github.io/docs/5-blockchain/index.xml>
<meta name=robots content="noindex, nofollow">
<link rel="shortcut icon" href=/favicons/favicon.ico>
<title>区块链 | 现代技能栈</title>
<meta name=description content="区块链领域的所思所为!
">
<meta property="og:title" content="区块链">
<meta property="og:description" content="区块链领域的所思所为!
">
<meta property="og:type" content="website">
<meta property="og:url" content="https://xiaoping378.github.io/docs/5-blockchain/"><meta property="og:site_name" content="现代技能栈">
<meta itemprop=name content="区块链">
<meta itemprop=description content="区块链领域的所思所为!
"><meta name=twitter:card content="summary">
<meta name=twitter:title content="区块链">
<meta name=twitter:description content="区块链领域的所思所为!
">
<link rel=preload href=/scss/main.min.9f63fcc1b5f091883eb4c0c66b7bddf337a299d08451443230a201303e53b01c.css as=style>
<link href=/scss/main.min.9f63fcc1b5f091883eb4c0c66b7bddf337a299d08451443230a201303e53b01c.css rel=stylesheet integrity>
<script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<script src=/js/lunr.min.js integrity=sha384-vRQ9bDyE0Wnu+lMfm57BlYLO0/XauFuKpVsZPs7KEDwYKktWi5+Kz3MP8++DFlRY crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-217913492-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
<a class=navbar-brand href=/>
<span class=navbar-logo></span><span class="text-uppercase font-weight-bold">现代技能栈</span>
</a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/about/><span>关于</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class="nav-link active" href=/docs/><span class=active>文档</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/blog/><span>博客</span></a>
</li>
<li class="nav-item mr-4 mb-2 mb-lg-0">
<a class=nav-link href=/community/><span>社区</span></a>
</li>
</ul>
</div>
<div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off data-offline-search-index-json-src=/offline-search-index.e77579ee1fd5ba0bd3f60936ebbb94a2.json data-offline-search-base-href=/ data-offline-search-max-results=10>
</div>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/docs/5-blockchain/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>区块链</h1>
<div class=lead>区块链领域的所思所为!</div>
<ul>
<li>1: <a href=#pg-92a9f0a8dd0dec3be5f2aab0480287a1>什么是以太坊</a></li>
<li>2: <a href=#pg-3b56f6ee89ab0e0ddb4c851274991a28>搭建以太坊私链网络</a></li>
<li>3: <a href=#pg-bc311f0f5a9779af3ad781d3d3573055>以太坊的truffle box开发实战</a></li>
<li>4: <a href=#pg-cff6c067f38087f593256a9b98010b27>fomo3d-上线部署要点</a></li>
<li>5: <a href=#pg-b343ce2ae51ef80e6d4361ca04ac169e>fomo3d-钱都去哪儿了</a></li>
<li>6: <a href=#pg-0bd51907ec255a7703ff0301867ca861>解读cosmos-sdk系列(1)</a></li>
<li>7: <a href=#pg-32977a59316b6013d93871144450ab9a>farbic-搭建高并发交易网络</a></li>
<li>8: <a href=#pg-cac9c2797f26b94f2afbcd6111d170ec>fabric-示例集群化操作</a></li>
<li>9: <a href=#pg-e0463540a4a1848ab0876eb50d314c9f>farbic-区块链的生产集群化</a></li>
</ul>
<div class=content>
<div class="pageinfo pageinfo-primary">
<p>存放些曾经在区块链界战斗过的痕迹。</p>
</div>
</div>
</div>
<div class=td-content>
<h1 id=pg-92a9f0a8dd0dec3be5f2aab0480287a1>1 - 什么是以太坊</h1>
<div class=lead>介绍以太坊公链</div>
<h3 id=目录>目录</h3>
<ol>
<li>什么是以太坊</li>
<li>应用场景</li>
<li>趋势展望</li>
</ol>
<h3 id=内容>内容</h3>
<p>1.什么是以太坊</p>
<p>以太坊是一个全新开放的区块链平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p>
<p>1.1. 从名字说起</p>
<p>以太坊 == ethereum，</p>
<p>Ether，物理学里面有个以太，绝对静止的存在于空间的那种物质，尚未证明是否真实存在，在某领域里，它被称为虚空，空间…是一种能承载万物的东西，是一种目前还难以解释和观察的东西。</p>
<p>至于这个“坊”字，也不知道是谁先翻译叫起来的，反正现在大家都这么叫。</p>
<p>1.2 从功能说起</p>
<p><a href=https://www.ethereum.org/ether>以太</a>是区块链网络里很重要的元素 -- 燃料 -- 以太币，为计算付费。</p>
<pre><code>1. 开发人员发布Dapp
2. 用户和Dapp交互
3. 挖矿得到报酬（维持网络稳定的）
4. 金融交易
</code></pre>
<p>1.3 从产出</p>
<ul>
<li>2014年9月份预售阶段发了6千万以太币，（募集到 31,531 个比特币）</li>
<li>其中20%用于以太基金的运作，主要是给开发人员发工资。</li>
<li>挖矿，大概每15秒左右出一个块，作为报酬，出块的人可以得到5个以太</li>
<li>打包叔块的人会得到2-3个以太</li>
</ul>
<p>自从<a href=https://blog.ethereum.org/2017/10/12/byzantium-hf-announcement/>Byzantium update</a>升级后，现在挖矿和挖到叔块的人会分别得到3和0.625-2.625个以太。</p>
<p>1.4 FAQ</p>
<p>1.4.1 以太比会无限发行么？</p>
<p>不会， 当时预售的时候规定，每年的发行量是1800万上限（被挖到），计划在17年底，会切换共识算法从POW到<a href=https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/>Casper</a>上，之后出块效率更高，需要的挖矿补贴更少, 具体发行多少，现在还未定。</p>
<p>1.4.2 以太币和比特币的对比？</p>
<p>如果后者，以太币是不可能实现的，在整个数字生态是互补关系，Ether应被视为“加密燃料”，其目的是为计算付费，而不是用作或被视为货币，资产，份额或其他任何东西。</p>
<p><img src=https://www.ethereum.org/images/bitcoin-and-ethereum-sitting-on-a-tree@2x.png alt></p>
<p>技术层面的对比</p>
<p><img src=/BTC-ETH.png alt></p>
<p>1.2 账户</p>
<p>以太坊有两种类型的账户：</p>
<ul>
<li>外部账户（由私钥控制的）</li>
<li>合约账户（由合约代码控制）。</li>
</ul>
<p>另种账户都可以发起交易，后者被动发送。</p>
<p>外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p>
<p>UTXOs的好处有：
更加私密（用户要是每笔交易都换一个地址，那么就很难找到其中两个地址的相关性）；潜在的可扩展性。</p>
<p>账户的好处：
节省大量空间（每笔交易只有一个输入、一个输出、一个签名）；更大的可替代性；简单（编码简单，不需要更为复杂脚本）；</p>
<p>1.3 以太坊虚拟机EVM</p>
<p>1.4 挖矿</p>
<p>1.5 网络</p>
<p>目前有主链和测试链之分，测试网已经运行到3代了</p>
<p>测试链的区别：</p>
<p><img src=/ethereum-tesnet.png alt></p>
<p>主链：</p>
<p><img src=/ethereum-mainnet.png alt></p>
<ol>
<li>应用场景</li>
</ol>
<ul>
<li>
<p>金融服务:主要是降低交易成本,减少跨组织交易风险等。该领域的区块链应用将最快
成熟起来,银行和金融交易机构将是主力推动者。</p>
</li>
<li>
<p>征信和权属管理:这是大型社交平台和保险公司都梦寐以求的,目前还缺乏足够的数据
来源、可靠的平台支持和有效的数据分析和管理。该领域创业的门槛极高,需要自上而
下的推动。</p>
</li>
<li>
<p>资源共享:airbnb 为代表的公司将欢迎这类应用,极大降低管理成本。这个领域创业门
槛低,主题集中,会受到投资热捧。</p>
</li>
<li>
<p>投资管理:无论公募还是私募基金,都可以应用区块链技术降低管理成本和管控风险。
虽然有 DAO 这样的试水,谨慎认为该领域的需求<a href=http://www.8btc.com/thedao-expolit-analysis>还未成熟</a>。</p>
</li>
<li>
<p>物联网与供应链:物联网是很适合的一个领域,短期内会有大量应用出现,特别是租
赁、物流等特定场景。但物联网自身的发展局限将导致短期内较难出现规模应用。</p>
</li>
</ul>
<ol start=3>
<li>趋势展望</li>
</ol>
<p><img src=/ethereum-future.png alt></p>
<p>一个是 技术领域也存在着周期律。这个周期目前看是7-8 年左右。或许正如人有“七年之
痒”,技术也存在着七年这道坎,到了这道坎,要么自身突破迈过去,要么往往就被新的技术
所取代。如果从比特币网络上线(2009 年1月)算起,到今年正是在坎上。因此,现在正是
相关技术进行突破的好时机。</p>
<p>为何恰好是7年? 7年按照产品周期来看基本是2-3个产品周期,所谓事不过三,经过2-3
个产品周期也差不多该有个结论了。</p>
<p>另外,最早出现的未必是先驱,也可能是先烈。创新固然很好,但过早播撒的种子,没有合
适的土壤,往往也难长大。技术创新与科研创新很不同的一点便是,技术创新必须立足于需
求,过早过晚都会错失良机。科研创新则要越早越好,最好像二十世纪那批物理巨匠们一
样,让后人吃了一百多年的老本。</p>
<p>最后,事物的发展往往是延续的、长期的。 新生事物大都不是凭空蹦出来的,往往是解决了
前辈未能解决的问题,或是出现了之前未曾出现过的场景。而且很多时候,新生事物会在历
史的舞台下面进行长期的演化,只要是往提高生产力的正确方向,迟早会出现在舞台上的一
天。</p>
<p><img src=/ethereum-giveup.png alt>
</br></br></br></br></br></br></br></br></br></br></br></br></br></p>
<h1 id=qa>QA ?</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3b56f6ee89ab0e0ddb4c851274991a28>2 - 搭建以太坊私链网络</h1>
<div class=lead>利用puppeth搭建POA共识的以太坊私链网络</div>
<p>大量过时文章充斥于网络，本文基于官方go-tehereum 1.6.7版本整理而出，在geth1.6之后引入了一个<strong>puppeth</strong>工具，它就是用来初始一个私链创世块配置的。</p>
<h3 id=准备工具环境>准备工具环境</h3>
<p>下载<code>go-ethereum代码</code>（go的开发环境准备，不在此文范围）</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 下载源码</span>
go get github.com/ethereum/go-ethereum
<span style=color:#a2f>cd</span> <span style=color:#b8860b>$GOPATH</span>/src/github.com/ethereum/go-ethereum

<span style=color:#080;font-style:italic># 编译1.6.7版本的代码</span>
git checkout -b v1.6.7 v1.6.7
make all

<span style=color:#080;font-style:italic># 安装</span>
sudo ln -s <span style=color:#b8860b>$PWD</span>/build/bin/* /usr/local/bin/

<span style=color:#080;font-style:italic># 检查是否安装OK</span>
geth version
    Geth
    Version: 1.6.7-stable
    Git Commit: ab5646c532292b51e319f290afccf6a44f874372
    Architecture: amd64
    Protocol Versions: <span style=color:#666>[</span><span style=color:#666>63</span> 62<span style=color:#666>]</span>
    Network Id: <span style=color:#666>1</span>
    Go Version: go1.8.3
    Operating System: linux
    <span style=color:#b8860b>GOPATH</span><span style=color:#666>=</span>/home/xxp/go
    <span style=color:#b8860b>GOROOT</span><span style=color:#666>=</span>/home/xxp/Software/go
</code></pre></div><h3 id=生成私链创世块的配置>生成私链创世块的配置</h3>
<ol>
<li>创建账户</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 创建testnet目录</span>
➜  mkdir testnet <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>cd</span> testnet

<span style=color:#080;font-style:italic># 创建3个普通账户，密码自定</span>
➜  geth --datadir node0 account new
<span style=color:#080;font-style:italic># 把密码记录到文件里，后面会频繁输入</span>
➜  <span style=color:#a2f>echo</span> node0 &gt; node0/password

➜  geth --datadir node1 account new
➜  <span style=color:#a2f>echo</span> node1 &gt; node1/password
➜  geth --datadir node2 account new
➜  <span style=color:#a2f>echo</span> node2 &gt; node2/password
</code></pre></div><p>如上打印的一串16进制的字符串就代表账户的userID（理解成网络中的IP地址），后面puppeth需要用到。</p>
<ol start=2>
<li>生成genesis文件</li>
</ol>
<p>genesis文件定义了私链的第一个块生成，直接看操作吧(省略了些输出)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  testnet puppeth

Please specify a network name to administer <span style=color:#666>(</span>no spaces, please<span style=color:#666>)</span>
&gt; testnet
Sweet, you can <span style=color:#a2f>set</span> this via --network<span style=color:#666>=</span>testnet next time!

INFO <span style=color:#666>[</span>08-21|23:04:14<span style=color:#666>]</span> Administering Ethereum network           <span style=color:#b8860b>name</span><span style=color:#666>=</span>testnet
WARN <span style=color:#666>[</span>08-21|23:04:14<span style=color:#666>]</span> No previous configurations found         <span style=color:#b8860b>path</span><span style=color:#666>=</span>/home/xxp/.puppeth/testnet

What would you like to <span style=color:#a2f;font-weight:700>do</span>? <span style=color:#666>(</span><span style=color:#b8860b>default</span> <span style=color:#666>=</span> stats<span style=color:#666>)</span>
 1. Show network stats
 2. Configure new genesis
 3. Track new remote server
 4. Deploy network components
&gt; <span style=color:#666>2</span>

Which consensus engine to use? <span style=color:#666>(</span><span style=color:#b8860b>default</span> <span style=color:#666>=</span> clique<span style=color:#666>)</span>
 1. Ethash - proof-of-work
 2. Clique - proof-of-authority
&gt; <span style=color:#666>2</span>
<span style=color:#080;font-style:italic># 设置5秒出一个块</span>
How many seconds should blocks take? <span style=color:#666>(</span><span style=color:#b8860b>default</span> <span style=color:#666>=</span> 15<span style=color:#666>)</span>
&gt; <span style=color:#666>5</span>
<span style=color:#080;font-style:italic># 输入有签名权限的账户</span>
Which accounts are allowed to seal? <span style=color:#666>(</span>mandatory at least one<span style=color:#666>)</span>
&gt; 0x799a8f7796d1d20b8198a587caaf545cdde5de13
&gt; 0x1458eac314d8fc922029095fae20483f55726017
&gt; 0x3ca60eb49314d867ab75a3c7b3a5aa61c3d6ef71
&gt; 0x
<span style=color:#080;font-style:italic># 输入有预留余额的账户</span>
Which accounts should be pre-funded? <span style=color:#666>(</span>advisable at least one<span style=color:#666>)</span>
&gt; 0x799a8f7796d1d20b8198a587caaf545cdde5de13
&gt; 0x1458eac314d8fc922029095fae20483f55726017
&gt; 0x3ca60eb49314d867ab75a3c7b3a5aa61c3d6ef71
&gt; 0x


Specify your chain/network ID <span style=color:#a2f;font-weight:700>if</span> you want an explicit one <span style=color:#666>(</span><span style=color:#b8860b>default</span> <span style=color:#666>=</span> random<span style=color:#666>)</span>
&gt; <span style=color:#666>378</span>                

Anything fun to embed into the genesis block? <span style=color:#666>(</span>max <span style=color:#666>32</span> bytes<span style=color:#666>)</span>
&gt; 

What would you like to <span style=color:#a2f;font-weight:700>do</span>? <span style=color:#666>(</span><span style=color:#b8860b>default</span> <span style=color:#666>=</span> stats<span style=color:#666>)</span>
 1. Show network stats
 2. Save existing genesis
 3. Track new remote server
 4. Deploy network components
&gt; <span style=color:#666>2</span>

Which file to save the genesis into? <span style=color:#666>(</span><span style=color:#b8860b>default</span> <span style=color:#666>=</span> testnet.json<span style=color:#666>)</span>
&gt; genesis.json
INFO <span style=color:#666>[</span>08-21|23:05:36<span style=color:#666>]</span> Exported existing genesis block 
</code></pre></div><p>最后会在当前目录生成genesis.json文件。</p>
<h3 id=启动私链网络>启动私链网络</h3>
<p>这里通过单机不同端口模拟多节点，</p>
<ul>
<li>默认geth一启动就会发出discovery，以发现其他节点，源码里内置了几个初始节点，可以通过--bootnode参数重置。如果真要不同节点互组网络的话，还需要主要时间同步，</li>
<li>还可以通过--nodiscover参数，停掉自动发现，并利用admin.addPeer()或者static-node功能组成网络。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 启动节点0, 关闭自动发现（防止不希望的节点进入）</span>
geth --datadir node0 init genesis.json
geth --datadir node0 --port <span style=color:#666>30000</span> --nodiscover --unlock <span style=color:#b44>&#39;0&#39;</span> --password ./node0/password console
<span style=color:#080;font-style:italic># 不加console的话，可以通过geth attach ipc:node0/geth.ipc来访问</span>

<span style=color:#080;font-style:italic># 启动节点1，另起一个终端，通过不同端口模拟</span>
geth --datadir node1 init genesis.json
geth --datadir node1 --port <span style=color:#666>30001</span> --nodiscover --unlock <span style=color:#b44>&#39;0&#39;</span> --password ./node1/password  console

<span style=color:#080;font-style:italic># 启动节点2，genesis.json里已经指定networkID,启动时无需指定了</span>
geth --datadir node2 init genesis.json
geth --datadir node2 --port <span style=color:#666>30002</span> --nodiscover --unlock <span style=color:#b44>&#39;0&#39;</span> --password ./node2/password  console
</code></pre></div><p>目前启动了三个节点，但都默认关闭了发现功能，需要手动添加peer节点。</p>
<p>在每个console输入<code>admin.nodeInfo.enode</code>， 把输出记录下来到<code>static-nodes.json</code>文件，我这里情况如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  testnet cat node0/static-nodes.json 
<span style=color:#666>[</span>
<span style=color:#b44>&#34;enode://2ffb53ede7de8dabf8f12343a7b2aba6b09263a53d8db5b4669309c5913f72969ce469cf09299f13e9d6cba8a98e18ad43811439326d7152f21d2e03ddc6be17@[::]:30000?discport=0&#34;</span>,
<span style=color:#b44>&#34;enode://910d1bfcd763bb5157bc62f8b121eb21fb305d17e4e4437c0b094d3d6f2d72f1964b80eb8fa2cf6cd7d4cc2d44cfc1ed9b74275ea7fd42ab89b4d089023fb7d5@[::]:30001?discport=0&#34;</span>,
<span style=color:#b44>&#34;enode://acab97a2a287b740b5efc3af465ba7330b3d4948b05e26818822d1aee659ec1b8f54ee9501576dc08ea4021d7ede01431691a27310a7dcbda2437bcd3b9c451d@[::]:30002?discport=0&#34;</span>
<span style=color:#666>]</span>

</code></pre></div><p>把static-nodes.json文件放入各自(node0/,node1/, node2/)的<code>admin.datadir</code>目录下，并<code>Ctrl+D</code>终止掉console，并重新执行<code>geth --datadir &lt;dir> --prot &lt;port> --nodiscover console</code>，如果觉得这样麻烦的话，或者以后动态添加节点时候，可考虑在每个节点的console里输入<code>admin.addPeer("nodeInfo_encode")</code>来完成。</p>
<p>然后在console中可以如下验证，是否互相发现组成以太坊私链网络了</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 这样可看到其他节点的明细</span>
&gt; admin.peers
<span style=color:#666>[{</span>
    caps: <span style=color:#666>[</span><span style=color:#b44>&#34;eth/63&#34;</span><span style=color:#666>]</span>,
    id: <span style=color:#b44>&#34;910d1bfcd763bb5157bc62f8b121eb21fb305d17e4e4437c0b094d3d6f2d72f1964b80eb8fa2cf6cd7d4cc2d44cfc1ed9b74275ea7fd42ab89b4d089023fb7d5&#34;</span>,
    name: <span style=color:#b44>&#34;Geth/v1.6.7-stable-ab5646c5/linux-amd64/go1.8.3&#34;</span>,
    network: <span style=color:#666>{</span>
      localAddress: <span style=color:#b44>&#34;[::1]:43928&#34;</span>,
      remoteAddress: <span style=color:#b44>&#34;[::1]:30001&#34;</span>
    <span style=color:#666>}</span>,
    protocols: <span style=color:#666>{</span>
      eth: <span style=color:#666>{</span>
        difficulty: 1,
        head: <span style=color:#b44>&#34;0xa43519868915a64d3798abf1867b7bc769d1239442c69ff1eca8e3dfcd13209b&#34;</span>,
        version: <span style=color:#666>63</span>
      <span style=color:#666>}</span>
    <span style=color:#666>}</span>
<span style=color:#666>}</span>, <span style=color:#666>{</span>
    caps: <span style=color:#666>[</span><span style=color:#b44>&#34;eth/63&#34;</span><span style=color:#666>]</span>,
    id: <span style=color:#b44>&#34;acab97a2a287b740b5efc3af465ba7330b3d4948b05e26818822d1aee659ec1b8f54ee9501576dc08ea4021d7ede01431691a27310a7dcbda2437bcd3b9c451d&#34;</span>,
    name: <span style=color:#b44>&#34;Geth/v1.6.7-stable-ab5646c5/linux-amd64/go1.8.3&#34;</span>,
    network: <span style=color:#666>{</span>
      localAddress: <span style=color:#b44>&#34;[::1]:60310&#34;</span>,
      remoteAddress: <span style=color:#b44>&#34;[::1]:30002&#34;</span>
    <span style=color:#666>}</span>,
    protocols: <span style=color:#666>{</span>
      eth: <span style=color:#666>{</span>
        difficulty: 1,
        head: <span style=color:#b44>&#34;0xa43519868915a64d3798abf1867b7bc769d1239442c69ff1eca8e3dfcd13209b&#34;</span>,
        version: <span style=color:#666>63</span>
      <span style=color:#666>}</span>
    <span style=color:#666>}</span>
<span style=color:#666>}]</span>
&gt; 
<span style=color:#080;font-style:italic># 可看到此节点发现了另外两个节点</span>
&gt; net.peerCount
<span style=color:#666>2</span>
&gt; 
</code></pre></div><p>目前整个testnet的目录结构如下</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  tree
.
├── genesis.json
├── node0
│   ├── geth
│   │   ├── chaindata
│   │   │   ├── 000002.ldb
|   |   |   ├── ...
│   │   ├── lightchaindata
│   │   │   ├── 000001.log
│   │   │   ├── ...
│   │   ├── LOCK
│   │   └── nodekey
│   ├── geth.ipc
│   ├── <span style=color:#a2f>history</span>
│   ├── keystore
│   │   └── UTC--2017-08-21T15-03-25.499242705Z--799a8f7796d1d20b8198a587caaf545cdde5de13
│   └── static-nodes.json
├── node1
│   ├── geth
│   │   ├── chaindata
│   │   │   ├── 000002.ldb
│   │   │   ├── ...
│   │   │   └── MANIFEST-000007
│   │   ├── lightchaindata
│   │   │   ├── ...
│   │   │   └── MANIFEST-000000
│   │   ├── LOCK
│   │   └── nodekey
│   ├── geth.ipc
│   ├── <span style=color:#a2f>history</span>
│   ├── keystore
│   │   └── UTC--2017-08-21T15-03-35.020270645Z--1458eac314d8fc922029095fae20483f55726017
│   └── static-nodes.json
└── node2
    ├── geth
    │   ├── chaindata
    │   │   ├── 000002.ldb
    │   │   ├── ...
    │   │   └── MANIFEST-000007
    │   ├── lightchaindata
    │   │   ├── ...
    │   │   └── MANIFEST-000000
    │   ├── LOCK
    │   └── nodekey
    ├── geth.ipc
    ├── <span style=color:#a2f>history</span>
    ├── keystore
    │   └── UTC--2017-08-21T15-03-46.899273318Z--3ca60eb49314d867ab75a3c7b3a5aa61c3d6ef71
    └── static-nodes.json

<span style=color:#666>15</span> directories, <span style=color:#666>56</span> files

</code></pre></div><h3 id=开始挖矿>开始挖矿</h3>
<p>在每个节点的console输入如下，启动挖矿（共识记账）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 这一步可以不需要，因为我们geth启动的时候，已经传入unlock参数了，因为console里执行unlock是有过期时间机制的，私网直接来。。。。</span>
&gt; personal.unlockAccount<span style=color:#666>(</span>eth.coinbase<span style=color:#666>)</span>
Unlock account 0x799a8f7796d1d20b8198a587caaf545cdde5de13
Passphrase: 
<span style=color:#a2f>true</span>
&gt; 
<span style=color:#080;font-style:italic># 这一个很重要，为后面的eth设置了默认账户</span>
&gt; eth.defaultAccount <span style=color:#666>=</span> eth.coinbase
<span style=color:#b44>&#34;0x799a8f7796d1d20b8198a587caaf545cdde5de13&#34;</span>
&gt; 
&gt; miner.start<span style=color:#666>()</span>
</code></pre></div><h3 id=通过钱包交易>通过钱包交易</h3>
<p>通过<a href=https://github.com/ethereum/mist/releases>mist</a>钱包界面，来查看基本信息和进行交易，不过之前需要在console开启RPC，　node0的console里如下</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&gt; admin.startRPC<span style=color:#666>(</span><span style=color:#b44>&#34;127.0.0.1&#34;</span>, 8545, <span style=color:#b44>&#34;*&#34;</span>, <span style=color:#b44>&#34;eth,net,web3,admin,personal&#34;</span><span style=color:#666>)</span>
</code></pre></div><p>启动的mist钱包</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mist --node geth --node-datadir ./node0 --rpc http://localhost:8545
<span style=color:#080;font-style:italic># 不启动rpc的话，也可以如下直接通过ipc通信</span>
<span style=color:#080;font-style:italic># mist  --rpc ./node0/geth.ipc  --node-networkid 378 --node-datadir ./node0</span>
</code></pre></div><p><img src=/ethereum-mist.png alt=mist界面></p>
<p>需要去node1上通过<code>eth.accounts[0]</code>拿到账号信息,填入红框，点击发送交易，输入密码即可</p>
<p><img src=/ethereum-transcation.png alt></p>
<p>另外也可以通过console命令行来完成上面操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>&gt; 
&gt; var <span style=color:#b8860b>sender</span> <span style=color:#666>=</span> eth.accounts<span style=color:#666>[</span>0<span style=color:#666>]</span>
undefined
&gt; var <span style=color:#b8860b>receiver</span> <span style=color:#666>=</span> <span style=color:#b44>&#34;0x1458eac314d8fc922029095fae20483f55726017&#34;</span>
undefined
&gt; var <span style=color:#b8860b>amount</span> <span style=color:#666>=</span> web3.toWei<span style=color:#666>(</span>10, <span style=color:#b44>&#34;ether&#34;</span><span style=color:#666>)</span>
undefined
&gt; personal.unlockAccount<span style=color:#666>(</span>eth.accounts<span style=color:#666>[</span>0<span style=color:#666>])</span>
Unlock account 0x799a8f7796d1d20b8198a587caaf545cdde5de13
Passphrase: 
<span style=color:#a2f>true</span>
&gt; eth.sendTransaction<span style=color:#666>({</span>from:sender, to:receiver, value: amount<span style=color:#666>})</span>
<span style=color:#b44>&#34;0x97ca1f5fa27df083e14b2ffb82c2a60744aeae0f1a7b5e735ca4d0c05c16f7b6&#34;</span>
&gt; 
</code></pre></div><h3 id=写个合约>写个合约</h3>
<p>通过mist界面点击的“开发”->"Open Remix IDE", 会自动打开IDE工具，并且默认集成了一个投票的合约，合约内容不表</p>
<p>“create”按钮后面输入 <code>10</code> -> 点击, 这时候需要输入密码解锁，因为需要支付一定的gas费用。</p>
<p><img src=/ethereum-contract-ballot.png alt></p>
<ul>
<li>这个合约就是个投票程序</li>
<li>第一个部署的默认是主席身份，拥有指定别人投票的权利，因为我这里的mist是连接的node0，所以</li>
<li>合约初始化（也就是界面点击“create”时），需要输入"投案"个数</li>
</ul>
<p>在每个节点的的console里，通过<code>eth.contract(ABI).at(Address);</code>拿到合约对象，</p>
<ul>
<li>其中node0的节点需要用<code>giveRightToVote</code>给其他账户授权投票权限</li>
<li>ABI的信息，就是remix里Interface框对应的信息</li>
<li>合约地址通过<code>Copy address</code>得到</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
&gt; var <span style=color:#b8860b>b</span> <span style=color:#666>=</span> eth.contract<span style=color:#666>([{</span><span style=color:#b44>&#34;constant&#34;</span>:false,<span style=color:#b44>&#34;inputs&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;to&#34;</span>,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;address&#34;</span><span style=color:#666>}]</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;delegate&#34;</span>,<span style=color:#b44>&#34;outputs&#34;</span>:<span style=color:#666>[]</span>,<span style=color:#b44>&#34;payable&#34;</span>:false,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;function&#34;</span><span style=color:#666>}</span>,<span style=color:#666>{</span><span style=color:#b44>&#34;constant&#34;</span>:true,<span style=color:#b44>&#34;inputs&#34;</span>:<span style=color:#666>[]</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;winningProposal&#34;</span>,<span style=color:#b44>&#34;outputs&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;_winningProposal&#34;</span>,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;uint8&#34;</span><span style=color:#666>}]</span>,<span style=color:#b44>&#34;payable&#34;</span>:false,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;function&#34;</span><span style=color:#666>}</span>,<span style=color:#666>{</span><span style=color:#b44>&#34;constant&#34;</span>:false,<span style=color:#b44>&#34;inputs&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;voter&#34;</span>,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;address&#34;</span><span style=color:#666>}]</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;giveRightToVote&#34;</span>,<span style=color:#b44>&#34;outputs&#34;</span>:<span style=color:#666>[]</span>,<span style=color:#b44>&#34;payable&#34;</span>:false,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;function&#34;</span><span style=color:#666>}</span>,<span style=color:#666>{</span><span style=color:#b44>&#34;constant&#34;</span>:false,<span style=color:#b44>&#34;inputs&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;proposal&#34;</span>,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;uint8&#34;</span><span style=color:#666>}]</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;vote&#34;</span>,<span style=color:#b44>&#34;outputs&#34;</span>:<span style=color:#666>[]</span>,<span style=color:#b44>&#34;payable&#34;</span>:false,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;function&#34;</span><span style=color:#666>}</span>,<span style=color:#666>{</span><span style=color:#b44>&#34;inputs&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;_numProposals&#34;</span>,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;uint8&#34;</span><span style=color:#666>}]</span>,<span style=color:#b44>&#34;payable&#34;</span>:false,<span style=color:#b44>&#34;type&#34;</span>:<span style=color:#b44>&#34;constructor&#34;</span><span style=color:#666>}])</span>.at<span style=color:#666>(</span><span style=color:#b44>&#39;0xc825238a3348f0a679924796fcf1b1b64a8c1706&#39;</span><span style=color:#666>)</span>
undefined

&gt; b.vote<span style=color:#666>(</span>9<span style=color:#666>)</span>
<span style=color:#b44>&#34;0x1646e6547606a8ad0e183f1c9145eff08bbdfd860961d6c7d7367f5b70779cbd&#34;</span>
&gt; 
&gt; b.giveRightToVote<span style=color:#666>(</span><span style=color:#b44>&#39;0x1458eac314d8fc922029095fae20483f55726017&#39;</span><span style=color:#666>)</span>
<span style=color:#b44>&#34;0x2759928ad03a2ed5bc4b9c54531eb83e25c4a468e71682f67b160ad3328c8173&#34;</span>
&gt; 
&gt; b.giveRightToVote<span style=color:#666>(</span><span style=color:#b44>&#39;0x3ca60eb49314d867ab75a3c7b3a5aa61c3d6ef71&#39;</span><span style=color:#666>)</span>
<span style=color:#b44>&#34;0x46f756e613499f836e392011c8f6d7c23d378fd5a656bae775ecda8bf286c5b6&#34;</span>
&gt; b.winningProposal<span style=color:#666>()</span>
<span style=color:#666>9</span>
</code></pre></div><p>其中值得注意的是b.vote(<number>) 其中的number不能超过create后传入初始参数10， 其实通过<code>Web3 deploy</code>框的信息也可以直接部署合约。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bc311f0f5a9779af3ad781d3d3573055>3 - 以太坊的truffle box开发实战</h1>
<div class=lead>介绍以太坊私合约开发</div>
<p>整个过程主要演示chrome扩展 METAMASK， OpenZepplin库和truffle框架的使用。</p>
<h3 id=搭建私连网络>搭建私连网络</h3>
<p>主要参考之前的<a href=../%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5>以太坊-私有链搭建初步实践</a>， 这里只用单节点的网络。</p>
<p>还是先准备账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir node0
<span style=color:#080;font-style:italic># 会在node0/keystore目录里生成一个keyfile json文件</span>
geth --datadir node0 account new

<span style=color:#080;font-style:italic>#利用puppeth生成genesis.json的过程不表，参考上边的链接</span>
geth --datadir node0 init genesis.json

<span style=color:#080;font-style:italic># 把刚才的账号的密码写入node0/password文件</span>
<span style=color:#080;font-style:italic># 启动私链，顺便开启console</span>
<span style=color:#a2f>echo</span> node0 &gt; node0/password
geth --datadir node0 --port <span style=color:#666>30000</span> --nodiscover --unlock <span style=color:#b44>&#39;0&#39;</span> --password ./node0/password --mine --rpc --rpccorsdomain <span style=color:#b44>&#34;*&#34;</span> --rpcapi <span style=color:#b44>&#34;eth,net,web3,admin,personal&#34;</span> console
</code></pre></div><p>我们把这个账号的json文件导入到chorme插件metamask里，便于后面调试和演示</p>
<p><img src=/ethereum-new-account.png alt></p>
<p>ubuntu系统上的chrome插件会有窗口消失的bug，在URL栏里打开<code>chrome-extension://nkbihfbeogaeaoehlefnkodbefgpgknn/popup.html</code></p>
<h3 id=truflle初始化项目>truflle初始化项目</h3>
<p>需要下载truffle命令号</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>npm install -g truffle

mkdir token <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>cd</span> token

<span style=color:#080;font-style:italic># 利用trulle下载token代笔示例</span>
truffle unbox tutorialtoken

npm intall zeppelin-solidity
</code></pre></div><p>如上必要的依赖框架和库已经下载到了本地， 接下来就创建自己的代币合约</p>
<p>在contract目录创建TutorialToken.sol文件，内容如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>pragma solidity <span style=color:#666>^</span><span style=color:#666>0.4</span>.<span style=color:#666>11</span>;


<span style=color:#a2f;font-weight:700>import</span> <span style=color:#b44>&#39;zeppelin-solidity/contracts/token/StandardToken.sol&#39;</span>;


<span style=color:#080;font-style:italic>/**
</span><span style=color:#080;font-style:italic> * @title SimpleToken
</span><span style=color:#080;font-style:italic> * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. 
</span><span style=color:#080;font-style:italic> * Note they can later distribute these tokens as they wish using `transfer` and other
</span><span style=color:#080;font-style:italic> * `StandardToken` functions.
</span><span style=color:#080;font-style:italic> */</span>
contract TutorialToken is StandardToken {

  string <span style=color:#a2f;font-weight:700>public</span> name <span style=color:#666>=</span> <span style=color:#b44>&#34;TutorialToken&#34;</span>;
  string <span style=color:#a2f;font-weight:700>public</span> symbol <span style=color:#666>=</span> <span style=color:#b44>&#34;SIM&#34;</span>;
  uint256 <span style=color:#a2f;font-weight:700>public</span> decimals <span style=color:#666>=</span> <span style=color:#666>18</span>;
  uint256 <span style=color:#a2f;font-weight:700>public</span> INITIAL_SUPPLY <span style=color:#666>=</span> <span style=color:#666>10000</span>;

  <span style=color:#080;font-style:italic>/**
</span><span style=color:#080;font-style:italic>   * @dev Contructor that gives msg.sender all of existing tokens. 
</span><span style=color:#080;font-style:italic>   */</span>
  <span style=color:#a2f;font-weight:700>function</span> TutorialToken() {
    totalSupply <span style=color:#666>=</span> INITIAL_SUPPLY;
    balances[msg.sender] <span style=color:#666>=</span> INITIAL_SUPPLY;
  }

}
</code></pre></div><p>在以太坊里几乎所有操作都是当做交易来看的，部署合约就是一种交易，交易就要花钱(gas消耗)，所以truffle做的是增量部署（少消耗gas），现在在<code>migrations</code>目录添加新的部署文件<code>2_deploy_contracts.js</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a2f;font-weight:700>var</span> TutorialToken <span style=color:#666>=</span> artifacts.require(<span style=color:#b44>&#34;./TutorialToken.sol&#34;</span>);

module.exports <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>function</span>(deployer) {
  deployer.deploy(TutorialToken);
};
</code></pre></div><p>一切准备就绪，编译，部署开始：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 编译</span>
➜  truffle compile
Compiling ./contracts/Migrations.sol...
Compiling ./contracts/TutorialToken.sol...
Compiling zeppelin-solidity/contracts/math/SafeMath.sol...
Compiling zeppelin-solidity/contracts/token/BasicToken.sol...
Compiling zeppelin-solidity/contracts/token/ERC20.sol...
Compiling zeppelin-solidity/contracts/token/ERC20Basic.sol...
Compiling zeppelin-solidity/contracts/token/StandardToken.sol...
Writing artifacts to ./build/contracts
<span style=color:#080;font-style:italic># 根据truffle.js的配置进行部署</span>
➜  truffle migrate
Using network <span style=color:#b44>&#39;development&#39;</span>.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x65ccd2d6a4f4248466dd7887da7a2ac35d18c7ab0ec826cb25580bc785a2c3b8
  Migrations: 0xc64569558f90302f4b3884929ac5540c645674dc
Saving successful migration to network...
  ... 0xf9043ca886d352f05a05642047f63eed11d9b328fb815becc68baffc4d953d60
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying TutorialToken...
  ... 0x19350625474c36316046b103e671eaad45834a60c17a5b9c64cf96316754560f
  TutorialToken: 0x7f469dc1ec17c3b7c52a3ad74611cb4b7e6807e1
Saving successful migration to network...
  ... 0xe57ba56dd5f1b18d410577def8bc7089f7de56e8d8718c3098430995d4b81353
Saving artifacts...

</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cff6c067f38087f593256a9b98010b27>4 - fomo3d-上线部署要点</h1>
<div class=lead>介绍以太坊私合约fomo3d本地调试要点</div>
<p>fomo3d游戏一出，国内疯狂clone上线，这里谈下我上线的思路和部署方法（纯手动的^_^，落伍了）</p>
<p>通过<a href=https://etherscan.io/address/0xa62142888aba8370742be823c1782d17a0389da1#code>原版合约地址</a>，可以一层一层的拔下所有涉及到的合约代码。</p>
<p>目前据我统计共有8个合约，其中有两个闭源合约：</p>
<ul>
<li>F3DexternalSettingsInterface</li>
<li>JIincInterfaceForForwarder</li>
</ul>
<p>闭源合约不可怕，看明白什么功能，自己hack掉是不影响游戏本身的。</p>
<pre><code>提前预警，合约的内容细节还是要自己研究的，没时间写太细，
</code></pre>
<p>其实这个游戏本身只需要2个合约就可以跑起来，且没实质影响，只是单纯改变了部分利益分配方式。</p>
<p>下面说明，我尽可能少改动原版的情况下，部署上线合约，移除p3d修改后的原版合约代码<a href=https://github.com/ChungkueiBlock/fomo3d/tree/master/sols>在这里</a></p>
<h2 id=部署前的准备>部署前的准备</h2>
<p>我一般使用<a href="https://remix.ethereum.org/#optimize=true&version=soljson-v0.4.24">在线remix</a>工具部署合约在自己的私链上调试，私链建议如下启动（一键解万忧的方式，推荐创世块采用<a href=https://github.com/ChungkueiBlock/tools/tree/master/privateEth>POA共识</a>-不消耗CPU），这样可以使用remix的debug功能</p>
<pre tabindex=0><code>geth  \
    --datadir ./node0\
    --ws\
    --wsaddr 0.0.0.0\
    --wsapi &quot;eth,net,web3,admin,personal,txpool,miner,clique,debug&quot;\
    --wsport 8546\
    --wsorigins &quot;*&quot;\
    --rpc\
    --rpcapi &quot;eth,net,web3,admin,personal,txpool,miner,clique,debug&quot;\
    --rpccorsdomain &quot;*&quot;\
    --rpcaddr 0.0.0.0\
    --rpcport 8545\
    --rpcvhosts &quot;*&quot;\
    --mine\
    --etherbase 0xdbeb69c655b666b3e17b8061df7ea4cc2399df11\
    --unlock 0xdbeb69c655b666b3e17b8061df7ea4cc2399df11\
    --password ./password\
    --nodiscover\
    --maxpeers '50'\
    --networkid 378\
    --targetgaslimit 471238800\
    &amp;
</code></pre><h2 id=部署合约>部署合约</h2>
<p>按先后顺序如下部署</p>
<ol>
<li><a href=https://github.com/ChungkueiBlock/sols/blob/master/fomo3d/Hourglass.sol>p3d合约</a></li>
</ol>
<p>真心不推荐部署带有p3d合约的游戏，这样项目方就可以吃掉本来要流到这里25%左右的流水资金了</p>
<p>我对p3d的合约内容还没有很深的研究，只知道它</p>
<ul>
<li>是一个自带“交易所”、发行总量为0的Token，</li>
<li>通过Eth买入会自动增发，卖出会销毁</li>
<li>买入和卖出都会扣掉10%的费用给仍持有Token的人</li>
<li>每买一次都会使Token升值</li>
<li>每卖一次会使Token降价</li>
</ul>
<p>这个合约不需要改动，贴源码，编译后部署截图如下，点击红色记录下来部署后的合约地址</p>
<p><img src=/p3d%E9%83%A8%E7%BD%B2.jpg alt=p3d></p>
<ol>
<li>部署divies合约</li>
</ol>
<p>这个合约专门往p3d持有者发分红的。</p>
<p>把刚才记录的p3d合约地址，替换到<code>HourglassInterface</code>后面的地址。如上贴源码，编译后部署<code>Divies</code>合约，</p>
<p>记录下divies的地址，并替换fomo3dlong.sol里的<code>DiviesInterface</code>地址</p>
<ol start=3>
<li><del>部署JIincForwarder合约</del></li>
</ol>
<p>这个合约是管理流向社区2%的资金的，被fomo3dlong里调用，
这里需要hack，因为其中涉及到一个闭源的合约，既然知道它是管理2%资金流向的，那直接在fomo3dLong的合约如下hack</p>
<ul>
<li>把定义<code>Jekyll_Island_Inc</code>的地方，直接定义成一个普通地址 <code>address reward = 0xxxxxxx;</code></li>
<li>把调用Jekyll_Island_Inc的地方， 写成<code>reward.transfer(_com);</code>， 注意有两个地方调用（都要换），一个是游戏进行时调用，一个是本轮结束后调用</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>        <span style=color:#080;font-style:italic>// // community rewards
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>// if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(&#34;deposit()&#34;))))
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>// {
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>//     // This ensures Team Just cannot influence the outcome of FoMo3D with
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>//     // bank migrations by breaking outgoing transactions.
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>//     // Something we would never do. But that&#39;s not the point.
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>//     // We spent 2000$ in eth re-deploying just to patch this, we hold the 
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>//     // highest belief that everything we create should be trustless.
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>//     // Team JUST, The name you shouldn&#39;t have to trust.
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>//     _p3d = _p3d.add(_com);
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>//     _com = 0;
</span><span style=color:#080;font-style:italic></span>        <span style=color:#080;font-style:italic>// }
</span><span style=color:#080;font-style:italic></span>
        reward.transfer(_com);
</code></pre></div><p>所以不需要部署这个合约，你只要想办法把流到这里的ETH，流到平台方就可以了。（流到开发者，我觉得也是可以的，哈哈～）</p>
<ol start=4>
<li>部署Team合约</li>
</ol>
<p>这个合约利用多签技术限制了影响团队的操作，需要改的地方就是把这些地址全部换成自己的，</p>
<p>把下面这些地址，改成你自己的地址，最好把<code>deployer</code>地址写成你用来部署合约的那个地址，后面调用playbook合约的<code>addGame</code>需要这里的权限</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>address inventor <span style=color:#666>=</span> <span style=color:#666>0x18E90Fc6F70344f53EBd4f6070bf6Aa23e2D748C</span>;
address mantso   <span style=color:#666>=</span> <span style=color:#666>0x8b4DA1827932D71759687f925D17F81Fc94e3A9D</span>;
address justo    <span style=color:#666>=</span> <span style=color:#666>0x8e0d985f3Ec1857BEc39B76aAabDEa6B31B67d53</span>;
address sumpunk  <span style=color:#666>=</span> <span style=color:#666>0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C</span>;
address deployer <span style=color:#666>=</span> <span style=color:#666>0xF39e044e1AB204460e06E87c6dca2c6319fC69E3</span>;

admins_[inventor] <span style=color:#666>=</span> Admin(<span style=color:#a2f;font-weight:700>true</span>, <span style=color:#a2f;font-weight:700>true</span>, <span style=color:#b44>&#34;inventor&#34;</span>);
admins_[mantso]   <span style=color:#666>=</span> Admin(<span style=color:#a2f;font-weight:700>true</span>, <span style=color:#a2f;font-weight:700>true</span>, <span style=color:#b44>&#34;mantso&#34;</span>);
admins_[justo]    <span style=color:#666>=</span> Admin(<span style=color:#a2f;font-weight:700>true</span>, <span style=color:#a2f;font-weight:700>true</span>, <span style=color:#b44>&#34;justo&#34;</span>);
admins_[sumpunk]  <span style=color:#666>=</span> Admin(<span style=color:#a2f;font-weight:700>true</span>, <span style=color:#a2f;font-weight:700>true</span>, <span style=color:#b44>&#34;sumpunk&#34;</span>);
admins_[deployer] <span style=color:#666>=</span> Admin(<span style=color:#a2f;font-weight:700>true</span>, <span style=color:#a2f;font-weight:700>true</span>, <span style=color:#b44>&#34;deployer&#34;</span>);
</code></pre></div><p>改完后，如上贴源码，编译后部署<code>TeamJust</code>合约，记录地址，替换playbook合约的<code>TeamJustInterface</code>地址</p>
<ol start=5>
<li>部署playerBook合约</li>
</ol>
<p>很有意思的合约，这里就是上面说的整个游戏其实只需要两个合约中的一个。
不解读细节了，直接改吧</p>
<p>你会发现这里怎么还有个<code>JIincForwarderInterface</code>地址，第三步不是说不部署这个了么 ？</p>
<p>这里的主要是收取别人注册名字开启邀请返佣机制时需要支付的那0.01ETH的</p>
<p>知道了这个，就跟第3步一样加个reward收款地址吧，细节不标</p>
<p>如上贴源码，编译后部署<code>PlayBook</code>合约，记录下地址， 替换fomo3d合约里的<code>PlayerBookInterface</code>地址。</p>
<ol start=6>
<li>部署fomo3dLong合约</li>
</ol>
<p>这个是另一个核心合约之一，这里也有个闭源合约，用来初始化控制时间的参数</p>
<p>直接注释掉，然后如下改动</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>uint256 <span style=color:#a2f;font-weight:700>private</span> rndExtra_ <span style=color:#666>=</span> <span style=color:#666>30</span>;     <span style=color:#080;font-style:italic>// 和rndInit一起控制第一轮游戏开始的初始时间的，单位是秒
</span><span style=color:#080;font-style:italic></span>uint256 <span style=color:#a2f;font-weight:700>private</span> rndGap_ <span style=color:#666>=</span> <span style=color:#666>30</span>;         <span style=color:#080;font-style:italic>// 和rndInit一起控制下轮游戏开始的初始时间的，单位是秒
</span></code></pre></div><p>还有两个改动点就是<code>activate</code>和<code>setOtherFomo</code>里加上自己的deployer地址，</p>
<p>额外把setOtherFomo里的往另一个游戏池子里输血的功能改到，因为我们没有其他的游戏，如第三步一样，换个收款码吧</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>otherF3D_.transfer(_long);
</code></pre></div><p>部署吧！！！</p>
<p>最后部署这一步，很有可能遇到<code>errored: oversized data</code>的错误，刷新remix页面即可。</p>
<h2 id=合约设置>合约设置</h2>
<p>先setOtherFomo,然后再设置playbook里的addgame，最后activate即可。</p>
<h2 id=页面>页面</h2>
<p>页面直接Ctrl+s下载原版界面，把最后的fomo3dLong的合约地址替换下，另外那个后台API，其实没什么，自己试下就知道了，然后就可以上线了。。。</p>
<p><img src=/fomo3d%E4%B8%8A%E7%BA%BF.png alt=fomo3d上线></p>
<h1 id=感受>感受</h1>
<ul>
<li>合约debug难如上青天</li>
<li>要替换一大堆合约里的地址，除了Interface类的要替成依赖的合约地址，其他的全可以写成你自己地址（即使都一样的也OK）就可以。</li>
</ul>
<p>目前我们搞出来的定制版有：</p>
<ul>
<li>多级返佣模式， 可自定义级数</li>
<li>空投fix版</li>
<li>去除战队版</li>
<li>移除p3d版本</li>
<li>原版</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b343ce2ae51ef80e6d4361ca04ac169e>5 - fomo3d-钱都去哪儿了</h1>
<div class=lead>分析太坊私合约fomo3d的数据流向</div>
<p>fomo3d里有战队系统、邀请分佣机制、持key分红、空投系统、持p3d分红等玩法, 相信通过之前各类媒体的解读都有所了解。</p>
<p>下面通过分析合约代码，以讲解ETH数据流向的方式串下所有流程，让大家明明白白的知道自己的ETH都去了哪里。</p>
<p>以10ETH充币到fomod3d合约举例，分三种情况</p>
<ul>
<li>早期用户（游戏刚启动时的激进者）</li>
<li>中期用户（为了赚分红、返佣的用户）</li>
<li>晚期用户（为了赢48%大奖的人）</li>
</ul>
<h2 id=早期>早期</h2>
<p>当合约被激活后，开发者做了一个很“仇富”的举动，每个地址在合约收到100ETH之前，只能购买1ETH的keys，防止被资本大鳄收割本轮后面入场的玩家。这里有个小hack的点，就是提前多准备些小号，多个地址去投，也可以做到比别人便宜多的价格买到keys。</p>
<p>这个阶段以买入10ETH举例，你只会买到等同于1ETH价值的keys，其余9个ETH会直接进入你的收益里，
演示如下：</p>
<p><img src=/ethLimiter2.png alt=ethLimiter2></p>
<p>下面是实现此功能的代码</p>
<p><img src=/ethLimiter.png alt=ethLimiter></p>
<p>代码里的规则(不限阶段)梳理：</p>
<ul>
<li>提款功能可以无限次提，不影响本轮接下来的分红收益，你的收益来自于你持有keys的分红。</li>
<li>最低可以支付1e-09个Ether，当购买的Key数量大于或者等于1个时，倒计时会加30秒。</li>
<li>当支付的eth不小于0.1时，会送一次“彩票”，买key支付的金额越大，中奖的奖金也越大，最大可中“彩票池”里额度的75%，直译过来这个功能叫空投。</li>
</ul>
<h2 id=中期>中期</h2>
<p>所有阶段的用户如果是直接打开的官网，充币买keys时会触发合约的这个接口，</p>
<p><img src=/buyXaddr.png alt=buyXaddr></p>
<p>其中_affcode是值邀请人的地址，_team是指用户所有购买key所选的战队，默认的2是指蛇队。</p>
<p>如果是从别人的邀请进入的官网，要看邀请人给你发的是哪个链接，有三种形式的链接：</p>
<p><img src=/affiliate.png alt=affiliate>,</p>
<p>从上到下，分别会走<code>buyXaddr</code>、<code>buyXid</code>、<code>buyXname</code>的接口，比如我给人发了<a href=http://exitscam.me/xxp>exitscam.me/xxp</a>的邀请链接，被邀的人买keys时会触发如下接口：</p>
<p><img src=/affiliate2.png alt=affiliate2></p>
<p>这其中我个人会收到他买key总额度的10%佣金，这里还有个隐藏的点：</p>
<pre><code>如果用户是直接从官网进入买key的，那同样会有10%佣金的产生，只不过是流向p3d的持有者。
</code></pre>
<h2 id=晚期>晚期</h2>
<p>当有人买key时，都会选择一个战队，默认会被勾选蛇队的，当买到keys数量不小于1个时，会使所选战队成为本轮的潜在获胜队。</p>
<p>说了这么多废话，回归正体，你的10ETH到底去了哪里？？？</p>
<p>如果支付10ETH时，选的是蛇队，你10个ETH里的5.6个会被持keys的人均分，1个看情况是给p3d的人还是给邀请你的人，还有1个必定会分给持有p3d的人，另外2个会进入大池子，其中0.2个会分给社区贡献人，0.1个会给TeamJust的另一个游戏合约，还有0.1个会流到“彩票池”里。</p>
<p>这里面根据你选的战队不通，分配比例不一样，具体看下的代码，执行这些ETH分配的是走<code>distributeExternal</code>，<code>distributeInternal</code> 出去的。</p>
<p>后面的PotSpit是本轮游戏结束后，如何分配大池子里的金额。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#080;font-style:italic>// Team allocation structures
</span><span style=color:#080;font-style:italic>// 0 = whales
</span><span style=color:#080;font-style:italic>// 1 = bears
</span><span style=color:#080;font-style:italic>// 2 = sneks
</span><span style=color:#080;font-style:italic>// 3 = bulls
</span><span style=color:#080;font-style:italic></span>
<span style=color:#080;font-style:italic>// Team allocation percentages
</span><span style=color:#080;font-style:italic>// (F3D, P3D) + (Pot , Referrals, Community)
</span><span style=color:#080;font-style:italic>// Referrals / Community rewards are mathematically designed to come from the winner&#39;s share of the pot.
</span><span style=color:#080;font-style:italic></span>fees_[<span style=color:#666>0</span>] <span style=color:#666>=</span> F3Ddatasets.TeamFee(<span style=color:#666>30</span>,<span style=color:#666>6</span>);   <span style=color:#080;font-style:italic>//50% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
</span><span style=color:#080;font-style:italic></span>fees_[<span style=color:#666>1</span>] <span style=color:#666>=</span> F3Ddatasets.TeamFee(<span style=color:#666>43</span>,<span style=color:#666>0</span>);   <span style=color:#080;font-style:italic>//43% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
</span><span style=color:#080;font-style:italic></span>fees_[<span style=color:#666>2</span>] <span style=color:#666>=</span> F3Ddatasets.TeamFee(<span style=color:#666>56</span>,<span style=color:#666>10</span>);  <span style=color:#080;font-style:italic>//20% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
</span><span style=color:#080;font-style:italic></span>fees_[<span style=color:#666>3</span>] <span style=color:#666>=</span> F3Ddatasets.TeamFee(<span style=color:#666>43</span>,<span style=color:#666>8</span>);   <span style=color:#080;font-style:italic>//35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
</span><span style=color:#080;font-style:italic></span>
<span style=color:#080;font-style:italic>// how to split up the final pot based on which team was picked
</span><span style=color:#080;font-style:italic>// (F3D, P3D)
</span><span style=color:#080;font-style:italic></span>potSplit_[<span style=color:#666>0</span>] <span style=color:#666>=</span> F3Ddatasets.PotSplit(<span style=color:#666>15</span>,<span style=color:#666>10</span>);  <span style=color:#080;font-style:italic>//48% to winner, 25% to next round, 2% to com
</span><span style=color:#080;font-style:italic></span>potSplit_[<span style=color:#666>1</span>] <span style=color:#666>=</span> F3Ddatasets.PotSplit(<span style=color:#666>25</span>,<span style=color:#666>0</span>);   <span style=color:#080;font-style:italic>//48% to winner, 25% to next round, 2% to com
</span><span style=color:#080;font-style:italic></span>potSplit_[<span style=color:#666>2</span>] <span style=color:#666>=</span> F3Ddatasets.PotSplit(<span style=color:#666>20</span>,<span style=color:#666>20</span>);  <span style=color:#080;font-style:italic>//48% to winner, 10% to next round, 2% to com
</span><span style=color:#080;font-style:italic></span>potSplit_[<span style=color:#666>3</span>] <span style=color:#666>=</span> F3Ddatasets.PotSplit(<span style=color:#666>30</span>,<span style=color:#666>10</span>);  <span style=color:#080;font-style:italic>//48% to winner, 10% to next round, 2% to com
</span></code></pre></div><p>还有很多细节要分享，碍于时间有限，不过我会持续更新这里的</p>
<h2 id=感想>感想</h2>
<ul>
<li>持有p3d的人和早期进入的才是最大的受益者</li>
<li>后期进入的人只有通过拉人赚佣金的方式回本了</li>
<li>这轮游戏应该是结束不了的： 总有人赔了，要拉人进来捞本，被拉的人周而复始。。。</li>
<li>结束只有两个可能： 1. 合约有重大漏洞，资金被盗 2. 当大池子里48%的收益足以对整个以太网络发动51%攻击。。。</li>
<li>矿工在背后偷着乐</li>
<li>你们谁知道TeamJust的下个游戏的合约地址么？ 我知道！！！</li>
</ul>
<p>如果你也找到了，可以加我微信<code>yiyemeishui</code>， 加好友时请输入TeamJust的下个游戏合约地址，我们一起来票大的。。。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0bd51907ec255a7703ff0301867ca861>6 - 解读cosmos-sdk系列(1)</h1>
<div class=lead>分析解读cosmos跨链方案</div>
<p>通过本系列，可以了解tendermint共识和cosmos-sdk架构的设计思想，并学习到如何通过Cosmos-SDK来快速开发自己的区块链应用。</p>
<p>cosmos团队把区块链分成了三层</p>
<ul>
<li>网络层 - p2p负责广播交易</li>
<li>共识层 - 对哪些交易打包进块形成共识</li>
<li>应用层 - 执行交易，负责交易结果落盘（状态一致）</li>
</ul>
<blockquote>
<p>这里的应用层可能会有误解，并非是Dapp层，对于SDK底层的Tendermint来说，除p2p网络和打包块共识外，其他都算是应用部分，
拿实现比特币公链的例子来讲，应用部分就是维护账户的UTXO数据库，如果对比以太的话，keystore账户和EVM虚机部分就是应用范畴，所以SDK内置了账户、质押、治理、权限等应用模块，可以帮助我们简单地实现底层链的开发。</p>
</blockquote>
<p>可以把这几层简单理解成各节点通过同步交易集（块）日志，实现数据（状态）一致性。数据库的主从模式不也是同步binlog日志，各自执行（replay，回放）日志后，实现数据（状态）最终落盘，区块节点本身同步块的时候，默认就是去下载交易日志，把执行结果按照逻辑链的形式写入本地leveldb的，然后才能对外提供各类RPC服务。</p>
<h2 id=tendermint共识>tendermint共识</h2>
<p>为后续更好的利用cosmos-sdk，要先了解下Tendermint。</p>
<p>Tendermint Core 提供了网络和共识层功能，而应用层要通过ABCI协议和Core互通消息msg，简单讲tendermint负责起一个replication engine进程，而应用层要运行一个state macheine进程，进程间通过ABCI消息来通信。</p>
<p>ABCI协议的消息体用protobuf定义在<a href=https://github.com/tendermint/tendermint/blob/master/abci/types/types.proto>这里</a>，app侧可以响应的request如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang>message Request {
  oneof value {
    RequestEcho echo = <span style=color:#666>2</span>;
    RequestFlush flush = <span style=color:#666>3</span>;
    RequestInfo info = <span style=color:#666>4</span>;
    RequestSetOption set_option = <span style=color:#666>5</span>;
    RequestInitChain init_chain = <span style=color:#666>6</span>;
    RequestQuery query = <span style=color:#666>7</span>;
    RequestBeginBlock begin_block = <span style=color:#666>8</span>;
    RequestCheckTx check_tx = <span style=color:#666>9</span>;
    RequestDeliverTx deliver_tx = <span style=color:#666>19</span>;
    RequestEndBlock end_block = <span style=color:#666>11</span>;
    RequestCommit commit = <span style=color:#666>12</span>;
  }
}
</code></pre></div><p>ABCI的设计主要有以下几个特点：</p>
<ul>
<li>
<p>消息协议</p>
<ul>
<li>成对出现的消息: <code>request</code>/<code>reponse</code></li>
<li>tendermint发起Request， app来响应</li>
<li>使用protobuf定义</li>
</ul>
</li>
<li>
<p>server/client</p>
<ul>
<li>tendermint运行client</li>
<li>app侧运行server端</li>
<li>可以由TSP（支持checkTx和DeliverTx消息的异步处理）、grpc两种方式实现</li>
</ul>
</li>
<li>
<p>区块相关</p>
<ul>
<li>abci是面向连接的</li>
<li>tendermint会创建三个socket连接来和app通信，分别是<code>Mempool</code>, <code>Cosensus</code>, <code>Query</code>连接
<ul>
<li>
<p><code>Mempool连接</code>: 钱包客户端发起交易，会首先进入钱包后台连接的节点的local mempool，该节点通过发送<code>checkTx</code>消息来通知app，去检验交易签名是否有效等等，如果OK节点则会p2p广播该交易到其他节点的mempool里。</p>
</li>
<li>
<p><code>Cosensus连接</code>: 出块节点从mempool的交易集里选出一个块提案（proposer），之后会经过3阶段提交（pre-vote, pre-commit， commit）处理，这个块才能说达成共识（上链了），，只有块被commited了，app侧才会更新状态，比如改变某地址余额等等。app更新状态的时候，是通过Core发送<code>BeginBlock</code>， <code>DeliverTx ...</code>， <code>EndBlock</code>, <code>Commit</code>消息给app侧来完成的，任何写入操作都是通过此连接完成的。</p>
</li>
<li>
<p><code>Query连接</code>： 主要负责一些和共识无关的查询操作，比如块信息，地址余额等等，主要用到<code>Info</code>, <code>SetOption</code>, <code>Query</code>消息</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>整个abci的信息流大致如下：
<img src=/abci.png alt=abci></p>
<p>关于Tendermint和app间数据流的更多细节见下：</p>
<p><img src=/tm-transaction-flow.png alt=dataFlow></p>
<p><a href=https://github.com/mobfoundry/hackatom/blob/master/tminfo.pdf>高清图地址</a></p>
<h2 id=总结>总结</h2>
<p>可以理解成，Tendermint主要负责在BFT环境下同步app间的块交易日志，无论任何交易类型，只要交易块的执行结果是确定性的（唯一性），Tendermint就可以为我们形成区块的共识。</p>
<pre><code>比如说，一个交易的内容在合约里创建一个真随机数，这种交易，tendermint是无法为我们形成共识的，因为多个节点的执行结果是不一样的， 因为这个结果是要在下个区块头的，这样就无法对下个区块形成共识了，所有节点都认为对方在恶意“搞分叉”了。
</code></pre>
<p>目前基于tendermint的项目有很多：</p>
<p>我个人看到好的是<code>BigchainDB</code>和超级账本<code>Burrow</code>项目，更多可以看<a href=https://tendermint.com/ecosystem>这里</a></p>
<p>后续源码介绍，如何基于tendermint创建一个区块链</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-32977a59316b6013d93871144450ab9a>7 - farbic-搭建高并发交易网络</h1>
<div class=lead>联盟链改造方案</div>
<p>针对每秒数千笔交易的场景，默认的CCVC（并发控制版本检查）会导致交易失败率的上升，其实不需要对基础网络本身做特殊设置，从合约代码入手可以解决，参考官方例子<a href=https://github.com/hyperledger/fabric-samples>farbic-samples</a>.</p>
<h3 id=下载项目>下载项目</h3>
<p>基于目前最新的v1.0.3版本来说</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/hyperledger/fabric-samples.git
<span style=color:#a2f>cd</span> fabric-samples/first-network
</code></pre></div><p>未完...</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-cac9c2797f26b94f2afbcd6111d170ec>8 - fabric-示例集群化操作</h1>
<div class=lead>介绍fabric示例中的集群化操作</div>
<p>fabric给出的cc样例都是跑在docker-compose上，这里介绍利用已有的docker-compose.yaml如何集群化运行。</p>
<h3 id=准备样例cc>准备样例CC</h3>
<p>以官方<code>fabric-samples</code>项目里的balance-transfer为例，准备拆分运行在4个虚机里。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/hyperledger/fabric-samples.git
<span style=color:#a2f>cd</span> fabric-samples/balance-transfer
</code></pre></div><p>本CC的示例，主要由3个部分组成:</p>
<ul>
<li>2 CAs</li>
<li>1 SOLO orderer</li>
<li>4 peers (2 peers per Org)</li>
</ul>
<p>其中<code>artifacts</code>目录里放置了：</p>
<ul>
<li>由 <strong>cryptogen</strong> 工具生成的证书信息，后面运行时需要挂载到各自的peer节点里</li>
<li>由 <strong>configtxgen</strong> 工具生成的初始块 <code>genesis.block</code> 和 channel配置信息<code>mychannell.tx</code></li>
</ul>
<h3 id=准备集群>准备集群</h3>
<p>根据上面的情况，下面准备四个虚机来集群化操作, 虚机规划信息如下：</p>
<ul>
<li>air13, 192.168.10.78, 运行ca1，ca2, 这是我的本机</li>
<li>node0, 192.168.10.110, 运行orderer</li>
<li>node1, 192.168.10.114, 运行org1的peer0、peer1</li>
<li>node2, 192.168.10.115, 运行org2的peer0、peer1</li>
</ul>
<p>每个虚机都预先安装docker和docker-compose</p>
<p>修改<code>artifacts/docker-compose.yaml</code>文件，在每个service下添加如下信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extra_hosts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;ca.org1.example.com:192.168.10.78&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;ca.org2.example.com:192.168.10.78&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;orderer.example.com:192.168.10.110&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;peer0.org1.example.com:192.168.10.114&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;peer1.org1.example.com:192.168.10.114&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;peer0.org2.example.com:192.168.10.115&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;peer1.org2.example.com:192.168.10.115&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>此举的作用是在每个容器的<code>/etc/hosts</code>文件里，添加上面的映射，最终docker-compose.yaml文件放置<a href=https://gist.github.com/xiaoping378/8ba8e796552e27277073e56cfd7b281a>gist</a>上了.</p>
<p>最后一步，因为此CC样例运行时，需要挂载本地目录里一些提前生成好的证书，我们还需要把这么需要挂载的东西，同步到每个虚机里，如下操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>rsync -az balance-transfer root@192.168.10.110:~/
rsync -az balance-transfer root@192.168.10.114:~/
rsync -az balance-transfer root@192.168.10.115:~/
</code></pre></div><h3 id=集群化运行>集群化运行</h3>
<p>ssh进入虚机，按照规划启动各自的服务</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 进入air13虚机</span>
<span style=color:#a2f>cd</span> balance-transfer/artifacts/
docker-compose up --no-deps ca.org1.example.com ca.org2.example.com

<span style=color:#080;font-style:italic># ssh进入node0虚机</span>
<span style=color:#a2f>cd</span> balance-transfer/artifacts/
docker-compose up --no-deps orderer.example.com

<span style=color:#080;font-style:italic># ssh进入node1虚机</span>
<span style=color:#a2f>cd</span> balance-transfer/artifacts/
docker-compose up --no-deps peer0.org1.example.com peer1.org1.example.com

<span style=color:#080;font-style:italic># ssh进入node2虚机</span>
<span style=color:#a2f>cd</span> balance-transfer/artifacts/
docker-compose up --no-deps peer0.org2.example.com peer1.org2.example.com
</code></pre></div><p>如上fabric的区块链网络已经集群化运行了</p>
<h3 id=运行app并测试cc>运行APP并测试CC</h3>
<p>在虚机air13上运行我们的前端APP，并测试在网络集群化后的的CC，</p>
<p>此外由于此APP样例的特殊性，还需要修改其他的地方</p>
<ul>
<li>config.json文件里的orderer地址改为<code>"grpcs://192.168.10.110:7050"</code></li>
<li>app/network-config.json里指定地址的地方需要改成<a href=https://gist.github.com/xiaoping378/a599e3bb3080135b2548c1242ca8cc80>这样</a></li>
</ul>
<p>进入balance-transfer目录，如下执行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ npm isntall
$ <span style=color:#b8860b>PORT</span><span style=color:#666>=</span><span style=color:#666>4000</span> node app
</code></pre></div><p>这样前端APP就运行起来了，接下来利用测试脚本<code>testAPIs.sh</code>测试下我们的CC,运行前，还需要修改下脚本里的peer地址，修改后的文件在<a href=https://gist.github.com/xiaoping378/dbfd8801b7b125b0d7add7fce7d4e854>这里</a></p>
<p>运行脚本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./testAPIs.sh
POST request Enroll on Org1  ...

<span style=color:#666>{</span><span style=color:#b44>&#34;success&#34;</span>:true,<span style=color:#b44>&#34;secret&#34;</span>:<span style=color:#b44>&#34;DbzvtdmATgve&#34;</span>,<span style=color:#b44>&#34;message&#34;</span>:<span style=color:#b44>&#34;Jim2 enrolled Successfully&#34;</span>,<span style=color:#b44>&#34;token&#34;</span>:<span style=color:#b44>&#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MDE4NzQ5MjUsInVzZXJuYW1lIjoiSmltMiIsIm9yZ05hbWUiOiJvcmcxIiwiaWF0IjoxNTAxODM4OTI1fQ.LUmfEstviquaD5k5oBMd9KUFaKF1s6ZMY8iO67dKiH0&#34;</span><span style=color:#666>}</span>

。
。
。

GET query Installed chaincodes

<span style=color:#666>[</span><span style=color:#b44>&#34;name: mycc, version: v0, path: github.com/example_cc&#34;</span><span style=color:#666>]</span>

GET query Instantiated chaincodes

<span style=color:#666>[</span><span style=color:#b44>&#34;name: mycc, version: v0, path: github.com/example_cc&#34;</span><span style=color:#666>]</span>

GET query Channels

<span style=color:#666>{</span><span style=color:#b44>&#34;channels&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;channel_id&#34;</span>:<span style=color:#b44>&#34;mychannel&#34;</span><span style=color:#666>}]}</span>

Total execution <span style=color:#a2f>time</span> : <span style=color:#666>13</span> secs ...

</code></pre></div><p>本样例修改后的完整地址在<a href=https://github.com/xiaoping378/fabric-samples>这里</a></p>
<h3 id=总结>总结</h3>
<p>目前集群化后网络里的peers ledger和orderer的数据还是存储在容器里，是否要考虑挂载出来，不然容器挂了再启动后，数据是否会乱了，后续研究下。</p>
<p>后续还会继续搞下CA，MSP和动态添加节点以及合约迭代升级等问题。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e0463540a4a1848ab0876eb50d314c9f>9 - farbic-区块链的生产集群化</h1>
<div class=lead>介绍fabric示例中的生产中的集群化操作</div>
<p>默认社区的demo是基于docker-compose给出的，达到了“一键部署”的效果，但生产上考虑多节点的情况，还需要费些手脚，这里考虑用kompose结合k8s来做这件事。</p>
<h3 id=k8s集群-1-7的初始化>k8s集群 1.7的初始化</h3>
<p>每个节点都要安装docker的步骤，此处略过不表，这里主要介绍利用kubeadm初始化k8s集群，这里不考虑k8s集群本身的高可用，以前有文章专门介绍过。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y apt-transport-https
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat <span style=color:#b44>&lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list
</span><span style=color:#b44>deb http://apt.kubernetes.io/ kubernetes-xenial main
</span><span style=color:#b44>EOF</span>
apt-get update
apt-get install -y kubelet kubeadm
<span style=color:#080;font-style:italic># 默认会自动安装这些包 ebtables kubeadm kubectl kubelet kubernetes-cni socat</span>
</code></pre></div><p>如果你本机是centos的话，可以用如下命令安装</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span><span style=color:#b44>[kubernetes]
</span><span style=color:#b44>name=Kubernetes
</span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span><span style=color:#b44>enabled=1
</span><span style=color:#b44>gpgcheck=1
</span><span style=color:#b44>repo_gpgcheck=1
</span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
</span><span style=color:#b44>        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span><span style=color:#b44>EOF</span>
setenforce <span style=color:#666>0</span>
yum install -y kubelet kubeadm
systemctl <span style=color:#a2f>enable</span> kubelet <span style=color:#666>&amp;&amp;</span> systemctl start kubelet
</code></pre></div><p>上面的命令，需要翻墙才能跑通，没条件的可以去<a href=https://github.com/kubernetes/release>release项目</a>自己编译deb包或者rpm包，如下运行</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/kubernetes/release.git <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>cd</span> release

<span style=color:#080;font-style:italic># debian系如下</span>
docker build --tag<span style=color:#666>=</span>debian-packager debian
docker run --volume<span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span><span style=color:#a2f>pwd</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/debian:/src&#34;</span> debian-packager
<span style=color:#080;font-style:italic># docker run -e &#34;HTTPS_PROXY=127.0.0.1:8118&#34; --net=host --volume=&#34;$(pwd)/debian:/src&#34; debian-packager</span>
<span style=color:#080;font-style:italic># 默认debs包在目录debian/bin/stable/xenial下</span>

<span style=color:#080;font-style:italic># centos系的如下</span>
<span style=color:#a2f>cd</span> rpm
./docker-build.sh
<span style=color:#080;font-style:italic>#默认rpm包在目录output/x86_64/下</span>
</code></pre></div><p>必要依赖搞到手后，就可以简单的利用kubeadm启动集群了
在master节点上如下执行初始化，此过程会启动 etcd，controller-manager，scheduler，api-server组件</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm init --kubernetes-version stable-1.7 --pod-network-cidr<span style=color:#666>=</span>10.244.0.0/16
</code></pre></div><p>在其他节点上执行join操作
现在必须要加上<code>--node-name</code>参数，不然报错误，这是个<a href=https://github.com/kubernetes/kubeadm/issues/347>bug</a></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm join --token 4cc663.c4d99a546c9f3974 192.168.10.78:6443 --node-name node-0
</code></pre></div><p>默认还需要启动pod network，我默认用的flannel。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel-rbac.yml
</code></pre></div><p>另外默认master节点是不会被调度容器的，如下可放开限制</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl taint nodes --all node-role.kubernetes.io/master-
</code></pre></div><p>默认我们得到如下的集群状态</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>➜  ~ kubectl get no
NAME      STATUS    AGE       VERSION
air13     Ready     2h        v1.7.2
node-0    Ready     17m       v1.7.2
</code></pre></div><h3 id=准备fabric的k8ss所需yaml文件>准备fabric的k8ss所需yaml文件</h3>
<p>这里需要用到下载我改过的kompose工具，默认官方的对hostpath的处理，需要引入PV，PVC，虽然这样无可厚非，但对与现阶段的我增加了不必要的复杂度，就动手加了个<code>--hostpaths</code>的选项，</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 下载我改过的工具项目-kompose</span>
git clone https://github.com/xiaoping378/kompose
<span style=color:#a2f>cd</span> kompose <span style=color:#666>&amp;&amp;</span> make
<span style=color:#080;font-style:italic># 如上会编译出kompose来，自己搞到$PATH里</span>
</code></pre></div><p>这里以<a href=https://github.com/hyperledger/fabric-samples.git>fabric-samples项目</a>里的balance-transfer为例，演示一个完整的CC运行在k8s上。</p>
<p>下载fabric-samles项目，</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/hyperledger/fabric-samples.git
<span style=color:#a2f>cd</span> fabric-samples/balance-transfer

kompose convert -f artifacts/docker-compose.yaml -d --hostpaths
<span style=color:#080;font-style:italic># 如上会在当前目录出现批量的deployment和service yaml文件，这里需要针对hostpath的volumes稍作修改</span>

sed -i <span style=color:#b44>&#39;s/.\/channel/\/root\/balance-transfer\/artifacts\/channel/&#39;</span> *-deployment.yaml
<span style=color:#080;font-style:italic>#如上改成绝对路径，另外还需要保证各节点都要有channel目录</span>
rsync -avz balance-transfer root@node-0:~/
</code></pre></div><p>因为ca, peer, orderer都需要从本地读取证书相关的信息，所以要把各节点利用<code>nodeSelector</code>特性绑定到指定的节点上，这一点以后得改掉，利用env来动态生成（待验证）</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic>#比如让要在特定节点调度特定容器，需要如下操作</span>
kubectl label node node0 <span style=color:#b8860b>ca</span><span style=color:#666>=</span>ture
</code></pre></div><p>还要在对应的deployment文件做如下操作</p>
<p><img src=/nodeSelector.png alt=nodeSelector></p>
<p>-- 未完待续。。。</p>
</div>
</main>
</div>
</div>
<footer class="bg-dark py-5 row d-print-none">
<div class="container-fluid mx-sm-5">
<div class=row>
<div class="col-6 col-sm-4 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="个人邮箱 xiaoping378@163.com" aria-label="个人邮箱 xiaoping378@163.com">
<a class=text-white target=_blank rel=noopener href=mailto:xiaoping378@163.com aria-label="个人邮箱 xiaoping378@163.com">
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=微博 aria-label=微博>
<a class=text-white target=_blank rel=noopener href=https://weibo.com/xiaoping378 aria-label=微博>
<i class="fab fa-weibo"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=知乎 aria-label=知乎>
<a class=text-white target=_blank rel=noopener href=https://www.zhihu.com/people/xiaoping378 aria-label=知乎>
<i class="fab fa-zhihu"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank rel=noopener href=https://github.com/xiaoping378/xiaoping378.github.io aria-label=GitHub>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank rel=noopener href=https://example.org/slack aria-label=Slack>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list">
<a class=text-white target=_blank rel=noopener href=https://example.org/mail aria-label="Developer mailing list">
<i class="fa fa-envelope"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
<small class=text-white>&copy; 2022 xiaoping378 保留所有权利</small>
<small class=ml-1><a href=# target=_blank rel=noopener>隐私政策</a></small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap.min.js integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA==" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script>
<script src=/js/deflate.js></script>
<script src=/js/main.min.e016890ed6b0c42f5af3410eb57ac626a192a868609aee68cefe1e0f84a50b13.js integrity="sha256-4BaJDtawxC9a80EOtXrGJqGSqGhgmu5ozv4eD4SlCxM=" crossorigin=anonymous></script>
</body>
</html>