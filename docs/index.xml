<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>现代技能栈 – 文集</title><link>https://xiaoping378.github.io/docs/</link><description>Recent content in 文集 on 现代技能栈</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://xiaoping378.github.io/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 什么是以太坊</title><link>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%9F%BA%E7%A1%800/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%9F%BA%E7%A1%800/</guid><description>
&lt;h3 id="目录">目录&lt;/h3>
&lt;ol>
&lt;li>什么是以太坊&lt;/li>
&lt;li>应用场景&lt;/li>
&lt;li>趋势展望&lt;/li>
&lt;/ol>
&lt;h3 id="内容">内容&lt;/h3>
&lt;p>1.什么是以太坊&lt;/p>
&lt;p>以太坊是一个全新开放的区块链平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。&lt;/p>
&lt;p>1.1. 从名字说起&lt;/p>
&lt;p>以太坊 == ethereum，&lt;/p>
&lt;p>Ether，物理学里面有个以太，绝对静止的存在于空间的那种物质，尚未证明是否真实存在，在某领域里，它被称为虚空，空间…是一种能承载万物的东西，是一种目前还难以解释和观察的东西。&lt;/p>
&lt;p>至于这个“坊”字，也不知道是谁先翻译叫起来的，反正现在大家都这么叫。&lt;/p>
&lt;p>1.2 从功能说起&lt;/p>
&lt;p>&lt;a href="https://www.ethereum.org/ether">以太&lt;/a>是区块链网络里很重要的元素 -- 燃料 -- 以太币，为计算付费。&lt;/p>
&lt;pre>&lt;code>1. 开发人员发布Dapp
2. 用户和Dapp交互
3. 挖矿得到报酬（维持网络稳定的）
4. 金融交易
&lt;/code>&lt;/pre>
&lt;p>1.3 从产出&lt;/p>
&lt;ul>
&lt;li>2014年9月份预售阶段发了6千万以太币，（募集到 31,531 个比特币）&lt;/li>
&lt;li>其中20%用于以太基金的运作，主要是给开发人员发工资。&lt;/li>
&lt;li>挖矿，大概每15秒左右出一个块，作为报酬，出块的人可以得到5个以太&lt;/li>
&lt;li>打包叔块的人会得到2-3个以太&lt;/li>
&lt;/ul>
&lt;p>自从&lt;a href="https://blog.ethereum.org/2017/10/12/byzantium-hf-announcement/">Byzantium update&lt;/a>升级后，现在挖矿和挖到叔块的人会分别得到3和0.625-2.625个以太。&lt;/p>
&lt;p>1.4 FAQ&lt;/p>
&lt;p>1.4.1 以太比会无限发行么？&lt;/p>
&lt;p>不会， 当时预售的时候规定，每年的发行量是1800万上限（被挖到），计划在17年底，会切换共识算法从POW到&lt;a href="https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/">Casper&lt;/a>上，之后出块效率更高，需要的挖矿补贴更少, 具体发行多少，现在还未定。&lt;/p>
&lt;p>1.4.2 以太币和比特币的对比？&lt;/p>
&lt;p>如果后者，以太币是不可能实现的，在整个数字生态是互补关系，Ether应被视为“加密燃料”，其目的是为计算付费，而不是用作或被视为货币，资产，份额或其他任何东西。&lt;/p>
&lt;p>&lt;img src="https://www.ethereum.org/images/bitcoin-and-ethereum-sitting-on-a-tree@2x.png" alt="">&lt;/p>
&lt;p>技术层面的对比&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/BTC-ETH.png" alt="">&lt;/p>
&lt;p>1.2 账户&lt;/p>
&lt;p>以太坊有两种类型的账户：&lt;/p>
&lt;ul>
&lt;li>外部账户（由私钥控制的）&lt;/li>
&lt;li>合约账户（由合约代码控制）。&lt;/li>
&lt;/ul>
&lt;p>另种账户都可以发起交易，后者被动发送。&lt;/p>
&lt;p>外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。&lt;/p>
&lt;p>UTXOs的好处有：
更加私密（用户要是每笔交易都换一个地址，那么就很难找到其中两个地址的相关性）；潜在的可扩展性。&lt;/p>
&lt;p>账户的好处：
节省大量空间（每笔交易只有一个输入、一个输出、一个签名）；更大的可替代性；简单（编码简单，不需要更为复杂脚本）；&lt;/p>
&lt;p>1.3 以太坊虚拟机EVM&lt;/p>
&lt;p>1.4 挖矿&lt;/p>
&lt;p>1.5 网络&lt;/p>
&lt;p>目前有主链和测试链之分，测试网已经运行到3代了&lt;/p>
&lt;p>测试链的区别：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethereum-tesnet.png" alt="">&lt;/p>
&lt;p>主链：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethereum-mainnet.png" alt="">&lt;/p>
&lt;ol>
&lt;li>应用场景&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>金融服务:主要是降低交易成本,减少跨组织交易风险等。该领域的区块链应用将最快
成熟起来,银行和金融交易机构将是主力推动者。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>征信和权属管理:这是大型社交平台和保险公司都梦寐以求的,目前还缺乏足够的数据
来源、可靠的平台支持和有效的数据分析和管理。该领域创业的门槛极高,需要自上而
下的推动。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>资源共享:airbnb 为代表的公司将欢迎这类应用,极大降低管理成本。这个领域创业门
槛低,主题集中,会受到投资热捧。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>投资管理:无论公募还是私募基金,都可以应用区块链技术降低管理成本和管控风险。
虽然有 DAO 这样的试水,谨慎认为该领域的需求&lt;a href="http://www.8btc.com/thedao-expolit-analysis">还未成熟&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>物联网与供应链:物联网是很适合的一个领域,短期内会有大量应用出现,特别是租
赁、物流等特定场景。但物联网自身的发展局限将导致短期内较难出现规模应用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>趋势展望&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethereum-future.png" alt="">&lt;/p>
&lt;p>一个是 技术领域也存在着周期律。这个周期目前看是7-8 年左右。或许正如人有“七年之
痒”,技术也存在着七年这道坎,到了这道坎,要么自身突破迈过去,要么往往就被新的技术
所取代。如果从比特币网络上线(2009 年1月)算起,到今年正是在坎上。因此,现在正是
相关技术进行突破的好时机。&lt;/p>
&lt;p>为何恰好是7年? 7年按照产品周期来看基本是2-3个产品周期,所谓事不过三,经过2-3
个产品周期也差不多该有个结论了。&lt;/p>
&lt;p>另外,最早出现的未必是先驱,也可能是先烈。创新固然很好,但过早播撒的种子,没有合
适的土壤,往往也难长大。技术创新与科研创新很不同的一点便是,技术创新必须立足于需
求,过早过晚都会错失良机。科研创新则要越早越好,最好像二十世纪那批物理巨匠们一
样,让后人吃了一百多年的老本。&lt;/p>
&lt;p>最后,事物的发展往往是延续的、长期的。 新生事物大都不是凭空蹦出来的,往往是解决了
前辈未能解决的问题,或是出现了之前未曾出现过的场景。而且很多时候,新生事物会在历
史的舞台下面进行长期的演化,只要是往提高生产力的正确方向,迟早会出现在舞台上的一
天。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethereum-giveup.png" alt="">
&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/br>&lt;/p>
&lt;h1 id="qa">QA ?&lt;/h1></description></item><item><title>Docs: 机器学习的语言之争</title><link>https://xiaoping378.github.io/docs/3-devops/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/</guid><description>
&lt;p>原文：&lt;a href="http://sebastianraschka.com/blog/2015/why-python.html">Python, Machine Learning, and Language Wars - A Highly Subjective Point of View&lt;/a>&lt;/p>
&lt;hr>
&lt;p>噢，天呀，那些主观有针对性的，自以为标题党的文章的另一个？是哒！为什么我还要不厌其烦的写下来呢？嗯，这里是来自于我的前教授的最琐碎但又改变生活的洞察和世俗的智慧之一，它已经成为了我的口头禅了：“如果你必须做这个任务超过三次以上，那么只要写一个脚本，然后对其自动化。”&lt;/p>
&lt;p>现在，你或许已经开始琢磨这个博客了。我已经超过半年没写什么东西了！好吧，&lt;a href="https://twitter.com/rasbt">沉迷在社交网络平台&lt;/a>除外，那不是真的：我写了&lt;a href="https://github.com/rasbt/python-machine-learning-book">一些东西&lt;/a> —— 准确来说，约400页。最近，对我来说，这真的已经是一次旅程了。而对于经常被问道的问题“为什么你选择Python来进行机器学习？”，我猜，是时候来写_我的脚本_了。&lt;/p>
&lt;p>在下面的段落中，我真的不打算告诉你为什么_你_或者其他人应该使用Python。老实说，我真心讨厌那类问题：“哪个&lt;em>最好？”（这里，用“编程语言、文本编辑器、IDE、操作系统、计算机制造商”替换掉&lt;/em>）。这实在是扯淡。虽然有时它挺有意思的，但是我建议你节省下关于这个问题的时间，用来在下班后跟朋友或者同事偶尔喝喝啤酒或咖啡。&lt;/p>
&lt;h4 id="目录">目录&lt;/h4>
&lt;!-- MarkdownTOC -->
&lt;ul>
&lt;li>&lt;a href="#%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%80%E7%9F%AD%E5%9B%9E%E7%AD%94">对于一个复杂问题的简短回答&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%88%91%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84python%E5%B7%A5%E5%85%B7%E6%98%AF%E4%BB%80%E4%B9%88">我最喜欢的Python工具是什么？&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%88%91%E5%AF%B9matlab%E6%98%AF%E6%80%8E%E4%B9%88%E7%9C%8B%E7%9A%84">我对MATLAB是怎么看的？&lt;/a>&lt;/li>
&lt;li>&lt;a href="#julia%E7%9C%9F%E6%A3%92%E7%90%86%E8%AE%BA%E4%B8%8A">Julia真棒……理论上！&lt;/a>&lt;/li>
&lt;li>&lt;a href="#r%E5%AE%9E%E5%9C%A8%E6%B2%A1%E5%95%A5%E9%94%99">R实在没啥错&lt;/a>&lt;/li>
&lt;li>&lt;a href="#perl%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">Perl发生了什么？&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%85%B6%E4%BB%96%E8%A7%82%E7%82%B9">其他观点&lt;/a>&lt;/li>
&lt;li>&lt;a href="#python%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E6%AD%BB%E6%8E%89%E7%9A%84%E8%AF%AD%E8%A8%80%E5%90%97">Python是一个正在死掉的语言吗？&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%80%BB%E7%BB%93">总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%8F%8D%E9%A6%88%E5%92%8C%E8%A7%82%E7%82%B9">反馈和观点&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#python">Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="#perl">Perl&lt;/a>&lt;/li>
&lt;li>&lt;a href="#r">R&lt;/a>&lt;/li>
&lt;li>&lt;a href="#matlaboctave">MATLAB/Octave&lt;/a>&lt;/li>
&lt;li>&lt;a href="#julia">Julia&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80-%E6%88%91%E5%BF%98%E8%AE%B0%E6%8F%90%E7%9A%84%E9%82%A3%E4%BA%9B">其他语言 (我忘记提的那些)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /MarkdownTOC -->
&lt;h2 id="对于一个复杂问题的简短回答">对于一个复杂问题的简短回答&lt;/h2>
&lt;p>或许我应该从一个简短的回答开始。欢迎你停止阅读这段后面的文章，因为它真的解决掉这个问题了。我是一个科学家，我喜欢完成我的工作。我喜欢有一个环境，在那里我可以快速原型，并记下我的模型和想法。我需要解决非常特殊的问题。我分析给定的数据集以得出结论。这对我来说是最重要的：我怎样才能最多产的完成我的工作呢？“多产”这里意味着什么？好吧，我通常只进行一次分析 (不同的想法测试和调试除外); 我不需要重复地24/7地运行一段特定的代码，我并不是在为最终用户开发软件应用或web应用。当我_量化y_ “多产”时，我从字面上评估(1) 把想法以代码的形式写下来所花费的时间，(2) 调试的时间和 (3) 执行的时间之和。对我来说，“最多产”意味着“获得结果需要花费多少时间？” 现在，这么多年来，我发现，Python就是为我而生的。并非总是如此，但很多时候是这样。正如生活中的其他东西一样，Python并不是“银弹”，它并非总是每一个问题的“最佳”解决方案。然而，如果你跨常见和不那么常见的问题任务来比较编程语言的话，它已经非常接近（最佳解决方案）了；Python可能是最通用，最有能力的全才。&lt;/p>
&lt;p>&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/the_general_problem.png" alt="">&lt;/p>
&lt;p>(来源: &lt;a href="https://xkcd.com/974/">https://xkcd.com/974/&lt;/a>)&lt;/p>
&lt;p>请记住：“过早的优化是一切罪恶的根源” (Donald Knuth)。如果你是那种想要从机器学习和数据科学划分中中优化下一个颠覆性高频交易模型的软件工程团队中的一员，那么Python可能不适合你 (但或许它是数据科学团队的语言选择，所以学习如何读懂它仍然有用)。因此，我的一个小小的忠告是，当你选择一门语言时，评估你每天的问题任务和需求。“如果你只有一把锤子，那么一切开始看起来都像一个钉子” – 你聪明得不会掉入这个陷阱！然而，记住，有一个平衡点。在有些场景下，即使螺丝刀可能是“更漂亮的”解决方法，锤子可能还是最好的选择。再次，这归结为生产力。&lt;/p>
&lt;p>&lt;strong>让我从个人经历中挑个例子来说说。&lt;/strong> 关于一个非常问题相关的假设，我需要开发一堆新颖的算法来“筛选”1千5百万个小的化合物。我完全是一个计算型人，但我和进行非计算性实验（我们称它们为“湿实验室”实验）的生物学家一起合作。目标是缩小它到一个包含100个潜在化合物的列表，这样他们可以在实验室里测试它们。提醒是，他们需要快速获得结果，因为他们仅有有限的实际来做实验。相信我，时间真的是“有限的”：在必须收集结果之前，我们刚让我们的补助金申请受理和研究得到资助 (我们的合作者对某种特定的只知春季产卵的幼虫做实验)。因此，我开始想“我要怎样尽可能快的把结果给他们？” 嗯，我懂C++和FORTRAN，如果我在各个语言中实现那些算法，那么与Python实现相比，执行“筛选”运行也许会更快些。这更多是一种有根据的猜测，我真的不知道实质上是否会更快。但有一件事我可以肯定：如果我开始用Python写代码，那么我可以让它在几天内运行 – 或许让对应的C++版本能够跑起来需要花一周的时间。以后，我会操心一个更有效的实现。在那一刻，重要的是，把那些结果拿给我的合作者 – “过早的优化是一切罪恶的根源。” 边注：相同的思路运用到数据存储解决方案。这里，我只是使用SQLite。CSV没有多大意义，因为我必须重复地注释和检索某些分子。我当然不想每次想要查看一个分子或者操作它的时候，都要全过程扫描或重写一个CSV – 在处理内存容量预留的问题。也许用MySQL会更好，但是出于上面提到的原因，我想快速地完成这项工作，并建立一个额外的SQL服务器……没时间做它了，用SQLite来完成这项工作挺好的。&lt;/p>
&lt;p>&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/automation.png" alt="">&lt;/p>
&lt;p>(来源: &lt;a href="https://xkcd.com/1319/">https://xkcd.com/1319/&lt;/a>)&lt;/p>
&lt;p>结论：**选择满足_你的_需求的那个语言！**不过，这里有一个小小的告诫！初学者在学习一门语言之前怎么能知道它的优势和缺点，程序员应该怎么知道这门语言对她来说会是有用的呢？这就是我会做的事：只要在谷歌和&lt;a href="https://github.com">GitHub&lt;/a>上搜索那些与你最常见的问题任务有关的特别的应用和解决方法。你不需要阅读和了解代码。只需要看看最终产品，另外，不要犹豫问别人。不要只是询问一般“最好的”编程语言，而是具体点，描述你的目标以及为什么你想要学习如何编程。如果你想为MacOS X开发应用，那么你可能会想要看看Objective C和Swift，如果你想在Android上开发，那么你可能会对Java更感兴趣，以此类推。&lt;/p>
&lt;h2 id="我最喜欢的python工具是什么">我最喜欢的Python工具是什么？&lt;/h2>
&lt;p>如果你感兴趣，那些是我最喜欢并且最常使用的Python“工具”，每天，我都会使用它们中的大部分。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.numpy.org">NumPy&lt;/a>: 我处理线性代数阵列结构和量化公式最喜欢的库；由&lt;a href="http://scipy2015.scipy.org/ehome/index.php?eventid=115969&amp;amp;">SciPy&lt;/a>增强。&lt;/li>
&lt;li>&lt;a href="https://theano.readthedocs.org/en/latest/">Theano&lt;/a>: 为机器学习算法减负，并将计算分布到我的GPU内核中。&lt;/li>
&lt;li>&lt;a href="http://scikit-learn.org/stable/">scikit-learn&lt;/a>: 用于每日、更基本的机器学习任务的最方便的API。&lt;/li>
&lt;li>&lt;a href="http://matplotlib.org">matplotlib&lt;/a>: 当涉及到画图时，这是我所选择的库。有时，我还使用&lt;a href="http://stanford.edu/~mwaskom/software/seaborn/index.html">seaborn&lt;/a>来绘制特殊的图，例如，热图超级棒！&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/heatmap.png" alt="">&lt;/p>
&lt;p>(来源: &lt;a href="http://stanford.edu/~mwaskom/software/seaborn/examples/structured_heatmap.html">http://stanford.edu/~mwaskom/software/seaborn/examples/structured_heatmap.html&lt;/a>)&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://flask.pocoo.org">Flask (Django)&lt;/a>: 难得，我想要将一个想法转换成一个web应用。这里，Flask非常方便！&lt;/li>
&lt;li>&lt;a href="http://www.sympy.org/en/index.html">SymPy&lt;/a>: 对于符号数学，对我来说，它取代了WolframAlpha。&lt;/li>
&lt;li>&lt;a href="http://pandas.pydata.org">pandas&lt;/a>: 处理相当小的数据集，大多数来自于CSV文件。&lt;/li>
&lt;li>&lt;a href="https://docs.python.org/2/library/sqlite3.html">sqlite3&lt;/a>:注释和查询“中型”数据集。&lt;/li>
&lt;li>&lt;a href="http://ipython.org">IPython notebooks&lt;/a>: 我还能说什么呢？我90%的研究发生在IPython notebooks。它只是一个让所有的东西都放在一个地方的好环境：想法、代码、注释、LaTeX方程、插图、图表、输出……&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/ipython_notebook.png" alt="">&lt;/p>
&lt;p>注意，IPython项目最近演变成了&lt;a href="https://jupyter.org">Jupyter项目&lt;/a>。现在，你不止可以使用Jupyter notebook环境到Python上，还可以是R, Julia, 等等。&lt;/p>
&lt;h2 id="我对matlab是怎么看的">我对MATLAB是怎么看的？&lt;/h2>
&lt;p>几年前，我想当常用MATLAB (/Octave)；大多数的计算机科学数据科学课都是用MATLAB。我真的觉得这对于原型真的一点儿都不是一个糟糕的环境！由于它的设计充分考虑了线性代数 (用于MATrix LABoratory的MATLAB)，当涉及到实现机器学习算法时，比之Python/NumPy，MATLAB让人感觉更多点“自然” —— 好啦，为了公平起见，&lt;a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html">1-indexed&lt;/a>编程语言对我们程序员来说，可能看起来有点奇怪。但是，记住，MATLAB带有一个大的价格标签，我认为它真正慢慢地淡出学术界以及工业界。此外，毕竟，我是开源粉 ;)。另外，与其他“生产性”的语言相比，它的性能也并不是那么的引人注目。看看下面的标准：&lt;/p>
&lt;p>&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/julia_benchmark.png" alt="">&lt;/p>
&lt;p>(相对于C的基准次数 —— 越小越好，C的性能 = 1.0; 来源: &lt;a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/&lt;/a>)&lt;/p>
&lt;p>然而，我们不应忘记，对于Python，也有这样整洁的Theano库。在2010年，Theano的开发者报道，当代码运行在CPU时，它比NumPy快1.8倍，而如果Theano针对GPU，那么它甚至比NumPy快11倍 (J. Bergstra, O. Breuleux, F. Bastien, P. Lamblin, R. Pascanu, G. Desjardins, J. Turian, D. Warde-Farley, 和Y. Bengio. Theano: Python中的的一个CPU和GPU运算编译器。在Proc. 9th Python in Science Conf, 第1–7页，2010年。)。现在，记住，这个Theano基准是来自2010年，而多年来，Theano得到了显著的改善，现代显卡的功能也是。&lt;/p>
&lt;blockquote>
&lt;p>我了解到，很多希腊人相信毕达哥拉斯所说的，所有的东西都是从数字生成的。这个断言带来了一个难题：不存在的东西怎么可以甚至设想生成？- Theano of Croton (哲学家，公元前6世纪)&lt;/p>
&lt;/blockquote>
&lt;p>PS: 如果你不喜欢NumPy的&lt;code>dot&lt;/code>方法，那么敬请期待即将到来的&lt;a href="https://docs.python.org/3.6/whatsnew/3.5.html">Python 3.5&lt;/a> – 对于矩阵乘法，我们将获得一个中缀&lt;a href="http://legacy.python.org/dev/peps/pep-0465/">运算符&lt;/a>，耶！&lt;/p>
&lt;p>“手动的”矩阵矩阵乘法 (我的意思是，无需NumPy的帮助，而BLAS或者LAPACK看起来繁琐且非常低效)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">
[[&lt;span style="color:#666">1&lt;/span>, &lt;span style="color:#666">2&lt;/span>], [[&lt;span style="color:#666">5&lt;/span>, &lt;span style="color:#666">6&lt;/span>], [[&lt;span style="color:#666">1&lt;/span> &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#666">5&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">2&lt;/span> &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#666">7&lt;/span>, &lt;span style="color:#666">1&lt;/span> &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#666">6&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">2&lt;/span> &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#666">8&lt;/span>],
[&lt;span style="color:#666">3&lt;/span>, &lt;span style="color:#666">4&lt;/span>]] x [&lt;span style="color:#666">7&lt;/span>, &lt;span style="color:#666">8&lt;/span>]] &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#666">3&lt;/span> &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#666">5&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">4&lt;/span> &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#666">7&lt;/span>, &lt;span style="color:#666">3&lt;/span> &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#666">6&lt;/span> &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#666">4&lt;/span> &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#666">8&lt;/span>]]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们有线性代数和经过优化的库来处理它，谁还会想使用嵌套的for循环来实现这个表达式！？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">
&lt;span style="color:#666">&amp;gt;&amp;gt;&amp;gt;&lt;/span> X &lt;span style="color:#666">=&lt;/span> numpy&lt;span style="color:#666">.&lt;/span>array()
&lt;span style="color:#666">&amp;gt;&amp;gt;&amp;gt;&lt;/span> W &lt;span style="color:#666">=&lt;/span> numpy&lt;span style="color:#666">.&lt;/span>array()
&lt;span style="color:#666">&amp;gt;&amp;gt;&amp;gt;&lt;/span> X&lt;span style="color:#666">.&lt;/span>dot(W)
[[&lt;span style="color:#666">19&lt;/span>, &lt;span style="color:#666">22&lt;/span>],
[&lt;span style="color:#666">43&lt;/span>, &lt;span style="color:#666">50&lt;/span>]]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，如果这个&lt;code>dot&lt;/code>产品对你来说并无吸引力，那么这是它将会在Python 3.5中的样子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">
&lt;span style="color:#666">&amp;gt;&amp;gt;&amp;gt;&lt;/span> X &lt;span style="color:#666">@&lt;/span> W
[[&lt;span style="color:#666">19&lt;/span>, &lt;span style="color:#666">22&lt;/span>],
[&lt;span style="color:#666">43&lt;/span>, &lt;span style="color:#666">50&lt;/span>]]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>老实说，我不得不承认，我并不一定是“@”符号作为矩阵操作符的一个大粉丝。然而，我真的长时间苦苦想了这个问题，没法找到更好的“未使用的”符号了。如果你有更好的想法，请让我知道，我真的很好奇！&lt;/p>
&lt;h2 id="julia真棒-理论上">Julia真棒……理论上！&lt;/h2>
&lt;p>我认为Julia是一个伟大的语言，并且我会将其推荐给那些开始编程和机器学习的人。虽然，我不确定是否真的应该这样做。为什么呢？要把自己交给这个编程语言，是有点悲伤矛盾的。使用Julia，我们无法肯定在接下来的几年内，它是否会变得够“流行”。等等，“流行性”跟一门编程语言有多棒多有用有啥关系？让我告诉你。窘境是，最有用的语言不一定是设计良好的，但一定是流行的。为什么？&lt;/p>
&lt;ol>
&lt;li>已经有大量的（大多数是免费的）库以供你使用，这样一来，你可以对你的时间尽其所用，而无需重新发明轮子。&lt;/li>
&lt;li>在线查找帮助、教程和样例容易得多。&lt;/li>
&lt;li>更频繁的语言改善、更新和补丁，会让它“甚至更好”。&lt;/li>
&lt;li>对协作更友好，并且在团队中工作更简单。&lt;/li>
&lt;li>更多的人会从你的代码中受益 (例如，如果你决定将其分享到GitHub上)。&lt;/li>
&lt;/ol>
&lt;p>就个人而言，我爱Julia本身。它完美的匹配了我的个人兴趣。虽然，我使用Python；主要是因为已经有了那么多超级棒的东西在那里了，这使得它格外得心应手。Python社区一切安好，而我相信在（至少）下一个5到10年内，它还会存在并蓬勃发展。但是对于Julia，我并没那么肯定。我喜欢设计，我觉得这很棒。尽管如此，如果它并不流行，那么我无法分辨它是“面向未来的”。如果在几年内发展停止了呢？我会对那些在这点上将“死”的东西进行投资。然而，如果每个人都这样想，那么新语言就永远没戏了。&lt;/p>
&lt;h2 id="r实在没啥错">R实在没啥错&lt;/h2>
&lt;p>嗯，我猜我曾经是一个R人，这并不是什么大秘密。甚至我还写过一本关于它的书 (好吧，准确来讲，实际上是关于&lt;a href="http://www.amazon.com/Instant-Heat-Maps-R-How-/dp/1782165649/ref=sr_1_1?ie=UTF8&amp;amp;qid=1372160113&amp;amp;sr=8-1&amp;amp;keywords=instant+heat+maps+in+r+how-to">R中的热图(Heat maps in R)&lt;/a>。注意，这是在几年前，在&lt;code>ggplot2&lt;/code>是个事之前。没有真正令人信服的理由让你去看看 —— 我指的是这本书。不过，如果你无法抗拒要看看的话，这是免费的、5分钟就可读完的&lt;a href="http://sebastianraschka.com/Articles/heatmaps_in_r.html">简短版本&lt;/a>)。我同意，有点扯远了。所以，回到讨论：R怎么了？我觉得它完全没有不好的地方。我的意思是，毕竟，对于“数据科学”，R是非常强大的，并且完全可以胜任且“大众化”的语言！不久前，甚至微软也开始非常非常感兴趣：&lt;a href="http://www.cio.com/article/2906456/data-analytics/microsoft-closes-acquisition-of-r-software-and-services-provider.html">Microsoft收购Revolution Analytics，一家用于统计计算和预测分析的开源R编程语言服务商业提供商&lt;/a>。&lt;/p>
&lt;p>所以，我可以如何总结下对于R的感受呢？我不大确定这句话出自何处 —— 我在前段时间从某处某人那里看到的 —— 但它很好的解释了R和Python之间的区别：“R是统计学家为了自己开发的一门编程语言；而Python是计算机科学家开发的，程序员可以用它来应用统计技术。”该消息的部分是，R和Python都同样能够用于“数据科学”任务，然而，Python语法对我来说，只是感觉更自然 —— 这是个人品味问题。&lt;/p>
&lt;p>我只想提出，Theano和在GPU上计算是Python的一个大增益，但我看到R也完全可以：&lt;a href="http://blog.revolutionanalytics.com/2015/01/parallel-programming-with-gpus-and-r.html">GPU和R上的并行编程&lt;/a>。我知道接下来你想问什么：“好吧，那么要是把我当模型编程一个漂亮_闪亮_的web应用又如何？我打赌，这是你没法在R中做的事！” 抱歉，但是你输了；看看&lt;a href="http://www.rstudio.com/shiny/">Shiny by RStudio，一个R语言的web应用框架&lt;/a>。你明白我的意思吗？这里没有赢家。可能永远都不会有。&lt;/p>
&lt;p>把我最喜欢的Python引述中的一个从其原有语境中拿出来：“这里，我们都是大人” —— 不要在把我们的时间浪费在语言之争上了。选择那个“适合”你的语言。当涉及到就业市场上的观点：这里也没有对错。我不认为要聘请你为“数据科学家”的公司真的会计较你最喜欢的工具箱 —— 毕竟，编程语言只是“工具”。而最重要的技能是像“数据科学家”一样思考，问正确的问题，能够解决问题。难的是数学和机器学习理论，新的编程语言是可以很容易学到的。试想一下，你学会了如何挥舞锤子来把钉子敲进去，而从不同的制造商那里挑一把锤子能有多难？但如果你仍然感兴趣，例如看看TIOBE Index，_一个_编程语言流行性的估量：&lt;/p>
&lt;p>&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/tiobe.png" alt="">&lt;/p>
&lt;p>(来源: &lt;a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html&lt;/a>)&lt;/p>
&lt;p>但是，如果我们看看来自Spectrum IEEE的&lt;a href="http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages">2015年十大编程语言&lt;/a>，那么会发现，R语言正在快速攀升(左列：2015，右列：2014）。&lt;/p>
&lt;p>&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/spectrum.jpg" alt="">&lt;/p>
&lt;p>(来源: &lt;a href="http://spectrum.ieee.org/computing/software/the%E2%80%932015-top-ten-programming-languages">http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages&lt;/a>)&lt;/p>
&lt;p>我想你了解了。Python和R，不再有什么真正打的区别了。此外，当你在选择使用哪个语言的时候，你不应该担心工作计划。&lt;/p>
&lt;h2 id="perl发生了什么">Perl发生了什么？&lt;/h2>
&lt;p>Perl是在我早起职业生涯中选取的第一门语言(当然，除了高中时使用的Basic, Pascal, 和Delphi)。在我还是德国的一个大学生的时候，我上了一门Perl编程课。那时，我真心喜欢它，但是，嘿，在这点上，我确实没有什么好对其进行比较的。就个人而言，我只知道少数几个积极使用Perl为每天写脚本。虽然，我认为在生物信息学领域这仍然相当普遍!? 不管怎么说，让我们保持这部分简短，让它安息：“&lt;a href="http://archive.oreilly.com/pub/post/perl_is_dead_long_live_perl.html">“Perl死了。Perl万岁。”&lt;/a>&lt;/p>
&lt;h2 id="其他观点">其他观点&lt;/h2>
&lt;p>还有许多其他语言可以用于机器学习，例如，&lt;a href="https://www.ruby-lang.org">Ruby&lt;/a> (&lt;a href="http://www.amazon.com/Thoughtful-Machine-Learning-Test-Driven-Approach/dp/1449374069/ref=sr_1_1?ie=UTF8&amp;amp;qid=1440407371&amp;amp;sr=8-1&amp;amp;keywords=machine+learning+ruby">Thoughtful Machine Learning: A Test-Driven Approach&lt;/a>), &lt;a href="https://www.java.com/en/">Java&lt;/a> (&lt;a href="http://java-ml.sourceforge.net">Java-ML&lt;/a>), &lt;a href="http://www.scala-lang.org">Scala&lt;/a>(&lt;a href="https://github.com/scalanlp/breeze">Breeze&lt;/a>), &lt;a href="http://www.lua.org">Lua&lt;/a>(&lt;a href="http://torch.ch">Torch&lt;/a>), 等等。然而，除了我多年前参与的一个Java类，或者&lt;a href="https://spark.apache.org/docs/0.9.0/python-programming-guide.html">PySpark&lt;/a>, 这一用于Spark的Python API，它是用Scala写的，我真的没有使用那些语言的丰富经验，因此不知道该说些什么好。&lt;/p>
&lt;h2 id="python是一个正在死掉的语言吗">Python是一个正在死掉的语言吗？&lt;/h2>
&lt;p>这是一个合法的问题，最近它在Quora出现了，如果你想听听关于这个的一些其他不错的观点，那么看看这个&lt;a href="http://www.quora.com/Is-it-true-that-Python-is-a-dying-language">问题支线&lt;/a>。不过，如果你想听听我的观点，我会说，不，它不是。为什么？好吧，Python是一门“相当”古老的语言 —— 它的第一个版本是在90年代初的某个时候 (我们可以从1991年开始算起)，它像每一个编程语言一样，不得不做出某些选择和妥协。每一个编程语言都有它自己的怪癖，而更现代的语言趋向于从过去的错误中学习，这是件好事 (顺便说一下，R是在Python之后不久发布的：1995)。 Python远不“完美”，而像其他每个语言一样，它有自己的缺点。作为一个核心Python用户，我必须提一下，GIL (Global Interpreter Lock，全局解释锁)是让我最苦恼的东西 —— 但是请注意，有一个多进程和多线程模块，因此它实际上并非是一种限制，而是某些上下文中的小小“不便”。&lt;/p>
&lt;p>对于一个编程语言“多棒”并无可以量化的度量，它真正取决于你在找寻什么。你想要问的问题是：“我想要实现什么，哪一个是实现它的最好的工具” —— “如果你只有一把锤子，那么一切开始看起来都像一个钉子。”再次说到锤子和钉子，Python是非常灵活的，我每天大部分的研究都是通过Python，使用强大的scikit-learn机器学习库 —— 用于数据改写的pandas，用户可视化的matplotlib/seaborn，以及用以跟踪所有这些东西的IPython notebooks —— 来完成的。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>好啦，这是对于一个看似很简单的问题的一个相当长的答案。相信我，我可以花几小时或几天继续写下去。但为嘛要把事情搞复杂呢？让我们总结一下：&lt;/p>
&lt;p>&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/python.png" alt="">&lt;/p>
&lt;p>(来源: &lt;a href="https://xkcd.com/353/">https://xkcd.com/353/&lt;/a>)&lt;/p>
&lt;h2 id="反馈和观点">反馈和观点&lt;/h2>
&lt;p>我想要跟你分享关于这篇文章的很多很好的意见。记住，“一句忠告”有所偏颇是自然的；你或许发现了额，我的偏见是非常喜欢Python —— 抱歉啦，但这就是我！我相信，听取其他人的想法也是非常有用的！特别是当你是“数据科学”、机器学习和编程领域的新手的时候。话虽如此，请继续，看看下面的那些带干货的评论！&lt;/p>
&lt;h3 id="python">Python&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的rm999:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>为了把我的数据管道（从数据源一直到生产模型和前端/可视化）弄到一块，大概一年前，我从大多使用R切换到大多使用Python。这对我能够做的事或者我当生产力并无实际影响，除了我在使用任何语言的前几年中需要对其进行额外的谷歌。我选择Python的主要原因是单纯的实用：这是一个我团队之外的人会尊重和使用的语言。这使得我更容易以许多不同的方法进行协作：与其他团队共享工具，转移代码的所有权，在我需要的时候获得帮助，等等等等。在一些公司，数据科学有“设计一些东西，然后将其抛出墙外让其他人处理”这种美誉。根据我的经验，R只是加深了这种美誉。这太糟糕了，它真的能把它所做的事情做得很好。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的DrNuke:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>我喜欢文章中的黑客方法：工具仅仅是做一些有价值的事情的工具，而不是目标本身。如今，因为数据科学爆炸以及快速与非专业人员进行交互的需要，所以，Python生态是正确的时候的正确的工具。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的zzleeper:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>非常有意思的文章。我觉得很多数值Pythonistas都处在相同的境地：他们容忍大多数语言，但发现R的语法有点不自然，当试图超越纯矩阵的东西时Matlab有所不足，并都在观望Julia是否会崛起 (在我看来，似乎是会的)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.reddit.com/r/MachineLearning/comments/3ibx9j/python_machine_learning_and_language_wars_a/">reddit&lt;/a>上的JanneJM:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>关键是有足够高品质的库。我知道的许多人，包括我，并不是真的对Python很感兴趣。我们使用Numpy, Scipy, Matplotlib, Pandas等等等等。Python只是来凑凑热闹。要是这些库出现在Ruby / Perl / Lua，那么它们就是我们今天会使用的语言。&lt;/p>
&lt;/blockquote>
&lt;h3 id="perl">Perl&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的leni536：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>“然而，我认为Perl在生物信息学领域还是相当常见的！？”这是事实 —— 许多生物信息学每天的任务都或多或少有纯文本分析[1]，而Perl在解析文本和快速使用正则表达式方面有过人之处。“我”这一代的生物信息学家(20–30)使用Python进行数据清理和分析，有时是因为绘图更好，语言更容易上手，它在高校中较为普遍，或者其他原因 —— 比我这一代年长的人们通常使用P&lt;/p>
&lt;/blockquote>
&lt;h3 id="r">R&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的geomark：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>我刚完成了Coursera数据科学之路，这让我从一个完全的R新手变得至少有点精通了。之前我用Python来进行相当多的web编程，起初，除了它统计编程的能力，我并不喜欢R。但最近，我发现了一些不错的R包，它们能让那些我通常会用Python做的事情用R来做变得愉悦。就像我最近发现的用于爬取网页的rvest包。用R进行数据可视化似乎优得多，除非我想念Python中的某些东西（极有可能）。并且提供一个漂亮的统计数据应用是很容易用shiny或者RStudio Presenter做到的。但R真的没法扩展到一个大型生产应用，不是吗？因此，我觉得我需要同时用Python 和R。新增：这是一个不错的列表。谢谢。另外，在文章中，他说Python语法感觉更自然，这也是我所觉得的。但后来我开始使用R中诸如magrittr和dplyr这种包，它们给你像管道一样不错的东西，因此那种感觉开始消退了。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的Adam_O&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>从一个学生的角度来看，大多数不错的在线分析/数据分析/统计课程都使用R，从医在学习材料的时候，很难摆脱它。一旦你获取了基础概念，那么转到Python应该不难。虽然，我想大多数的人仍然更喜欢用ggplot2进行可视化。每当我使用R的时候，我觉得自己像是一个统计学家，我可以感觉到从这门语言从散发出来的“冷严谨”。但最后，我觉得同时使用这两门语言是有利的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="matlab-octave">MATLAB/Octave&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的sampo&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Andrew Ng在Coursera的机器学习课上说，根据他的经验，用Octave/Matlab完成课程作业的学生比用Python完成的快。但是是的，课程的关键是实现和玩转小数值算法，而该博客是关于那些主要调用Python中已有的机器学习库的人。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的misiti3780&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Octave/Matlab是“不错”，但是尝试将其集成到一个生产web应用上还需要点好运气。既然你无法真正做到这点 —— 那么避免使用它们，除非你对实现相同的算法两次并无意见。Matlab license还要花钱买，而工具箱还需要花额外的钱。R是有用的，因为长时间以来它一直有很多资源，并且统计信息社区大部分都在使用它。它还有许多尚未移植到其他语言的有用的库 (ggmap!!!)。但你仍然还是要面对相同的问题，也就是说你没法将R集成到生产WEB应用上。我非常确定，Hadoop之流不支持R, Octave, 或者Matlab。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的thanatropism&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里少了一件事：Matlab的语法其实是非常接近现代Fortran的。我至少通过添加类型/常规的冗余/修改do-loops语法/等等重写Matlab代码，从而写了两次Fortran代码(用于蒙特卡罗模拟；不同的上下文)。&lt;/p>
&lt;/blockquote>
&lt;h3 id="julia">Julia&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的Lofkin:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>就个人而言，我尝试转到Julia，但速度缓慢的高阶函数，核心数据基础设施的高流失率，以及没有Pymc 3，这些都让我在pydata待了更长一点。我已经拴在numba上了。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的Buttons 840:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>我专业使用Python 8年了，这是我最喜欢的语言。我有点常使用numpy和scikit-learn。这么说，最近，我真的很享受学习Julia的过程。它简单易学，并且确实表现良好（读：很快）。事实上，我认为学习Julia将会和学习一些诸如numba一样有用，并且提供相似的（有人说会略胜一筹）性能。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的idunning:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>作为那种在日常工作（及编外项目）中几乎完全使用Julia的人中的一员，我认为作者对Julia的大部分想法都是正确的。我认为这个语言很棒，使用它让我的生活更美好。在我看来有一些包实际上比它们在其他语言中的等价物更好。另一方面，我对那些不完美的事物拥有更高的容忍度，我能自己理出头绪（幸运的是有时间这样做），并且如果不存在的话（在每一点上），我愿意为它编码。当然，对大多数的人来说，并不是这样的，但没关系。作者不愿意冒着Julia将会不“存在”的风险，这很公平。它肯定尚未完成，但它正在完成的路上。虽然，我有信心，它会存活下来（并且繁荣发展），并且继续增长不充实的社区。我有一种感觉，在一两年左右，最终，作者将找到他到Julia王国之路。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.reddit.com/r/Python/comments/3i8crj/python_machine_learning_and_language_wars_a/">reddit&lt;/a>上的niksko:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>我同意Julia主题。它潜力巨大，并且它基本上是专门为这些类型的应用准备的，但现在还没有社区和支持。我花了一个学期进行计算进化动力学领域的一个小的研究项目，而最繁琐最困难的部分是让Julia绘制我所想要的图。另外，那个时候，它还没有支持文档字符串 :/。它速度快，炫，但不够成熟。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.reddit.com/r/MachineLearning/comments/3ibx9j/python_machine_learning_and_language_wars_a/">reddit&lt;/a>上的KG7ULQ:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>在我学习Coursera上的Ng ML课程后，我看了看，似乎要做的事情就是使用Python……但必须学习几个大库，包括你提到的那些。然后我看到了Julia，觉得我还不如学习它，因为它已经内置了所有的线性代数和SIMD相关的东西，并且性能更好。它的确看起来像是ML的“最佳”语言。&lt;/p>
&lt;/blockquote>
&lt;h3 id="其他语言-我忘记提的那些">其他语言 (我忘记提的那些)&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://news.ycombinator.com/item?id=10113413">hackernews&lt;/a>上的leni536:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>C++并没有做错什么。对于线性代数，我使用armadillo库，它是LAPACK和BLAS一个非常棒的封装 (并且也快！)。出于某些原因，科学家有点怕C++。由于某些原因，你“不得不”在一个“更容易的”语言中进行原型。当然，你你能把C++当成计算器而不是解释语言，但我看到人们卡在原型语言的计算上，最终并没有把它带到一个更快的平台上。要点是：C++对于科学计算并不难。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.reddit.com/r/Python/comments/3i8crj/python_machine_learning_and_language_wars_a/">reddit&lt;/a>上的leni536:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>对我来说，如果有什么会替换掉Python，那么Scala应该是最可能的候选者。我认为，函数式语言很好的适用于数学工作，并且它在JVM上，因此原型可以变成生产代码，而不需太多开销就可以“到处”运行。Spark是Scala的杀手级应用。现在，我可以从原型到在任意大的数据集之上运行，并且之间不会有太多的障碍。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.reddit.com/r/Python/comments/3i8crj/python_machine_learning_and_language_wars_a/">reddit&lt;/a>上的rpcope1:&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>[Scala]在编译的时候可能是慢，但它比CPython更安全，并且快得多（除了使用非字节码的代码和调用C/Fortran库之外），并且还有一些我现在在Python中及其想念的概念，例如，Option[T]，隐式修改器，不废柴的map/reduce/filter，不废柴的lambda，等等。&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: 快速安装</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85/</guid><description>
&lt;p>不知道为什么openshift在国内热度这么低，那些要做自己容器云的公司，不知道有openshift项目的存在么？完全满足我的需求。&lt;/p>
&lt;p>docker负责应用的隔离打包，k8s提供集群管理和容器的编排服务，而openshfit则负责整个应用的生命周期：&lt;/p>
&lt;ul>
&lt;li>源码管理，CI&amp;amp;CD能力&lt;/li>
&lt;li>多租户管理, 支持LDAP和Oauth&lt;/li>
&lt;li>集成监控日志于web console&lt;/li>
&lt;/ul>
&lt;p>先说下自接触到openshift项目就遇到的一个困惑，就是openshift origin/enterprise /online/dedicated/ocp之间的关系： &lt;code>orgin相当于Fedora， 其他的相当于RHEL&lt;/code>&lt;/p>
&lt;p>接下来谈下我用自己的笔记本实践的过程与感受：&lt;/p>
&lt;ol>
&lt;li>快速安装&lt;/li>
&lt;/ol>
&lt;p>本人日常基于ubuntu16.04办公，所以用oc直接上, oc相当于kubectl&lt;/p>
&lt;p>&lt;a href="https://github.com/openshift/origin/releases">这里&lt;/a>直接下载oc客户端，或者自行编译, 编译结果在_output目录下&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone --depth=1 https://github.com/openshift/origin.git
cd origin &amp;amp;&amp;amp; make
mv _output/local/bin/linux/amd64/oc /usr/local/bin
&lt;/code>&lt;/pre>&lt;p>启动openshift, 默认开启监控并初始安装自最新版本，当前是v1.5.0-alpha.2&lt;/p>
&lt;pre tabindex="0">&lt;code>oc cluster up --metrics=true --version=latest --insecure-skip-tls-verify=true --public-hostname=air13
&lt;/code>&lt;/pre>&lt;p>过程中会拉取所需镜像, 我这里显示比较多，之前已经做了些实验&lt;/p>
&lt;pre tabindex="0">&lt;code>➜ ~ docker images | grep openshift | awk '{print $1}'
openshift/node
openshift/origin-sti-builder
openshift/origin-docker-builder
openshift/origin-deployer
openshift/origin-gitserver
openshift/origin-docker-registry
openshift/origin-haproxy-router
openshift/origin
openshift/hello-openshift
openshift/openvswitch
openshift/origin-pod
openshift/origin-metrics-cassandra
openshift/origin-metrics-hawkular-metrics
openshift/origin-metrics-heapster
openshift/origin-metrics-deployer
openshift/mysql-55-centos7
openshift/origin-logging-curator
openshift/origin-logging-fluentd
openshift/origin-logging-deployment
openshift/origin-logging-elasticsearch
openshift/origin-logging-kibana
openshift/origin-logging-auth-proxy
&lt;/code>&lt;/pre>&lt;p>启动后，会打印如下信息&lt;/p>
&lt;pre tabindex="0">&lt;code>OpenShift server started.
The server is accessible via web console at:
https://air13:8443
The metrics service is available at:
https://metrics-openshift-infra.192.168.31.49.xip.io
You are logged in as:
User: developer
Password: developer
To login as administrator:
oc login -u system:admin
&lt;/code>&lt;/pre>&lt;p>打开浏览器，访问https://air13:8443，默认用developer登录，其实现在任意用户任意密码都可以的。&lt;/p>
&lt;p>web console里是空空如野的，可以临时授权developer用户操作所有项目&lt;/p>
&lt;pre tabindex="0">&lt;code>oc adm policy add-cluster-role-to-user cluster-admin developer
&lt;/code>&lt;/pre>&lt;p>2.技巧总结&lt;/p>
&lt;ul>
&lt;li>命令行自动补全, 其实kubectl也可以如此&lt;/li>
&lt;/ul>
&lt;p>&lt;code>source &amp;lt;(oc completion bash)&lt;/code>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>默认监控占用的资源太大了，可以如下降低资源占用，当然也可以web操作限制资源利用率&lt;/p>
&lt;pre tabindex="0">&lt;code>oc env rc hawkular-cassandra-1 MAX_HEAP_SIZE=1024M -n openshift-infra
#重建下变量才会生效
oc scale rc hawkular-cassandra-1 --replicas 0 -n openshift-infra
oc scale rc hawkular-cassandra-1 --replicas 1 -n openshift-infra
&lt;/code>&lt;/pre>&lt;p>因为是rc，所以直接杀掉没关系，要不env不生效&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自己编译离线文档&lt;/p>
&lt;pre tabindex="0">&lt;code># 下载源文件
git clone --depth=1 https://github.com/openshift/openshift-docs.git
# 编译
cd openshift-docs &amp;amp;&amp;amp; asciibinder build
# 结果会存放在 _preview下，
cd _preview &amp;amp;&amp;amp; python -m SimpleHTTPServer
#打开浏览器访问127.0.0.1:8000
&lt;/code>&lt;/pre>&lt;p>推荐此人&lt;a href="http://guifreelife.com/">blog&lt;/a>，有几篇干货&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>3.后面会重点说下权限/资源管理和整个app开发的流程&lt;/p></description></item><item><title>Docs: 构建生产环境级的docker Swarm集群-1</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-swarm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-swarm/</guid><description>
&lt;p>此文档适用于低于1.12版本的docker，之后swarm已内置于docker-engine里。&lt;/p>
&lt;ol>
&lt;li>硬件需求&lt;/li>
&lt;/ol>
&lt;p>至少5台PC服务器, 分别如下作用&lt;/p>
&lt;ul>
&lt;li>manager0&lt;/li>
&lt;li>manager1&lt;/li>
&lt;li>consul0&lt;/li>
&lt;li>node0&lt;/li>
&lt;li>node1&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>每台PC上安装docker-engine&lt;/li>
&lt;/ol>
&lt;p>一台一台的ssh上去执行，或者使用ansible批量部署工具。&lt;/p>
&lt;p>安装docker-engine&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -sSL https://get.docker.com/ | sh
&lt;/code>&lt;/pre>&lt;p>启动之，并使之监听2375端口&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
&lt;/code>&lt;/pre>&lt;p>亦可修改配置，使之永久生效&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir /etc/systemd/system/docker.service.d
cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/systemd/system/docker.service.d/docker.conf
[Service]
ExecStart=
ExecStart=/usr/bin/docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --dns 180.76.76.76 --insecure-registry registry.cecf.com -g /home/Docker/docker
EOF
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>启动discovery后台&lt;/li>
&lt;/ol>
&lt;p>在consul0上启动consul服务，manager用其来认证node连接并存储node状态， 理应建立discovery的高可用，这里简化之&lt;/p>
&lt;pre tabindex="0">&lt;code>docker run -d -p 8500:8500 --name=consul progrium/consul -server -bootstrap
&lt;/code>&lt;/pre>&lt;ol start="4">
&lt;li>创建Swarm集群&lt;/li>
&lt;/ol>
&lt;p>在manager0上创建the primary manager， 自行替换manager0_ip和consul0_ip的真实IP地址。&lt;/p>
&lt;pre tabindex="0">&lt;code>docker run -d -p 4000:4000 swarm manage -H :4000 --replication --advertise &amp;lt;manager0_ip&amp;gt;:4000 consul://&amp;lt;consul0_ip&amp;gt;:8500
&lt;/code>&lt;/pre>&lt;p>在manager1上启动replica manger&lt;/p>
&lt;pre tabindex="0">&lt;code>docker run -d -p 4000:4000 swarm manage -H :4000 --replication --advertise &amp;lt;manager1_ip&amp;gt;:4000 consul://&amp;lt;consul0_ip&amp;gt;:8500
&lt;/code>&lt;/pre>&lt;p>--replication&lt;/p>
&lt;ol start="5">
&lt;li>在node上执行加入集群操作&lt;/li>
&lt;/ol>
&lt;p>分别在node0和node1上执行加入集群操作&lt;/p>
&lt;pre tabindex="0">&lt;code>docker run -d swarm join --advertise=&amp;lt;node_ip&amp;gt;:2375 consul://&amp;lt;consul0_ip&amp;gt;:8500
&lt;/code>&lt;/pre>&lt;ol start="6">
&lt;li>在manger0上查看集群状态&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker -H :4000 info
&lt;/code>&lt;/pre></description></item><item><title>Docs: 源码部署K8S</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2k8s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2k8s/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>此文应该不能运行成功了，，，陈年老文，有待验证。&lt;/p>
&lt;/div>
&lt;h4 id="一-先介绍最省事的部署方法-直接从官网下release版本安装">一. 先介绍最省事的部署方法，直接从官网下release版本安装:&lt;/h4>
&lt;p>git clone 代码步骤省略 ...&lt;/p>
&lt;ol>
&lt;li>下载各依赖的release版本&lt;/li>
&lt;/ol>
&lt;p>通过修改配置文件 &lt;strong>cluster/centos/config-build.sh&lt;/strong>， 可自定义（k8s, docker, flannel, etcd）各自的下载地址和版本， 不同的版本的依赖可能会需要小改下脚本（版本变更有些打包路径发生了变化，兼容性问题）&lt;/p>
&lt;pre tabindex="0">&lt;code>cd cluster/centos &amp;amp;&amp;amp; ./build.sh all
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>安装并启动k8s集群环境&lt;/li>
&lt;/ol>
&lt;p>通过修改配置文件 &lt;strong>cluster/centos/config-default.sh&lt;/strong>，定义你环境里的设备的IP和其他参数，推荐运行脚本前先通过ssh-copy-id做好免密钥认证；&lt;/p>
&lt;pre tabindex="0">&lt;code>export KUBERNETES_PROVIDER=centos &amp;amp;&amp;amp; cluster/kube-up.sh
&lt;/code>&lt;/pre>&lt;h4 id="二-源码级编译安装">二. 源码级编译安装&lt;/h4>
&lt;p>本步骤基于上一大步来说,
先来看下载各依赖的release后，cluster/centos下目录发生了什么变化&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/k8s-binaries-tree.png" alt="">&lt;/p>
&lt;p>多了一个binaries的目录，里面是各master和minion上各依赖的二进制文件， 所以我们只要源码编译的结果，替换到这里来， 然后继续上一大步的第2小步即可。&lt;/p>
&lt;p>这里说下，本地编译k8s的话，需要设置安装godep，然后命令本地化。&lt;/p>
&lt;pre tabindex="0">&lt;code>export PATH=$PATH:$GOPATH/bin
&lt;/code>&lt;/pre>&lt;p>最后只需要去源码根目录下执行， 编译结果在_output目录下&lt;/p>
&lt;pre tabindex="0">&lt;code>make
&lt;/code>&lt;/pre>&lt;p>替换到相应的binaries目录下，重新运行kube-up.sh即可。&lt;/p></description></item><item><title>Docs: 百宝箱脚本</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/%E7%99%BE%E5%AE%9D%E7%AE%B1%E8%84%9A%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/%E7%99%BE%E5%AE%9D%E7%AE%B1%E8%84%9A%E6%9C%AC/</guid><description>
&lt;ul>
&lt;li>备份所有docker镜像&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">mkdir -p images &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a2f">cd&lt;/span> images
&lt;span style="color:#a2f;font-weight:bold">for&lt;/span> image in &lt;span style="color:#b44">`&lt;/span>docker images | grep -v REPOSITORY | awk &lt;span style="color:#b44">&amp;#39;{print $1&amp;#34;:&amp;#34;$2}&amp;#39;&lt;/span>&lt;span style="color:#b44">`&lt;/span>; &lt;span style="color:#a2f;font-weight:bold">do&lt;/span>
&lt;span style="color:#a2f">echo&lt;/span> &lt;span style="color:#b44">&amp;#34;saving the image of &lt;/span>&lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">image&lt;/span>&lt;span style="color:#b68;font-weight:bold">}&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
docker save &lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">image&lt;/span>&lt;span style="color:#b68;font-weight:bold">}&lt;/span> &amp;gt; &lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">image&lt;/span>////-&lt;span style="color:#b68;font-weight:bold">}&lt;/span>.tar
&lt;span style="color:#a2f">echo&lt;/span> -e &lt;span style="color:#b44">&amp;#34;finished saving the image of \033[32m &lt;/span>&lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">image&lt;/span>&lt;span style="color:#b68;font-weight:bold">}&lt;/span>&lt;span style="color:#b44"> \033[0m&amp;#34;&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>批量加载本地tar镜像&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#a2f;font-weight:bold">for&lt;/span> image in &lt;span style="color:#b44">`&lt;/span>ls *.tar&lt;span style="color:#b44">`&lt;/span>; &lt;span style="color:#a2f;font-weight:bold">do&lt;/span>
&lt;span style="color:#a2f">echo&lt;/span> &lt;span style="color:#b44">&amp;#34;loading the image of &lt;/span>&lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">image&lt;/span>&lt;span style="color:#b68;font-weight:bold">}&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
docker load &amp;lt; &lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">image&lt;/span>&lt;span style="color:#b68;font-weight:bold">}&lt;/span>
&lt;span style="color:#a2f">echo&lt;/span> -e &lt;span style="color:#b44">&amp;#34;finished loading the image of \033[32m &lt;/span>&lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">image&lt;/span>&lt;span style="color:#b68;font-weight:bold">}&lt;/span>&lt;span style="color:#b44"> \033[0m&amp;#34;&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>批量杀死僵尸进程&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">ps -A -o stat,ppid,pid,cmd | grep -e &lt;span style="color:#b44">&amp;#39;^[Zz]&amp;#39;&lt;/span> | awk &lt;span style="color:#b44">&amp;#39;{print $2}&amp;#39;&lt;/span> | xargs &lt;span style="color:#a2f">kill&lt;/span> -9
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: 站点搭建方法</title><link>https://xiaoping378.github.io/docs/1-site/create_site/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/1-site/create_site/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>主要涉及到hugo和docsy主题的使用。&lt;/p>
&lt;/div>
&lt;h2 id="hugo介绍">hugo介绍&lt;/h2>
&lt;p>hugo是spf13的开源作品，目前任职于google，对他最早的印象是使用他的vim-spf13配置，后来又接触到他的cobra、plfag、viper... 为golang的生态完善做了很大贡献，致敬!&lt;/p>
&lt;p>书归正传，hugo是基于golang开发的世界上最快的网站构建框架，本文介绍如何基于它构建技术类文档库，也可作为内部wiki或开源书籍使用。之所以没选择gitbook，发现CLI版本已于2018年停止维护了。&lt;/p>
&lt;h2 id="准备环境">准备环境&lt;/h2>
&lt;p>安装git和hugo&lt;/p>
&lt;ul>
&lt;li>
&lt;p>具体过程此处不表。注意是安装hugo_extended的版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果要编译成html，部署到webserver上，还需要安装nodejs 12+。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="主题选择">主题选择&lt;/h2>
&lt;p>选用Docsy主题，出自google的开源主题，很多流行项目使用此主题作为官方站点，有k8s、kubeflow、grpc、etcd、Selenium等，详见此。主要功能包含：&lt;/p>
&lt;ul>
&lt;li>支持树形目录&lt;/li>
&lt;li>国际化&lt;/li>
&lt;li>搜索功能&lt;/li>
&lt;li>移动端自适应适配&lt;/li>
&lt;li>标签分类&lt;/li>
&lt;li>全站打印&lt;/li>
&lt;li>文档版本化&lt;/li>
&lt;li>用户反馈等&lt;/li>
&lt;/ul>
&lt;p>官方提供了快速上手的脚手架，具体操作如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/google/docsy-example.git
&lt;/code>&lt;/pre>&lt;/div>&lt;p>脚手架初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#a2f">cd&lt;/span> docsy-example &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> git submodule update --init --recursive
&lt;/code>&lt;/pre>&lt;/div>&lt;p>本地启动，默认可通过&lt;code>localhost:1313&lt;/code>访问，官方提供了在线的&lt;a href="https://example.docsy.dev/">预览地址&lt;/a>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">hugo server
&lt;/code>&lt;/pre>&lt;/div>&lt;p>​&lt;/p>
&lt;h2 id="目录结构说明">目录结构说明&lt;/h2>
&lt;p>默认脚手架目录结构如下，只关注&lt;code>config.toml&lt;/code>文件和&lt;code>content&lt;/code>目录，就可以满足日常使用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ docsy-example git:&lt;span style="color:#666">(&lt;/span>master&lt;span style="color:#666">)&lt;/span> tree -L &lt;span style="color:#666">1&lt;/span>
.
├── assets &lt;span style="color:#080;font-style:italic"># 静态资源&lt;/span>
├── config.toml &lt;span style="color:#080;font-style:italic"># 站点的配置文件：主题选择、名称、链接、页面分析、markdown解析引擎...&lt;/span>
├── content &lt;span style="color:#080;font-style:italic"># 站点内容：顶层导航，左侧树形章节&lt;/span>
├── CONTRIBUTING.md
├── deploy.sh
├── docker-compose.yaml
├── Dockerfile
├── layouts &lt;span style="color:#080;font-style:italic"># 可覆盖主题的默认布局，添加自定义页面布局&lt;/span>
├── LICENSE
├── netlify.toml
├── package.json
├── README.md
├── resources
└── themes &lt;span style="color:#080;font-style:italic"># Docsy主题的目录，hugo推荐的存放路径&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="重点说明">重点说明&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>修改主题的页面布局&lt;/p>
&lt;ul>
&lt;li>大部分内容可以通过修改根目录的config.toml的文件来实现&lt;/li>
&lt;li>不能通过上条实现的，也不建议直接修改themes目录下的内容，copy到在根目录同样的相对路径上再修改，会覆盖默认主题相关的实现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>docsy主题默认提供了3种版面布局, 分别在content目录下，写markdown文件，不同目录按照各自类型风格渲染。&lt;/p>
&lt;ul>
&lt;li>docs技术文档类的布局&lt;/li>
&lt;li>blog博客类的布局&lt;/li>
&lt;li>community社区相关介绍的布局&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>docs的目录章节可以任意分级，目录下的_index.md或者_index.html为该章、节的首页描述。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根目录运行如下命令可编译最终html，可能会提示&lt;code>POSTCSS&lt;/code>编译失败，需要根目录运行&lt;code>npm install&lt;/code>安装依赖。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">rm -rf public/ &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#b8860b">HUGO_ENV&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;production&amp;#34;&lt;/span> hugo --gc &lt;span style="color:#666">||&lt;/span> &lt;span style="color:#a2f">exit&lt;/span> &lt;span style="color:#666">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>站点内搜索功能依赖编译后的json文件，需要上一步才能使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于config.toml配置的解读（最新注释说明，可查看本站的&lt;a href="https://github.com/xiaoping378/xiaoping378.github.io/blob/master/config.toml">原件&lt;/a>）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml">&lt;span style="color:#080;font-style:italic"># 站点的访问地址，本地预览时(hugo server)可忽悠&lt;/span>
baseURL = &lt;span style="color:#b44">&amp;#34;https://xiaoping378.github.io&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 站点title,会被多语言里的设置覆盖&lt;/span>
&lt;span style="color:#080;font-style:italic"># title = &amp;#34;小平栈&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 是否生成robots文件&lt;/span>
enableRobotsTXT = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
&lt;span style="color:#080;font-style:italic"># 主题选择，支持组合，优先级从左到右.&lt;/span>
theme = [&lt;span style="color:#b44">&amp;#34;docsy&amp;#34;&lt;/span>]
&lt;span style="color:#080;font-style:italic"># 页面上提供类似&amp;#34;最后修改&amp;#34;的信息&lt;/span>
enableGitInfo = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
&lt;span style="color:#080;font-style:italic"># 国际化相关设置&lt;/span>
&lt;span style="color:#080;font-style:italic"># 默认语言的的站点内容路径&lt;/span>
contentDir = &lt;span style="color:#b44">&amp;#34;content&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 默认语言&lt;/span>
defaultContentLanguage = &lt;span style="color:#b44">&amp;#34;zh-cn&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 国际化翻译中，如果有缺失是否用占位符显示&lt;/span>
enableMissingTranslationPlaceholders = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
&lt;span style="color:#080;font-style:italic"># 注释后，可以开启标签分类功能&lt;/span>
&lt;span style="color:#080;font-style:italic"># disableKinds = [&amp;#34;taxonomy&amp;#34;, &amp;#34;taxonomyTerm&amp;#34;]&lt;/span>
[params.taxonomy]
&lt;span style="color:#080;font-style:italic"># set taxonomyCloud = [] to hide taxonomy clouds&lt;/span>
taxonomyCloud = [&lt;span style="color:#b44">&amp;#34;tags&amp;#34;&lt;/span>]
&lt;span style="color:#080;font-style:italic"># If used, must have same lang as taxonomyCloud&lt;/span>
taxonomyCloudTitle = [&lt;span style="color:#b44">&amp;#34;标签&amp;#34;&lt;/span>]
&lt;span style="color:#080;font-style:italic"># set taxonomyPageHeader = [] to hide taxonomies on the page headers&lt;/span>
taxonomyPageHeader = [&lt;span style="color:#b44">&amp;#34;tags&amp;#34;&lt;/span>]
&lt;span style="color:#080;font-style:italic"># 代码块高亮配置&lt;/span>
pygmentsCodeFences = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
pygmentsUseClasses = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># Use the new Chroma Go highlighter in Hugo.&lt;/span>
pygmentsUseClassic = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic">#pygmentsOptions = &amp;#34;linenos=table&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># See https://help.farbox.com/pygments.html&lt;/span>
pygmentsStyle = &lt;span style="color:#b44">&amp;#34;emacs&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 配置blog编译产物的路径.&lt;/span>
[permalinks]
blog = &lt;span style="color:#b44">&amp;#34;/:section/:year/:month/:day/:slug/&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># markdown渲染引擎配置: https://github.com/russross/blackfriday&lt;/span>
&lt;span style="color:#080;font-style:italic"># [blackfriday]&lt;/span>
&lt;span style="color:#080;font-style:italic"># plainIDAnchors = true&lt;/span>
&lt;span style="color:#080;font-style:italic"># hrefTargetBlank = true&lt;/span>
&lt;span style="color:#080;font-style:italic"># angledQuotes = false&lt;/span>
&lt;span style="color:#080;font-style:italic"># latexDashes = true&lt;/span>
&lt;span style="color:#080;font-style:italic"># 图片引擎处理: https://github.com/disintegration/imaging&lt;/span>
[imaging]
resampleFilter = &lt;span style="color:#b44">&amp;#34;CatmullRom&amp;#34;&lt;/span>
quality = &lt;span style="color:#666">75&lt;/span>
anchor = &lt;span style="color:#b44">&amp;#34;smart&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># [services]&lt;/span>
&lt;span style="color:#080;font-style:italic"># [services.googleAnalytics]&lt;/span>
&lt;span style="color:#080;font-style:italic"># # Comment out the next line to disable GA tracking. Also disables the feature described in [params.ui.feedback].&lt;/span>
&lt;span style="color:#080;font-style:italic"># id = &amp;#34;UA-00000000-0&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># Language configuration&lt;/span>
[languages]
[languages.zh-cn]
title = &lt;span style="color:#b44">&amp;#34;现代技能栈&amp;#34;&lt;/span>
description = &lt;span style="color:#b44">&amp;#34;小平-所思所为&amp;#34;&lt;/span>
languageName = &lt;span style="color:#b44">&amp;#34;中文&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 用于多语言排序，越小越靠上。&lt;/span>
weight = &lt;span style="color:#666">1&lt;/span>
&lt;span style="color:#080;font-style:italic"># markdown的解析设置，抄的k8s 文档设置...&lt;/span>
[markup]
[markup.goldmark]
[markup.goldmark.extensions]
definitionList = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
table = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
typographer = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
[markup.goldmark.parser]
attribute = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
autoHeadingID = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
autoHeadingIDType = &lt;span style="color:#b44">&amp;#34;blackfriday&amp;#34;&lt;/span>
[markup.goldmark.renderer]
unsafe = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
[markup.highlight]
codeFences = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
guessSyntax = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
hl_Lines = &lt;span style="color:#b44">&amp;#34;&amp;#34;&lt;/span>
lineNoStart = &lt;span style="color:#666">1&lt;/span>
lineNos = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
lineNumbersInTable = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
noClasses = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
style = &lt;span style="color:#b44">&amp;#34;emacs&amp;#34;&lt;/span>
tabWidth = &lt;span style="color:#666">4&lt;/span>
[markup.tableOfContents]
endLevel = &lt;span style="color:#666">3&lt;/span>
ordered = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
startLevel = &lt;span style="color:#666">2&lt;/span>
&lt;span style="color:#080;font-style:italic"># Everything below this are Site Params&lt;/span>
&lt;span style="color:#080;font-style:italic"># Comment out if you don&amp;#39;t want the &amp;#34;print entire section&amp;#34; link enabled.&lt;/span>
[outputs]
section = [&lt;span style="color:#b44">&amp;#34;HTML&amp;#34;&lt;/span>, &lt;span style="color:#b44">&amp;#34;print&amp;#34;&lt;/span>, &lt;span style="color:#b44">&amp;#34;RSS&amp;#34;&lt;/span>]
[params]
copyright = &lt;span style="color:#b44">&amp;#34;xiaoping378&amp;#34;&lt;/span>
privacy_policy = &lt;span style="color:#b44">&amp;#34;#&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># First one is picked as the Twitter card image if not set on page.&lt;/span>
&lt;span style="color:#080;font-style:italic"># images = [&amp;#34;images/project-illustration.png&amp;#34;]&lt;/span>
&lt;span style="color:#080;font-style:italic"># Menu title if your navbar has a versions selector to access old versions of your site.&lt;/span>
&lt;span style="color:#080;font-style:italic"># This menu appears only if you have at least one [params.versions] set.&lt;/span>
version_menu = &lt;span style="color:#b44">&amp;#34;Releases&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># Flag used in the &amp;#34;version-banner&amp;#34; partial to decide whether to display a &lt;/span>
&lt;span style="color:#080;font-style:italic"># banner on every page indicating that this is an archived version of the docs.&lt;/span>
&lt;span style="color:#080;font-style:italic"># Set this flag to &amp;#34;true&amp;#34; if you want to display the banner.&lt;/span>
archived_version = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># The version number for the version of the docs represented in this doc set.&lt;/span>
&lt;span style="color:#080;font-style:italic"># Used in the &amp;#34;version-banner&amp;#34; partial to display a version number for the &lt;/span>
&lt;span style="color:#080;font-style:italic"># current doc set.&lt;/span>
version = &lt;span style="color:#b44">&amp;#34;0.0&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># A link to latest version of the docs. Used in the &amp;#34;version-banner&amp;#34; partial to&lt;/span>
&lt;span style="color:#080;font-style:italic"># point people to the main doc site.&lt;/span>
&lt;span style="color:#080;font-style:italic"># url_latest_version = &amp;#34;https://example.com&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 方便用户反馈，提交技术文章问题的仓库地址&lt;/span>
github_repo = &lt;span style="color:#b44">&amp;#34;https://github.com/xiaoping378/xiaoping378.github.io&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 技术站点背后的项目issue地址&lt;/span>
&lt;span style="color:#080;font-style:italic"># github_project_repo = &amp;#34;https://github.com/xiaoping378/xiaoping378.github.io&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 以下三个是设置远程文档位置的，目前用不上，这里hack一下，不然“编辑此页”的功能会去链接到content/zh-cn下&lt;/span>
&lt;span style="color:#080;font-style:italic"># Specify a value here if your content directory is not in your repo&amp;#39;s root directory&lt;/span>
github_subdir = &lt;span style="color:#b44">&amp;#34;/&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># Uncomment this if you have a newer GitHub repo with &amp;#34;main&amp;#34; as the default branch,&lt;/span>
&lt;span style="color:#080;font-style:italic"># or specify a new value if you want to reference another branch in your GitHub links&lt;/span>
&lt;span style="color:#080;font-style:italic"># github_branch= &amp;#34;main&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 支持三种搜索，三选一，禁用google搜索，需要注释掉此处&lt;/span>
&lt;span style="color:#080;font-style:italic"># gcs_engine_id = &amp;#34;d72aa9b2712488cc3&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># Enable Algolia DocSearch&lt;/span>
algolia_docsearch = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># Enable Lunr.js offline search&lt;/span>
offlineSearch = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># 默认使用的Chroma代码高亮方案，可换成prism方案。&lt;/span>
prism_syntax_highlighting = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># User interface configuration&lt;/span>
[params.ui]
&lt;span style="color:#080;font-style:italic"># 是否禁用面包屑导航.&lt;/span>
breadcrumb_disable = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># 是否禁用底部About链接&lt;/span>
footer_about_disable = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
&lt;span style="color:#080;font-style:italic"># 是否展示项目logo，位置必须放置在 assets/icons/logo.svg&lt;/span>
navbar_logo = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
&lt;span style="color:#080;font-style:italic"># 在首页，上下滑动页面，顶部导航是否禁用半透明&lt;/span>
navbar_translucent_over_cover_disable = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># 左侧章节树形目录默认是否处于折叠状态&lt;/span>
sidebar_menu_compact = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
&lt;span style="color:#080;font-style:italic"># 左侧章节树形目录上是否不显示搜索框，前提是需要开启搜索功能&lt;/span>
sidebar_search_disable = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># 关闭了google分析，下面功能不会启用&lt;/span>
[params.ui.feedback]
enable = &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>
&lt;span style="color:#080;font-style:italic"># The responses that the user sees after clicking &amp;#34;yes&amp;#34; (the page was helpful) or &amp;#34;no&amp;#34; (the page was not helpful).&lt;/span>
yes = &lt;span style="color:#b44">&amp;#39;Glad to hear it! Please &amp;lt;a href=&amp;#34;https://github.com/USERNAME/REPOSITORY/issues/new&amp;#34;&amp;gt;tell us how we can improve&amp;lt;/a&amp;gt;.&amp;#39;&lt;/span>
no = &lt;span style="color:#b44">&amp;#39;Sorry to hear that. Please &amp;lt;a href=&amp;#34;https://github.com/USERNAME/REPOSITORY/issues/new&amp;#34;&amp;gt;tell us how we can improve&amp;lt;/a&amp;gt;.&amp;#39;&lt;/span>
&lt;span style="color:#080;font-style:italic"># 在文章上面显示“阅读时长：x分钟”&lt;/span>
[params.ui.readingtime]
enable = &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>
&lt;span style="color:#080;font-style:italic"># 社区community版面要用到的参数&lt;/span>
[params.links]
&lt;span style="color:#080;font-style:italic"># End user relevant links. These will show up on left side of footer and in the community page if you have one.&lt;/span>
[[params.links.user]]
name = &lt;span style="color:#b44">&amp;#34;个人邮箱 xiaoping378@163.com&amp;#34;&lt;/span>
url = &lt;span style="color:#b44">&amp;#34;mailto:xiaoping378@163.com&amp;#34;&lt;/span>
icon = &lt;span style="color:#b44">&amp;#34;fa fa-envelope&amp;#34;&lt;/span>
desc = &lt;span style="color:#b44">&amp;#34;欢迎邮件交流&amp;#34;&lt;/span>
[[params.links.user]]
name =&lt;span style="color:#b44">&amp;#34;微博&amp;#34;&lt;/span>
url = &lt;span style="color:#b44">&amp;#34;https://weibo.com/xiaoping378&amp;#34;&lt;/span>
icon = &lt;span style="color:#b44">&amp;#34;fab fa-weibo&amp;#34;&lt;/span>
desc = &lt;span style="color:#b44">&amp;#34;个人微博，基本不用&amp;#34;&lt;/span>
[[params.links.user]]
name = &lt;span style="color:#b44">&amp;#34;知乎&amp;#34;&lt;/span>
url = &lt;span style="color:#b44">&amp;#34;https://www.zhihu.com/people/xiaoping378&amp;#34;&lt;/span>
icon = &lt;span style="color:#b44">&amp;#34;fab fa-zhihu&amp;#34;&lt;/span>
desc = &lt;span style="color:#b44">&amp;#34;知乎专栏&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># Developer relevant links. These will show up on right side of footer and in the community page if you have one.&lt;/span>
[[params.links.developer]]
name = &lt;span style="color:#b44">&amp;#34;GitHub&amp;#34;&lt;/span>
url = &lt;span style="color:#b44">&amp;#34;https://github.com/xiaoping378/xiaoping378.github.io&amp;#34;&lt;/span>
icon = &lt;span style="color:#b44">&amp;#34;fab fa-github&amp;#34;&lt;/span>
desc = &lt;span style="color:#b44">&amp;#34;文集开源地址!&amp;#34;&lt;/span>
[[params.links.developer]]
name = &lt;span style="color:#b44">&amp;#34;Slack&amp;#34;&lt;/span>
url = &lt;span style="color:#b44">&amp;#34;https://example.org/slack&amp;#34;&lt;/span>
icon = &lt;span style="color:#b44">&amp;#34;fab fa-slack&amp;#34;&lt;/span>
desc = &lt;span style="color:#b44">&amp;#34;未开通&amp;#34;&lt;/span>
[[params.links.developer]]
name = &lt;span style="color:#b44">&amp;#34;Developer mailing list&amp;#34;&lt;/span>
url = &lt;span style="color:#b44">&amp;#34;https://example.org/mail&amp;#34;&lt;/span>
icon = &lt;span style="color:#b44">&amp;#34;fa fa-envelope&amp;#34;&lt;/span>
desc = &lt;span style="color:#b44">&amp;#34;未开通&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>不定期更新此文，待进一步优化，，，&lt;/p>
&lt;p>如果自己搭建嫌麻烦，可直接Copy本站，编写自己的内容即可，搭建本站时，也遇到了Docsy国际化方面的问题，已提交官方&lt;a href="https://github.com/google/docsy/pull/826">PR&lt;/a>修复。&lt;/p>
&lt;p>&lt;a href="../actions_pages">下文&lt;/a>介绍使用github的actions和pages自动托管站点。&lt;/p></description></item><item><title>Docs: 搭建以太坊私链网络</title><link>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;p>大量过时文章充斥于网络，本文基于官方go-tehereum 1.6.7版本整理而出，在geth1.6之后引入了一个&lt;strong>puppeth&lt;/strong>工具，它就是用来初始一个私链创世块配置的。&lt;/p>
&lt;h3 id="准备工具环境">准备工具环境&lt;/h3>
&lt;p>下载&lt;code>go-ethereum代码&lt;/code>（go的开发环境准备，不在此文范围）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 下载源码&lt;/span>
go get github.com/ethereum/go-ethereum
&lt;span style="color:#a2f">cd&lt;/span> &lt;span style="color:#b8860b">$GOPATH&lt;/span>/src/github.com/ethereum/go-ethereum
&lt;span style="color:#080;font-style:italic"># 编译1.6.7版本的代码&lt;/span>
git checkout -b v1.6.7 v1.6.7
make all
&lt;span style="color:#080;font-style:italic"># 安装&lt;/span>
sudo ln -s &lt;span style="color:#b8860b">$PWD&lt;/span>/build/bin/* /usr/local/bin/
&lt;span style="color:#080;font-style:italic"># 检查是否安装OK&lt;/span>
geth version
Geth
Version: 1.6.7-stable
Git Commit: ab5646c532292b51e319f290afccf6a44f874372
Architecture: amd64
Protocol Versions: &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#666">63&lt;/span> 62&lt;span style="color:#666">]&lt;/span>
Network Id: &lt;span style="color:#666">1&lt;/span>
Go Version: go1.8.3
Operating System: linux
&lt;span style="color:#b8860b">GOPATH&lt;/span>&lt;span style="color:#666">=&lt;/span>/home/xxp/go
&lt;span style="color:#b8860b">GOROOT&lt;/span>&lt;span style="color:#666">=&lt;/span>/home/xxp/Software/go
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="生成私链创世块的配置">生成私链创世块的配置&lt;/h3>
&lt;ol>
&lt;li>创建账户&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 创建testnet目录&lt;/span>
➜ mkdir testnet &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a2f">cd&lt;/span> testnet
&lt;span style="color:#080;font-style:italic"># 创建3个普通账户，密码自定&lt;/span>
➜ geth --datadir node0 account new
&lt;span style="color:#080;font-style:italic"># 把密码记录到文件里，后面会频繁输入&lt;/span>
➜ &lt;span style="color:#a2f">echo&lt;/span> node0 &amp;gt; node0/password
➜ geth --datadir node1 account new
➜ &lt;span style="color:#a2f">echo&lt;/span> node1 &amp;gt; node1/password
➜ geth --datadir node2 account new
➜ &lt;span style="color:#a2f">echo&lt;/span> node2 &amp;gt; node2/password
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上打印的一串16进制的字符串就代表账户的userID（理解成网络中的IP地址），后面puppeth需要用到。&lt;/p>
&lt;ol start="2">
&lt;li>生成genesis文件&lt;/li>
&lt;/ol>
&lt;p>genesis文件定义了私链的第一个块生成，直接看操作吧(省略了些输出)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ testnet puppeth
Please specify a network name to administer &lt;span style="color:#666">(&lt;/span>no spaces, please&lt;span style="color:#666">)&lt;/span>
&amp;gt; testnet
Sweet, you can &lt;span style="color:#a2f">set&lt;/span> this via --network&lt;span style="color:#666">=&lt;/span>testnet next time!
INFO &lt;span style="color:#666">[&lt;/span>08-21|23:04:14&lt;span style="color:#666">]&lt;/span> Administering Ethereum network &lt;span style="color:#b8860b">name&lt;/span>&lt;span style="color:#666">=&lt;/span>testnet
WARN &lt;span style="color:#666">[&lt;/span>08-21|23:04:14&lt;span style="color:#666">]&lt;/span> No previous configurations found &lt;span style="color:#b8860b">path&lt;/span>&lt;span style="color:#666">=&lt;/span>/home/xxp/.puppeth/testnet
What would you like to &lt;span style="color:#a2f;font-weight:bold">do&lt;/span>? &lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b8860b">default&lt;/span> &lt;span style="color:#666">=&lt;/span> stats&lt;span style="color:#666">)&lt;/span>
1. Show network stats
2. Configure new genesis
3. Track new remote server
4. Deploy network components
&amp;gt; &lt;span style="color:#666">2&lt;/span>
Which consensus engine to use? &lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b8860b">default&lt;/span> &lt;span style="color:#666">=&lt;/span> clique&lt;span style="color:#666">)&lt;/span>
1. Ethash - proof-of-work
2. Clique - proof-of-authority
&amp;gt; &lt;span style="color:#666">2&lt;/span>
&lt;span style="color:#080;font-style:italic"># 设置5秒出一个块&lt;/span>
How many seconds should blocks take? &lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b8860b">default&lt;/span> &lt;span style="color:#666">=&lt;/span> 15&lt;span style="color:#666">)&lt;/span>
&amp;gt; &lt;span style="color:#666">5&lt;/span>
&lt;span style="color:#080;font-style:italic"># 输入有签名权限的账户&lt;/span>
Which accounts are allowed to seal? &lt;span style="color:#666">(&lt;/span>mandatory at least one&lt;span style="color:#666">)&lt;/span>
&amp;gt; 0x799a8f7796d1d20b8198a587caaf545cdde5de13
&amp;gt; 0x1458eac314d8fc922029095fae20483f55726017
&amp;gt; 0x3ca60eb49314d867ab75a3c7b3a5aa61c3d6ef71
&amp;gt; 0x
&lt;span style="color:#080;font-style:italic"># 输入有预留余额的账户&lt;/span>
Which accounts should be pre-funded? &lt;span style="color:#666">(&lt;/span>advisable at least one&lt;span style="color:#666">)&lt;/span>
&amp;gt; 0x799a8f7796d1d20b8198a587caaf545cdde5de13
&amp;gt; 0x1458eac314d8fc922029095fae20483f55726017
&amp;gt; 0x3ca60eb49314d867ab75a3c7b3a5aa61c3d6ef71
&amp;gt; 0x
Specify your chain/network ID &lt;span style="color:#a2f;font-weight:bold">if&lt;/span> you want an explicit one &lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b8860b">default&lt;/span> &lt;span style="color:#666">=&lt;/span> random&lt;span style="color:#666">)&lt;/span>
&amp;gt; &lt;span style="color:#666">378&lt;/span>
Anything fun to embed into the genesis block? &lt;span style="color:#666">(&lt;/span>max &lt;span style="color:#666">32&lt;/span> bytes&lt;span style="color:#666">)&lt;/span>
&amp;gt;
What would you like to &lt;span style="color:#a2f;font-weight:bold">do&lt;/span>? &lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b8860b">default&lt;/span> &lt;span style="color:#666">=&lt;/span> stats&lt;span style="color:#666">)&lt;/span>
1. Show network stats
2. Save existing genesis
3. Track new remote server
4. Deploy network components
&amp;gt; &lt;span style="color:#666">2&lt;/span>
Which file to save the genesis into? &lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b8860b">default&lt;/span> &lt;span style="color:#666">=&lt;/span> testnet.json&lt;span style="color:#666">)&lt;/span>
&amp;gt; genesis.json
INFO &lt;span style="color:#666">[&lt;/span>08-21|23:05:36&lt;span style="color:#666">]&lt;/span> Exported existing genesis block
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后会在当前目录生成genesis.json文件。&lt;/p>
&lt;h3 id="启动私链网络">启动私链网络&lt;/h3>
&lt;p>这里通过单机不同端口模拟多节点，&lt;/p>
&lt;ul>
&lt;li>默认geth一启动就会发出discovery，以发现其他节点，源码里内置了几个初始节点，可以通过--bootnode参数重置。如果真要不同节点互组网络的话，还需要主要时间同步，&lt;/li>
&lt;li>还可以通过--nodiscover参数，停掉自动发现，并利用admin.addPeer()或者static-node功能组成网络。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 启动节点0, 关闭自动发现（防止不希望的节点进入）&lt;/span>
geth --datadir node0 init genesis.json
geth --datadir node0 --port &lt;span style="color:#666">30000&lt;/span> --nodiscover --unlock &lt;span style="color:#b44">&amp;#39;0&amp;#39;&lt;/span> --password ./node0/password console
&lt;span style="color:#080;font-style:italic"># 不加console的话，可以通过geth attach ipc:node0/geth.ipc来访问&lt;/span>
&lt;span style="color:#080;font-style:italic"># 启动节点1，另起一个终端，通过不同端口模拟&lt;/span>
geth --datadir node1 init genesis.json
geth --datadir node1 --port &lt;span style="color:#666">30001&lt;/span> --nodiscover --unlock &lt;span style="color:#b44">&amp;#39;0&amp;#39;&lt;/span> --password ./node1/password console
&lt;span style="color:#080;font-style:italic"># 启动节点2，genesis.json里已经指定networkID,启动时无需指定了&lt;/span>
geth --datadir node2 init genesis.json
geth --datadir node2 --port &lt;span style="color:#666">30002&lt;/span> --nodiscover --unlock &lt;span style="color:#b44">&amp;#39;0&amp;#39;&lt;/span> --password ./node2/password console
&lt;/code>&lt;/pre>&lt;/div>&lt;p>目前启动了三个节点，但都默认关闭了发现功能，需要手动添加peer节点。&lt;/p>
&lt;p>在每个console输入&lt;code>admin.nodeInfo.enode&lt;/code>， 把输出记录下来到&lt;code>static-nodes.json&lt;/code>文件，我这里情况如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ testnet cat node0/static-nodes.json
&lt;span style="color:#666">[&lt;/span>
&lt;span style="color:#b44">&amp;#34;enode://2ffb53ede7de8dabf8f12343a7b2aba6b09263a53d8db5b4669309c5913f72969ce469cf09299f13e9d6cba8a98e18ad43811439326d7152f21d2e03ddc6be17@[::]:30000?discport=0&amp;#34;&lt;/span>,
&lt;span style="color:#b44">&amp;#34;enode://910d1bfcd763bb5157bc62f8b121eb21fb305d17e4e4437c0b094d3d6f2d72f1964b80eb8fa2cf6cd7d4cc2d44cfc1ed9b74275ea7fd42ab89b4d089023fb7d5@[::]:30001?discport=0&amp;#34;&lt;/span>,
&lt;span style="color:#b44">&amp;#34;enode://acab97a2a287b740b5efc3af465ba7330b3d4948b05e26818822d1aee659ec1b8f54ee9501576dc08ea4021d7ede01431691a27310a7dcbda2437bcd3b9c451d@[::]:30002?discport=0&amp;#34;&lt;/span>
&lt;span style="color:#666">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>把static-nodes.json文件放入各自(node0/,node1/, node2/)的&lt;code>admin.datadir&lt;/code>目录下，并&lt;code>Ctrl+D&lt;/code>终止掉console，并重新执行&lt;code>geth --datadir &amp;lt;dir&amp;gt; --prot &amp;lt;port&amp;gt; --nodiscover console&lt;/code>，如果觉得这样麻烦的话，或者以后动态添加节点时候，可考虑在每个节点的console里输入&lt;code>admin.addPeer(&amp;quot;nodeInfo_encode&amp;quot;)&lt;/code>来完成。&lt;/p>
&lt;p>然后在console中可以如下验证，是否互相发现组成以太坊私链网络了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 这样可看到其他节点的明细&lt;/span>
&amp;gt; admin.peers
&lt;span style="color:#666">[{&lt;/span>
caps: &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#b44">&amp;#34;eth/63&amp;#34;&lt;/span>&lt;span style="color:#666">]&lt;/span>,
id: &lt;span style="color:#b44">&amp;#34;910d1bfcd763bb5157bc62f8b121eb21fb305d17e4e4437c0b094d3d6f2d72f1964b80eb8fa2cf6cd7d4cc2d44cfc1ed9b74275ea7fd42ab89b4d089023fb7d5&amp;#34;&lt;/span>,
name: &lt;span style="color:#b44">&amp;#34;Geth/v1.6.7-stable-ab5646c5/linux-amd64/go1.8.3&amp;#34;&lt;/span>,
network: &lt;span style="color:#666">{&lt;/span>
localAddress: &lt;span style="color:#b44">&amp;#34;[::1]:43928&amp;#34;&lt;/span>,
remoteAddress: &lt;span style="color:#b44">&amp;#34;[::1]:30001&amp;#34;&lt;/span>
&lt;span style="color:#666">}&lt;/span>,
protocols: &lt;span style="color:#666">{&lt;/span>
eth: &lt;span style="color:#666">{&lt;/span>
difficulty: 1,
head: &lt;span style="color:#b44">&amp;#34;0xa43519868915a64d3798abf1867b7bc769d1239442c69ff1eca8e3dfcd13209b&amp;#34;&lt;/span>,
version: &lt;span style="color:#666">63&lt;/span>
&lt;span style="color:#666">}&lt;/span>
&lt;span style="color:#666">}&lt;/span>
&lt;span style="color:#666">}&lt;/span>, &lt;span style="color:#666">{&lt;/span>
caps: &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#b44">&amp;#34;eth/63&amp;#34;&lt;/span>&lt;span style="color:#666">]&lt;/span>,
id: &lt;span style="color:#b44">&amp;#34;acab97a2a287b740b5efc3af465ba7330b3d4948b05e26818822d1aee659ec1b8f54ee9501576dc08ea4021d7ede01431691a27310a7dcbda2437bcd3b9c451d&amp;#34;&lt;/span>,
name: &lt;span style="color:#b44">&amp;#34;Geth/v1.6.7-stable-ab5646c5/linux-amd64/go1.8.3&amp;#34;&lt;/span>,
network: &lt;span style="color:#666">{&lt;/span>
localAddress: &lt;span style="color:#b44">&amp;#34;[::1]:60310&amp;#34;&lt;/span>,
remoteAddress: &lt;span style="color:#b44">&amp;#34;[::1]:30002&amp;#34;&lt;/span>
&lt;span style="color:#666">}&lt;/span>,
protocols: &lt;span style="color:#666">{&lt;/span>
eth: &lt;span style="color:#666">{&lt;/span>
difficulty: 1,
head: &lt;span style="color:#b44">&amp;#34;0xa43519868915a64d3798abf1867b7bc769d1239442c69ff1eca8e3dfcd13209b&amp;#34;&lt;/span>,
version: &lt;span style="color:#666">63&lt;/span>
&lt;span style="color:#666">}&lt;/span>
&lt;span style="color:#666">}&lt;/span>
&lt;span style="color:#666">}]&lt;/span>
&amp;gt;
&lt;span style="color:#080;font-style:italic"># 可看到此节点发现了另外两个节点&lt;/span>
&amp;gt; net.peerCount
&lt;span style="color:#666">2&lt;/span>
&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>目前整个testnet的目录结构如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ tree
.
├── genesis.json
├── node0
│   ├── geth
│   │   ├── chaindata
│   │   │   ├── 000002.ldb
| | | ├── ...
│   │   ├── lightchaindata
│   │   │   ├── 000001.log
│   │   │   ├── ...
│   │   ├── LOCK
│   │   └── nodekey
│   ├── geth.ipc
│   ├── &lt;span style="color:#a2f">history&lt;/span>
│   ├── keystore
│   │   └── UTC--2017-08-21T15-03-25.499242705Z--799a8f7796d1d20b8198a587caaf545cdde5de13
│   └── static-nodes.json
├── node1
│   ├── geth
│   │   ├── chaindata
│   │   │   ├── 000002.ldb
│   │   │   ├── ...
│   │   │   └── MANIFEST-000007
│   │   ├── lightchaindata
│   │   │   ├── ...
│   │   │   └── MANIFEST-000000
│   │   ├── LOCK
│   │   └── nodekey
│   ├── geth.ipc
│   ├── &lt;span style="color:#a2f">history&lt;/span>
│   ├── keystore
│   │   └── UTC--2017-08-21T15-03-35.020270645Z--1458eac314d8fc922029095fae20483f55726017
│   └── static-nodes.json
└── node2
├── geth
│   ├── chaindata
│   │   ├── 000002.ldb
│   │   ├── ...
│   │   └── MANIFEST-000007
│   ├── lightchaindata
│   │   ├── ...
│   │   └── MANIFEST-000000
│   ├── LOCK
│   └── nodekey
├── geth.ipc
├── &lt;span style="color:#a2f">history&lt;/span>
├── keystore
│   └── UTC--2017-08-21T15-03-46.899273318Z--3ca60eb49314d867ab75a3c7b3a5aa61c3d6ef71
└── static-nodes.json
&lt;span style="color:#666">15&lt;/span> directories, &lt;span style="color:#666">56&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开始挖矿">开始挖矿&lt;/h3>
&lt;p>在每个节点的console输入如下，启动挖矿（共识记账）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 这一步可以不需要，因为我们geth启动的时候，已经传入unlock参数了，因为console里执行unlock是有过期时间机制的，私网直接来。。。。&lt;/span>
&amp;gt; personal.unlockAccount&lt;span style="color:#666">(&lt;/span>eth.coinbase&lt;span style="color:#666">)&lt;/span>
Unlock account 0x799a8f7796d1d20b8198a587caaf545cdde5de13
Passphrase:
&lt;span style="color:#a2f">true&lt;/span>
&amp;gt;
&lt;span style="color:#080;font-style:italic"># 这一个很重要，为后面的eth设置了默认账户&lt;/span>
&amp;gt; eth.defaultAccount &lt;span style="color:#666">=&lt;/span> eth.coinbase
&lt;span style="color:#b44">&amp;#34;0x799a8f7796d1d20b8198a587caaf545cdde5de13&amp;#34;&lt;/span>
&amp;gt;
&amp;gt; miner.start&lt;span style="color:#666">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="通过钱包交易">通过钱包交易&lt;/h3>
&lt;p>通过&lt;a href="https://github.com/ethereum/mist/releases">mist&lt;/a>钱包界面，来查看基本信息和进行交易，不过之前需要在console开启RPC，　node0的console里如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&amp;gt; admin.startRPC&lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b44">&amp;#34;127.0.0.1&amp;#34;&lt;/span>, 8545, &lt;span style="color:#b44">&amp;#34;*&amp;#34;&lt;/span>, &lt;span style="color:#b44">&amp;#34;eth,net,web3,admin,personal&amp;#34;&lt;/span>&lt;span style="color:#666">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动的mist钱包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">mist --node geth --node-datadir ./node0 --rpc http://localhost:8545
&lt;span style="color:#080;font-style:italic"># 不启动rpc的话，也可以如下直接通过ipc通信&lt;/span>
&lt;span style="color:#080;font-style:italic"># mist --rpc ./node0/geth.ipc --node-networkid 378 --node-datadir ./node0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://xiaoping378.github.io/ethereum-mist.png" alt="mist界面">&lt;/p>
&lt;p>需要去node1上通过&lt;code>eth.accounts[0]&lt;/code>拿到账号信息,填入红框，点击发送交易，输入密码即可&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethereum-transcation.png" alt="">&lt;/p>
&lt;p>另外也可以通过console命令行来完成上面操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&amp;gt;
&amp;gt; var &lt;span style="color:#b8860b">sender&lt;/span> &lt;span style="color:#666">=&lt;/span> eth.accounts&lt;span style="color:#666">[&lt;/span>0&lt;span style="color:#666">]&lt;/span>
undefined
&amp;gt; var &lt;span style="color:#b8860b">receiver&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#b44">&amp;#34;0x1458eac314d8fc922029095fae20483f55726017&amp;#34;&lt;/span>
undefined
&amp;gt; var &lt;span style="color:#b8860b">amount&lt;/span> &lt;span style="color:#666">=&lt;/span> web3.toWei&lt;span style="color:#666">(&lt;/span>10, &lt;span style="color:#b44">&amp;#34;ether&amp;#34;&lt;/span>&lt;span style="color:#666">)&lt;/span>
undefined
&amp;gt; personal.unlockAccount&lt;span style="color:#666">(&lt;/span>eth.accounts&lt;span style="color:#666">[&lt;/span>0&lt;span style="color:#666">])&lt;/span>
Unlock account 0x799a8f7796d1d20b8198a587caaf545cdde5de13
Passphrase:
&lt;span style="color:#a2f">true&lt;/span>
&amp;gt; eth.sendTransaction&lt;span style="color:#666">({&lt;/span>from:sender, to:receiver, value: amount&lt;span style="color:#666">})&lt;/span>
&lt;span style="color:#b44">&amp;#34;0x97ca1f5fa27df083e14b2ffb82c2a60744aeae0f1a7b5e735ca4d0c05c16f7b6&amp;#34;&lt;/span>
&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="写个合约">写个合约&lt;/h3>
&lt;p>通过mist界面点击的“开发”-&amp;gt;&amp;quot;Open Remix IDE&amp;quot;, 会自动打开IDE工具，并且默认集成了一个投票的合约，合约内容不表&lt;/p>
&lt;p>“create”按钮后面输入 &lt;code>10&lt;/code> -&amp;gt; 点击, 这时候需要输入密码解锁，因为需要支付一定的gas费用。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethereum-contract-ballot.png" alt="">&lt;/p>
&lt;ul>
&lt;li>这个合约就是个投票程序&lt;/li>
&lt;li>第一个部署的默认是主席身份，拥有指定别人投票的权利，因为我这里的mist是连接的node0，所以&lt;/li>
&lt;li>合约初始化（也就是界面点击“create”时），需要输入&amp;quot;投案&amp;quot;个数&lt;/li>
&lt;/ul>
&lt;p>在每个节点的的console里，通过&lt;code>eth.contract(ABI).at(Address);&lt;/code>拿到合约对象，&lt;/p>
&lt;ul>
&lt;li>其中node0的节点需要用&lt;code>giveRightToVote&lt;/code>给其他账户授权投票权限&lt;/li>
&lt;li>ABI的信息，就是remix里Interface框对应的信息&lt;/li>
&lt;li>合约地址通过&lt;code>Copy address&lt;/code>得到&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">
&amp;gt; var &lt;span style="color:#b8860b">b&lt;/span> &lt;span style="color:#666">=&lt;/span> eth.contract&lt;span style="color:#666">([{&lt;/span>&lt;span style="color:#b44">&amp;#34;constant&amp;#34;&lt;/span>:false,&lt;span style="color:#b44">&amp;#34;inputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[{&lt;/span>&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;to&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;address&amp;#34;&lt;/span>&lt;span style="color:#666">}]&lt;/span>,&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;delegate&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;outputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[]&lt;/span>,&lt;span style="color:#b44">&amp;#34;payable&amp;#34;&lt;/span>:false,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;function&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>,&lt;span style="color:#666">{&lt;/span>&lt;span style="color:#b44">&amp;#34;constant&amp;#34;&lt;/span>:true,&lt;span style="color:#b44">&amp;#34;inputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[]&lt;/span>,&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;winningProposal&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;outputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[{&lt;/span>&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;_winningProposal&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;uint8&amp;#34;&lt;/span>&lt;span style="color:#666">}]&lt;/span>,&lt;span style="color:#b44">&amp;#34;payable&amp;#34;&lt;/span>:false,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;function&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>,&lt;span style="color:#666">{&lt;/span>&lt;span style="color:#b44">&amp;#34;constant&amp;#34;&lt;/span>:false,&lt;span style="color:#b44">&amp;#34;inputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[{&lt;/span>&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;voter&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;address&amp;#34;&lt;/span>&lt;span style="color:#666">}]&lt;/span>,&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;giveRightToVote&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;outputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[]&lt;/span>,&lt;span style="color:#b44">&amp;#34;payable&amp;#34;&lt;/span>:false,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;function&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>,&lt;span style="color:#666">{&lt;/span>&lt;span style="color:#b44">&amp;#34;constant&amp;#34;&lt;/span>:false,&lt;span style="color:#b44">&amp;#34;inputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[{&lt;/span>&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;proposal&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;uint8&amp;#34;&lt;/span>&lt;span style="color:#666">}]&lt;/span>,&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;vote&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;outputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[]&lt;/span>,&lt;span style="color:#b44">&amp;#34;payable&amp;#34;&lt;/span>:false,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;function&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>,&lt;span style="color:#666">{&lt;/span>&lt;span style="color:#b44">&amp;#34;inputs&amp;#34;&lt;/span>:&lt;span style="color:#666">[{&lt;/span>&lt;span style="color:#b44">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;_numProposals&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;uint8&amp;#34;&lt;/span>&lt;span style="color:#666">}]&lt;/span>,&lt;span style="color:#b44">&amp;#34;payable&amp;#34;&lt;/span>:false,&lt;span style="color:#b44">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;constructor&amp;#34;&lt;/span>&lt;span style="color:#666">}])&lt;/span>.at&lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b44">&amp;#39;0xc825238a3348f0a679924796fcf1b1b64a8c1706&amp;#39;&lt;/span>&lt;span style="color:#666">)&lt;/span>
undefined
&amp;gt; b.vote&lt;span style="color:#666">(&lt;/span>9&lt;span style="color:#666">)&lt;/span>
&lt;span style="color:#b44">&amp;#34;0x1646e6547606a8ad0e183f1c9145eff08bbdfd860961d6c7d7367f5b70779cbd&amp;#34;&lt;/span>
&amp;gt;
&amp;gt; b.giveRightToVote&lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b44">&amp;#39;0x1458eac314d8fc922029095fae20483f55726017&amp;#39;&lt;/span>&lt;span style="color:#666">)&lt;/span>
&lt;span style="color:#b44">&amp;#34;0x2759928ad03a2ed5bc4b9c54531eb83e25c4a468e71682f67b160ad3328c8173&amp;#34;&lt;/span>
&amp;gt;
&amp;gt; b.giveRightToVote&lt;span style="color:#666">(&lt;/span>&lt;span style="color:#b44">&amp;#39;0x3ca60eb49314d867ab75a3c7b3a5aa61c3d6ef71&amp;#39;&lt;/span>&lt;span style="color:#666">)&lt;/span>
&lt;span style="color:#b44">&amp;#34;0x46f756e613499f836e392011c8f6d7c23d378fd5a656bae775ecda8bf286c5b6&amp;#34;&lt;/span>
&amp;gt; b.winningProposal&lt;span style="color:#666">()&lt;/span>
&lt;span style="color:#666">9&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中值得注意的是b.vote(&lt;number>) 其中的number不能超过create后传入初始参数10， 其实通过&lt;code>Web3 deploy&lt;/code>框的信息也可以直接部署合约。&lt;/p></description></item><item><title>Docs: 监控之我见</title><link>https://xiaoping378.github.io/docs/3-devops/%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/</guid><description>
&lt;!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
&lt;ul>
&lt;li>&lt;a href="#%E6%A6%82%E8%BF%B0">概述&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%9B%91%E6%8E%A7%E7%9B%AE%E6%A0%87">监控目标&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95">监控方法&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%9B%91%E6%8E%A7%E6%A0%B8%E5%BF%83">监控核心&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%9B%91%E6%8E%A7%E6%B5%81%E7%A8%8B">监控流程&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87">监控指标&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#%E7%A1%AC%E4%BB%B6%E7%9B%91%E6%8E%A7">硬件监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7">系统监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7">应用监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7">网络监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90">流量分析&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7">日志监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E5%AE%89%E5%85%A8%E7%9B%91%E6%8E%A7">安全监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="#api%E7%9B%91%E6%8E%A7">API监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7">性能监控&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A7">业务监控&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6">监控报警&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%8A%A5%E8%AD%A6%E5%A4%84%E7%90%86">报警处理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%E6%80%BB%E7%BB%93">总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>监控是整个运维乃至整个产品生命周期中非常重要的一环，可以事前及时预警发现故障，事后提供详实的数据用于追查定位问题。&lt;/p>
&lt;p>目前业界存在各种开源监控产品，如Zabbix，ELK体系，Prometheus等等，各有自身的适用场景，所以选择基于一款开源的的监控系统会是事半功倍的事情。&lt;/p>
&lt;h2 id="监控目标">监控目标&lt;/h2>
&lt;p>站在公司各业务角度考虑，整理如下四点目标：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E7%9B%AE%E6%A0%87.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>对系统不间断实时监控&lt;/strong>: 实际上是对系统不间断的实时监控(这就是监控)&lt;/li>
&lt;li>&lt;strong>实时反馈系统当前状态&lt;/strong>: 我们监控某个硬件、某个系统，某个进程服务,都是需要能实时看到当前系统的状态，是正常、异常、或者故障&lt;/li>
&lt;li>&lt;strong>保证服务可靠性安全性&lt;/strong>：我们监控的目的就是要保证系统、服务、业务正常运行&lt;/li>
&lt;li>&lt;strong>保证业务持续稳定运行&lt;/strong>：如果我们的监控做得很完善，即使出现故障，能第一时间接收到故障报警，在第一时间处理解决，从而保证业务持续性的稳定运行；&lt;/li>
&lt;/ul>
&lt;h2 id="监控方法">监控方法&lt;/h2>
&lt;p>既然我们了解到了监控的重要性、以及监控的目的，那么下面我们需要了解下监控有哪些方法。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>了解监控对象&lt;/strong>：我们要监控的对象你是否了解呢？比如 CPU 到底是如何工作的？&lt;/li>
&lt;li>&lt;strong>性能基准指标&lt;/strong>：我们要监控这个东西的什么属性？比如 CPU 的使用率、负载、用户态、内核态、上下文切换。&lt;/li>
&lt;li>&lt;strong>报警阈值定义&lt;/strong>：怎么样才算是故障，要报警呢？比如 CPU 的负载到底多少算高，用户态、内核态分别跑多少算高？&lt;/li>
&lt;li>&lt;strong>故障处理流程&lt;/strong>：收到了故障报警，我们怎么处理呢？有什么更高效的处理流程吗？&lt;/li>
&lt;/ul>
&lt;h2 id="监控核心">监控核心&lt;/h2>
&lt;p>我们了解了监控的方法、监控对象、性能指标、报警阈值定义、以及故障处理流程几步骤，当然我们更需要知道监控的核心是什么？&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E6%A0%B8%E5%BF%83.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>发现问题&lt;/strong>：当系统发生故障报警，我们会收到故障报警的信息 ；&lt;/li>
&lt;li>&lt;strong>定位问题&lt;/strong>：故障邮件一般都会写某某主机故障、具体故障的内容，我们需要对报警内容进行分析，比如一台服务器连不上：我们就需要考虑是网络问题、还是负载太高导致长时间无法连接，又或者某开发触发了防火墙禁止的相关策略等等，我们就需要去分析故障具体原因；&lt;/li>
&lt;li>&lt;strong>解决问题&lt;/strong>：当然我们了解到故障的原因后，就需要通过故障解决的优先级去解决该故障；&lt;/li>
&lt;li>&lt;strong>总结问题&lt;/strong>：当我们解决完重大故障后，需要对故障原因以及防范进行总结归纳，避免以后重复出现；&lt;/li>
&lt;/ul>
&lt;h2 id="监控流程">监控流程&lt;/h2>
&lt;p>基于 Zabbix 来构建整个监控体系生态圈&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E6%B5%81%E7%A8%8B.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>数据采集&lt;/strong>：Zabbix 通过 SNMP、Agent、ICMP、SSH、IPMI 等对系统进行数据采集；&lt;/li>
&lt;li>&lt;strong>数据存储&lt;/strong>：Zabbix 存储在 MySQL 上，也可以存储在其他数据库服务；&lt;/li>
&lt;li>&lt;strong>数据分析&lt;/strong>：当我们事后需要复盘分析故障时，Zabbix 能给我们提供图形以及时间等相关信息，方面我们确定故障所在；&lt;/li>
&lt;li>&lt;strong>数据展示&lt;/strong>：web 界面展示、(移动 APP、java_php 开发一个 web 界面也可以) ；&lt;/li>
&lt;li>&lt;strong>监控报警&lt;/strong>：电话报警、邮件报警、微信报警、短信报警、报警升级机制等（无论什么报警都可以）；&lt;/li>
&lt;li>&lt;strong>报警处理&lt;/strong>：当接收到报警，我们需要根据故障的级别进行处理，比如:重要紧急、重要不紧急等。根据故障的级别，配合相关的人员进行快速处理；&lt;/li>
&lt;/ul>
&lt;h2 id="监控指标">监控指标&lt;/h2>
&lt;p>具体要监控些什么东西？那么我在这里进行了分类整理:&lt;/p>
&lt;h3 id="硬件监控">硬件监控&lt;/h3>
&lt;p>早期我们通过机房巡检的方式，查看硬件设备灯光闪烁情况判断是否故障，这样非常浪费人力，并且是重复性无技术含量的工作，大家懂得。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E7%A1%AC%E4%BB%B6%E7%9B%91%E6%8E%A7.jpeg" alt="">&lt;/p>
&lt;p>当然我们现在可以通过IPMI对硬件详细情况进行监控，并对 CPU、内存、磁盘、温度、风扇、电压等设置报警阈值(自行对监控报警内容编写合理的报警范围)&lt;/p>
&lt;h3 id="系统监控">系统监控&lt;/h3>
&lt;p>基本全是 Linux 服务器，那么我们肯定要监控系统资源的使用情况，系统监控是监控体系的基础。&lt;/p>
&lt;p>**监控主要对象: **&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1.jpeg" alt="">&lt;/p>
&lt;p>CPU 有几个重要的概念：&lt;code>上下文切换、运行队列和使用率&lt;/code>。
这也是我们 CPU 监控的几个重点指标。
通常情况，每个处理器的运行队列不要高于3，CPU 利用率中“用户态/内核态”比例维持在70/30，空闲状态维持在50%，上下文切换
要根据系统繁忙程度来综合考量。&lt;/p>
&lt;p>针对 CPU 常用的工具有：htop、top、vmstat、mpstat、dstat、glances&lt;/p>
&lt;p>Zabbix 提供系统监控模板：&lt;code>Zabbix Agent Interface&lt;/code>&lt;/p>
&lt;p>cpu整体状态
&lt;img src="https://xiaoping378.github.io/cpu%E6%95%B4%E4%BD%93%E7%8A%B6%E6%80%81.jpeg" alt="">&lt;/p>
&lt;p>cpu上下文切换
&lt;img src="https://xiaoping378.github.io/cpu%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.jpeg" alt="">&lt;/p>
&lt;p>硬盘读写吞吐
&lt;img src="https://xiaoping378.github.io/%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E5%90%9E%E5%90%90.jpeg" alt="">&lt;/p>
&lt;p>其它的系统监控还有运行的进程端口、进程数、登陆用户、Open File 等（详细查看 zabbix 自带 OS Linux 模板）&lt;/p>
&lt;h3 id="应用监控">应用监控&lt;/h3>
&lt;p>把硬件监控和系统监控研究明白后，我们进一步操作是需要登陆到服务器上查看服务器运行了哪些服务，都需要监控起来。
应用服务监控也是监控体系中比较重要的内容，例如：LVS、Haproxy、Docker、Nginx、PHP、Memcached、Redis、MySQL、Rabbitmq 等等，相关的服务都需要使用zabbix监控起来。&lt;/p>
&lt;p>PHP-FPM状态
&lt;img src="https://xiaoping378.github.io/PHP-FPM_status.jpeg" alt="">&lt;/p>
&lt;p>redis状态
&lt;img src="https://xiaoping378.github.io/redis_status.jpeg" alt="">&lt;/p>
&lt;p>Zabbix 提供应用服务监控：Zabbix Agent UserParameter
Zabbix 提供的Java监控：Zabbix JMX Interface
percona 提供 MySQL 数据库监控：percona-monitoring-plulgins&lt;/p>
&lt;h3 id="网络监控">网络监控&lt;/h3>
&lt;p>网络监控是我们构建监控平台时必须要考虑的，尤其是针对有多个机房的场景，各个机房之间的网络状态，机房和全国各地的网络状态都是我们需要重点关注的对象。&lt;/p>
&lt;p>需要借助于网络监控工具 Smokeping监控机房链路。&lt;/p>
&lt;p>Smokeping 是 rrdtool 的作者 Tobi Oetiker 的作品，是用 Perl 写的，主要是监视网络性能，www 服务器性能，dns 查询性能等，使用 rrdtool 绘图，而且支持分布式，直接从多个 agent 进行数据的汇总。&lt;/p>
&lt;p>CDN监控。。。对接第三方接口
&lt;img src="https://xiaoping378.github.io/cdn%E7%9B%91%E6%8E%A7.jpeg" alt="">&lt;/p>
&lt;h3 id="流量分析">流量分析&lt;/h3>
&lt;p>网站流量分析对于运维人员来说，更是一门必须掌握的知识了。比如对于300.cn站点来说：&lt;/p>
&lt;p>通过对网站来源的统计和分析，可以了解我们在某个网站上的广告投入有没有收到预期的效果。
可以区分不同地区的访问人数、甚至产品交易额等。
百度统计、google 分析、站长工具等等，只需要在页面嵌入一个js即可，但是，数据始终是在对方手中，个性化定制不方便，推荐使用google的piwik开源网站访问统计系统。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/piwik%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1.png" alt="">&lt;/p>
&lt;h3 id="日志监控">日志监控&lt;/h3>
&lt;p>通常情况下，随着系统的运行，操作系统会产生系统日志，应用程序会产生应用程序的访问日志、错误日志、运行日志、网络日志，我们可以使用 ELK 来进行日志监控。&lt;/p>
&lt;p>对于日志监控来说，最见的需求就是收集、存储、查询、展示。&lt;/p>
&lt;p>开源社区正好有相对应的开源项目： logstash（收集） + elasticsearch（存储+搜索） + kibana（展示）
我们将这三个组合起来的技术称之为 ELK Stack，所以说 ELK Stack 指的是 Elasticsearch、Logstash、Kibana 技术栈的结合。&lt;/p>
&lt;p>如果收集了日志信息，那么如果部署更新有异常出现，可以立即在 kibana 上看到。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/kibana-log.png" alt="">&lt;/p>
&lt;p>当然也可以通过Zabbix过滤错误日志来进行告警。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/zabbix-log.jpeg" alt="">&lt;/p>
&lt;h3 id="安全监控">安全监控&lt;/h3>
&lt;p>虽然Linux开源的安全产品不少，比如四层 iptables，七层WEB防护 Nginx+lua 实现 WAF，最后将相关的日志都收至 ELK Stack，通过图形化进行不同的攻击类型展示。但是始终是一件比较耗费时间的事情，并且个人认为效果并不是很好。&lt;/p>
&lt;h3 id="api监控">API监控&lt;/h3>
&lt;p>由于微服务架构的推行， API 变得越来越重要，很显然我们也需要这样的数据来分辨我们提供的 API 是否能够正常运作。&lt;/p>
&lt;p>监控 API 接口 GET、POST、PUT、DELETE、HEAD、OPTIONS 的请求， 可用性、正确性、响应时间为三大重性能指标&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/api-monitor.jpeg" alt="">&lt;/p>
&lt;h3 id="性能监控">性能监控&lt;/h3>
&lt;p>全面监控网页性能，DNS 响应时间、HTTP 建立连接时间、页面性能指数、响应时间、可用率、元素大小等&lt;/p>
&lt;p>Zabbix 提供 URL监控：Zabbix Web 监控&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7download-speed.jpeg" alt="">&lt;/p>
&lt;h3 id="业务监控">业务监控&lt;/h3>
&lt;p>没有业务指标监控的监控平台，不是一个完善的监控平台，通常在我们的监控系统中，必须将我们重要的业务指标进行监控，并设置阈值进行告警通知。&lt;/p>
&lt;p>例如一个产品集群：&lt;/p>
&lt;ul>
&lt;li>每天产生多少订单；&lt;/li>
&lt;li>每天注册多少用户；&lt;/li>
&lt;li>每天有多少活跃用户；&lt;/li>
&lt;li>每天有多少推广活动；&lt;/li>
&lt;li>推广活动引入多少用户；&lt;/li>
&lt;li>推广活动引入多少流量；&lt;/li>
&lt;li>推广活动引入多少利润；&lt;/li>
&lt;/ul>
&lt;p>等等 重要指标都可以加到 Zabbix 上，然后通过 screen 展示。&lt;/p>
&lt;h2 id="监控报警">监控报警&lt;/h2>
&lt;p>故障报警通知的方式有很多种，当然我们最常用的还是短信，邮件&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6.png" alt="">&lt;/p>
&lt;h2 id="报警处理">报警处理&lt;/h2>
&lt;p>一般报警后我们故障如何处理，首先，我们可以通过告警升级机制先自动处理，比如 Nginx 服务 down 了，可以设置告警升级自动启动 Nginx。&lt;/p>
&lt;p>但是如果一般业务出现了严重故障，我们通常根据故障的级别，故障的业务，来指派不同的运维人员进行处理。
当然不同业务形态、不同架构、不同服务可能采用的方式都不同，这个没有一个固定的模式套用。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/%E6%8A%A5%E8%AD%A6%E5%A4%84%E7%90%86.png" alt="">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;ol>
&lt;li>监控是一个长期持续的项目, 需要特定的1-2人跟踪改进;&lt;/li>
&lt;li>监控使用方是业务和运维;&lt;/li>
&lt;li>业务方应提供监控项获取方法;&lt;/li>
&lt;li>如果有投诉，先找监控项目组，没有做到“事先”发现问题，监控项目组应该承担其责任;&lt;/li>
&lt;li>对外提供api，供业务方使用&lt;/li>
&lt;/ol></description></item><item><title>Docs: docker网络</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/docker-network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/docker-network/</guid><description>
&lt;p>自去年就开始推动公司业务使用docker了， 至今也一年多了，但对docker网络的认知一直一知半解。。。&lt;/p>
&lt;p>主要是太忙，加上线上业务也没出过关于网络吞吐性能方面的问题，就没太大动力去搞明白， 现在闲下来了，搞之！&lt;/p>
&lt;h3 id="环境声明">环境声明&lt;/h3>
&lt;ul>
&lt;li>以下内容只针对OS: Ubuntu16.04 docker: 1.10.3的环境， 写本文时docker最新的release版本是1.11.2，还有什么CoreOS，Unikernel 之类的（表示都没玩过）。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>docker更新迭代速度太快了，公司业务只用到基本功能，所以没动力跟进它的更新了
各种新时代下的产物频出啊， CoreOS为linux的发行版， 没需求，好遗憾.&lt;/p>
&lt;/blockquote>
&lt;h3 id="docker的网络模式">docker的网络模式&lt;/h3>
&lt;p>一开始安装完docker， 它就会默认创建3个网络， 使用__docker network ls__查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ blog git:&lt;span style="color:#666">(&lt;/span>master&lt;span style="color:#666">)&lt;/span> docker network ls
NETWORK ID NAME DRIVER
46416a43fbc6 bridge bridge
45398901e9f0 none null
9440a8140e68 host host
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当启动一个容器时， 默认使用bridge模式， 可以通过 --net 指定其它模式。&lt;/p>
&lt;p>下面先简要说明下各自的概念&lt;/p>
&lt;ul>
&lt;li>bridge 模式&lt;/li>
&lt;/ul>
&lt;p>容器间之所以能通信，就靠宿主机上的docker0了， docker0就是bridge模式下默认创建的虚拟设备名称&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ blog git:&lt;span style="color:#666">(&lt;/span>master&lt;span style="color:#666">)&lt;/span> ✗ ifconfig docker0
docker0 Link encap:Ethernet HWaddr 02:42:49:56:7c:3b
inet addr:172.17.0.1 Bcast:0.0.0.0 Mask:255.255.0.0
inet6 addr: fe80::42:49ff:fe56:7c3b/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:78103 errors:0 dropped:0 overruns:0 frame:0
TX packets:47578 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:17485434 &lt;span style="color:#666">(&lt;/span>17.4 MB&lt;span style="color:#666">)&lt;/span> TX bytes:82163889 &lt;span style="color:#666">(&lt;/span>82.1 MB&lt;span style="color:#666">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ifocnfig可以看到很多信息， mac地址，IP等这些也可以通过参数指定成别的。&lt;/p>
&lt;ul>
&lt;li>none模式&lt;/li>
&lt;/ul>
&lt;p>none网络模式下的容器里是缺少网络接口的，例如eth0等，但会有一个lo设备。&lt;/p>
&lt;p>没用过也没见过这样的业务场景， 不做过多说明&lt;/p>
&lt;ul>
&lt;li>host模式&lt;/li>
&lt;/ul>
&lt;p>容器直接操作宿主机的网络栈， 无疑是性能最好的网络模式， 可以认为是无带宽损耗的。&lt;/p>
&lt;h3 id="细说bridge模式">细说bridge模式&lt;/h3>
&lt;p>这也是我们线上正在在用的网络模式。&lt;/p>
&lt;p>bridge模式主要利用了iptables的Masquerading和DNAT功能。&lt;/p>
&lt;p>未完。。。&lt;/p></description></item><item><title>Docs: 权限资源管理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%9D%83%E9%99%90%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%9D%83%E9%99%90%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</guid><description>
&lt;p>重点介绍 project，limitRange，resourceQuta和 user, group, rule，role，policy，policybinding的关系,
我刚接触时，这几个概念老搞不太清楚，这里梳理下&lt;/p>
&lt;h2 id="资源管理说明">资源管理说明&lt;/h2>
&lt;p>可以对计算资源的大小和对象类型的数量来进行配额限制。&lt;/p>
&lt;p>&lt;code>ResourceQuota&lt;/code>是面向project（namespace的基础上加了些注解）层面的，只有集群管理员可以基于namespace设置。&lt;/p>
&lt;p>&lt;code>limtRange&lt;/code>是面向pod和container级别的，openshift额外还可以限制 image， imageStream和pvc，
也是只有集群管理员才可以基于project设置，而开发人员只能基于pod（container）设置cpu和内存的requests/limits。&lt;/p>
&lt;h3 id="resourcequota">ResourceQuota&lt;/h3>
&lt;p>看看具体可以管理哪些资源，期待网络相关的也加进来.简单来讲，可以基于project来限制可消耗的内存大小和可创建的pods数量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#080;font-style:italic">// The following identify resource constants for Kubernetes object types
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>&lt;span style="color:#a2f;font-weight:bold">const&lt;/span> (
&lt;span style="color:#080;font-style:italic">// Pods, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourcePods ResourceName = &lt;span style="color:#b44">&amp;#34;pods&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// Services, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceServices ResourceName = &lt;span style="color:#b44">&amp;#34;services&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ReplicationControllers, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceReplicationControllers ResourceName = &lt;span style="color:#b44">&amp;#34;replicationcontrollers&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ResourceQuotas, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceQuotas ResourceName = &lt;span style="color:#b44">&amp;#34;resourcequotas&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ResourceSecrets, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceSecrets ResourceName = &lt;span style="color:#b44">&amp;#34;secrets&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ResourceConfigMaps, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceConfigMaps ResourceName = &lt;span style="color:#b44">&amp;#34;configmaps&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ResourcePersistentVolumeClaims, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourcePersistentVolumeClaims ResourceName = &lt;span style="color:#b44">&amp;#34;persistentvolumeclaims&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ResourceServicesNodePorts, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceServicesNodePorts ResourceName = &lt;span style="color:#b44">&amp;#34;services.nodeports&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ResourceServicesLoadBalancers, number
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceServicesLoadBalancers ResourceName = &lt;span style="color:#b44">&amp;#34;services.loadbalancers&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// CPU request, in cores. (500m = .5 cores)
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceRequestsCPU ResourceName = &lt;span style="color:#b44">&amp;#34;requests.cpu&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// Memory request, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceRequestsMemory ResourceName = &lt;span style="color:#b44">&amp;#34;requests.memory&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// Storage request, in bytes
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceRequestsStorage ResourceName = &lt;span style="color:#b44">&amp;#34;requests.storage&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// CPU limit, in cores. (500m = .5 cores)
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceLimitsCPU ResourceName = &lt;span style="color:#b44">&amp;#34;limits.cpu&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// Memory limit, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceLimitsMemory ResourceName = &lt;span style="color:#b44">&amp;#34;limits.memory&amp;#34;&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>openshift额外支持的images相关的限制策略&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#080;font-style:italic">// ResourceImageStreams represents a number of image streams in a project.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>ResourceImageStreams kapi.ResourceName = &lt;span style="color:#b44">&amp;#34;openshift.io/imagestreams&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ResourceImageStreamImages represents a number of unique references to images in all image stream
&lt;/span>&lt;span style="color:#080;font-style:italic">// statuses of a project.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>ResourceImageStreamImages kapi.ResourceName = &lt;span style="color:#b44">&amp;#34;openshift.io/images&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// ResourceImageStreamTags represents a number of unique references to images in all image stream specs
&lt;/span>&lt;span style="color:#080;font-style:italic">// of a project.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>ResourceImageStreamTags kapi.ResourceName = &lt;span style="color:#b44">&amp;#34;openshift.io/image-tags&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，除了可以设置额度Quantity外，还可以指定配额的作用范围Scopes，其实就是作用于哪类pod上的:&lt;/p>
&lt;ul>
&lt;li>是否是长期运行的pod&lt;/li>
&lt;li>是否有资源上限的pod&lt;/li>
&lt;/ul>
&lt;p>目前只有pods数和计算资源（cpu,内存）才能指定作用域&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#080;font-style:italic">// A ResourceQuotaScope defines a filter that must match each object tracked by a quota
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>&lt;span style="color:#a2f;font-weight:bold">type&lt;/span> ResourceQuotaScope &lt;span style="color:#0b0;font-weight:bold">string&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">const&lt;/span> (
&lt;span style="color:#080;font-style:italic">// Match all pod objects where spec.activeDeadlineSeconds，这个是标明pod的运行时长参数
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceQuotaScopeTerminating ResourceQuotaScope = &lt;span style="color:#b44">&amp;#34;Terminating&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// Match all pod objects where !spec.activeDeadlineSeconds ， 长期运行的pod
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceQuotaScopeNotTerminating ResourceQuotaScope = &lt;span style="color:#b44">&amp;#34;NotTerminating&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// Match all pod objects that have best effort quality of service， 只能用来描述资源无上限的pod数
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceQuotaScopeBestEffort ResourceQuotaScope = &lt;span style="color:#b44">&amp;#34;BestEffort&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic">// Match all pod objects that do not have best effort quality of service， 资源有上限的pod
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> ResourceQuotaScopeNotBestEffort ResourceQuotaScope = &lt;span style="color:#b44">&amp;#34;NotBestEffort&amp;#34;&lt;/span>
)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面举个例子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#008000;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>v1&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>ResourceQuota&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>compute-resources-long-running&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">hard&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">pods&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;4&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">limits.cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;4&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">limits.memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;2Gi&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">scopes&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- NotTerminating&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的意思即是， 限制长期运行的pod最多只能创建4个，且共用4c和2G内存&lt;/p>
&lt;p>如果不指定scopes的话，是描述的所有scopes的限制；&lt;/p>
&lt;blockquote>
&lt;p>本文参考&lt;a href="https://docs.openshift.org/latest/admin_guide/quota.html">这里&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>可以看到，通过资源配额管理，可以帮助我们解决以下问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>控制计算资源使用量&lt;/p>
&lt;p>我们在实际生产环境中经常遇到的情况是，用户申请了过多的资源，用户应用的资源使用率太低，造成了资源的浪费。管理员通常会给集群设置超卖系数，来提高整个集群的资源使用率；另外管理员也会给用户设置资源配额上限，来限制用户使用资源的数量。通过上面的介绍我们可以看到，kubernetes的资源配额，我们可以从应用的层次上来进行配额管理，可以设置不同应用的资源配额上限。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>控制besteffort类型POD资源使用量&lt;/p>
&lt;p>如果POD中的所有容器都没有设置request和limit，那么这些POD的QoS类型是besteffort，这种类型的POD更方便kubernetes进行调度，但是存在的问题是，如果不对这些POD进行资源管理，那么就会导致这个kubernetes集群资源过载，会影响这个集群中的所有应用，所以通过将资源配额管理的作用范围设置成besteffort，kubernetes可以通过限制这些POD的资源，避免整个集群资源过载。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>控制长期运行的应用和短暂运行的应用资源使用率&lt;/p>
&lt;p>在实际使用中，在kubernetes集群中会同时存在两种类型的应用，一种是长期运行的应用，比如网站这种web应用，还有一种就是短暂运行的应用，比如编译网站的这种应用。通过资源配额管理，可以同时对这两种不同类型的应用设置资源使用上限，来控制不同应用的资源使用。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="limitrange">LimitRange&lt;/h3>
&lt;p>&lt;code>limtRange&lt;/code>是面向pod和container级别的，为什么只能集群管理员才可设置呢，因为这个的提出是为了防止有些应用忘记加资源边界的限定，而占用过多的资源，那么有了limitRange就给它来个默认限制。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#008000;font-weight:bold">apiVersion&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;v1&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">kind&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;LimitRange&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">metadata&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;core-resource-limits&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">spec&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">limits&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#008000;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;Pod&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">max&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;2&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;1Gi&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">min&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;200m&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;6Mi&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#008000;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;Container&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">max&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;2&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;1Gi&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">min&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;100m&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;4Mi&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">default&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;300m&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;200Mi&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">defaultRequest&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;200m&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;100Mi&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">maxLimitRequestRatio&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;10&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#008000;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;openshift.io/Image&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">max&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">storage&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;1Gi&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#008000;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;openshift.io/ImageStream&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">max&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">openshift.io/image-tags&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;10&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">openshift.io/images&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#b44">&amp;#34;12&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上使用oc create后，会看到我们对某namespace下的pod和container做了默认的资源设置，&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/limitRange.png" alt="limitRange">&lt;/p>
&lt;h2 id="权限管理说明">权限管理说明&lt;/h2>
&lt;p>这里不涉及到认证登录的介绍，openshfit支持很多认证方式，比如AllowAll，CA认证, HTPasswd, KeyStone, LDAP, Oauth等，这里为了简化，用默认的AllowAll来做权限控制的说明&lt;/p>
&lt;p>权限管理，即访问API资源之前，必须要经过的访问策略校验，主要分为5种： AlwaysDeny、AlwaysAllow（默认）、ABAC、RBAC、Webhook&lt;/p>
&lt;p>主要说明user, group, rule，role，policy，policybinding之间的关系，以及提出这些概念，各自是为了解决什么问题&lt;/p>
&lt;ul>
&lt;li>user和group&lt;/li>
&lt;/ul>
&lt;p>说到user其实就是一个用户账号(userAccount)，用它来和k8s集群做交互（登录，kubectl等）， 但还有一个容易混淆的概念就是sercieAccount，有了userAccount为什么还又来个serviceAccount的设计， 这两者有什么区别 ？ 以下是kubernetes官方对两者的解释&lt;/p>
&lt;blockquote>
&lt;p>user account是为人类设计的，而service account则是为跑在pod里的进程用的，运行在pod里的进程需要调用Kubernetes API以及非Kubernetes API的其它服务（如image repository/被mount到pod上的NFS volumes中的file等）;&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>user account是global的，即跨namespace使用；而service account是namespaced内的，即仅在所属的namespace下使用;&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>user account可能会涉及到很多权限设定和商业逻辑在里面，而后者是更轻量级的，是集群用户针对某namespace内的服务使用的，一般遵循最小特权原则，如监控服务需要访问APIsever等;&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>useraccount需要借助第三方实现，后者系统都会默认在namesspace里创建default，亦可自定义&lt;/p>
&lt;/blockquote>
&lt;p>两者大部分流程是一致的，都是要先认证通过再校验权限，然后才是action， 实际上一般是由userAccount来控制serviceAccount来完成特定的任务，
比如一个用户A自建了服务1和服务2， 但只想把服务2开发给用户B，这样的serviceAccount就可以排上用场了,
又或者我有几个服务，有了serviceAccount就可以来限制用户的访问权限（list, watch, update, delete）了.&lt;/p>
&lt;p>说到group就是方便对user的权限批量操作而设计；&lt;/p>
&lt;p>用户可以被分配到一个或多个组，每个组代表一组特定的用户。组在同时向多个用户管理权限时非常有用。&lt;/p>
&lt;ul>
&lt;li>rule和role&lt;/li>
&lt;/ul>
&lt;p>rule是规则， 是对一组对象上被允许的动作（get, list, create, update, delete, deletecollection 和 watch）描述，可操作对象主要是 container，images，pod，servcie， project， user， build， imagestream， dc， route， templeate。&lt;/p>
&lt;p>role 就是规则的集合，俗称角色， 不同对象上的不同动作，可以任意组成各种角色，系统默认的有 &lt;code>admin basic-user cluster-admin cluster-admin edit self-provisioner view&lt;/code>；&lt;/p>
&lt;p>policy，是策略, 保存特定namespace的所有角色roles的对象。 每个命名空间最多只有一个Policy策略。&lt;/p>
&lt;p>rolebinding， 就是把user或者group与角色role进行关联，注意. user和group可以被关联到多个roles&lt;/p>
&lt;p>pollicybing, 就是就是多个rolebindings的描述；&lt;/p>
&lt;p>这样看，policy的概念提出有点儿扯淡了，感觉没什么用，其实不然，policy的提出主要是为了区分cluster-policy和local-policy的。&lt;/p>
&lt;p>cluster policy是适用于所有namespace的角色和绑定；
local policy则是试用于具体的某个namespace的；&lt;/p>
&lt;p>以上可以通过&lt;code>oc describe clusterPolicy default&lt;/code>来看查看所有详细的信息；&lt;/p>
&lt;p>小节：&lt;/p>
&lt;p>可以通过&lt;code>oc policy can-i --list&lt;/code>查看自己可以干些什么&lt;/p>
&lt;p>还可以通过&lt;code>oc policy who-can &amp;lt;动作&amp;gt; &amp;lt;资源对象&amp;gt;&lt;/code>， 比如说查看谁能get pod之类的，就是&lt;code>oc policy who-can get pod&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">➜ openshift-docs git:&lt;span style="color:#666">(&lt;/span>master&lt;span style="color:#666">)&lt;/span> ✗ oc policy who-can get pod
Namespace: myproject
Verb: get
Resource: pods
Users: developer
system:admin
system:serviceaccount:default:pvinstaller
system:serviceaccount:myproject:deployer
system:serviceaccount:openshift-infra:build-controller
system:serviceaccount:openshift-infra:deployment-controller
system:serviceaccount:openshift-infra:deploymentconfig-controller
system:serviceaccount:openshift-infra:endpoint-controller
system:serviceaccount:openshift-infra:namespace-controller
system:serviceaccount:openshift-infra:pet-set-controller
system:serviceaccount:openshift-infra:pv-binder-controller
system:serviceaccount:openshift-infra:pv-recycler-controller
Groups: system:cluster-admins
system:cluster-readers
system:masters
system:nodes
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果openshift自带的角色不能满足的话，还可以自定义角色role&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">$ oc get clusterrole view -o yaml &amp;gt; clusterrole_view.yaml
$ cp clusterrole_view.yaml localrole_exampleview.yaml
$ vim localrole_exampleview.yaml
&lt;span style="color:#080;font-style:italic"># 1. Update kind: ClusterRole to kind: Role&lt;/span>
&lt;span style="color:#080;font-style:italic"># 2. Update name: view to name: exampleview&lt;/span>
&lt;span style="color:#080;font-style:italic"># 3. Remove resourceVersion, selfLink, uid, and creationTimestamp&lt;/span>
$ oc create -f path/to/localrole_exampleview.yaml -n &amp;lt;project_you_want_to_add_the_local_role_exampleview_to&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="下文介绍实战-结合实际场景-如何设置权限-即整个开发管理流程实践说明">下文介绍实战，结合实际场景，如何设置权限，即整个开发管理流程实践说明&lt;/h2></description></item><item><title>Docs: 构建生产环境级的docker Swarm集群-2</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-swarm2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-swarm2/</guid><description>
&lt;p>此文档适用于不低于1.12版本的docker，因为swarm已内置于docker-engine里。&lt;/p>
&lt;ol>
&lt;li>硬件需求&lt;/li>
&lt;/ol>
&lt;p>这里以5台PC服务器为例, 分别如下作用&lt;/p>
&lt;ul>
&lt;li>manager0&lt;/li>
&lt;li>manager1&lt;/li>
&lt;li>node0&lt;/li>
&lt;li>node1&lt;/li>
&lt;li>node2&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>每台PC上安装docker-engine&lt;/li>
&lt;/ol>
&lt;p>一台一台的ssh上去执行，或者使用ansible批量部署工具。&lt;/p>
&lt;p>安装docker-engine&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -sSL https://get.docker.com/ | sh
&lt;/code>&lt;/pre>&lt;p>启动之，并使之监听2375端口&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
&lt;/code>&lt;/pre>&lt;p>亦可修改配置，使之永久生效&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir /etc/systemd/system/docker.service.d
cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/systemd/system/docker.service.d/docker.conf
[Service]
ExecStart=
ExecStart=/usr/bin/docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --dns 180.76.76.76 --insecure-registry registry.cecf.com -g /home/Docker/docker
EOF
&lt;/code>&lt;/pre>&lt;p>如果开启了防火墙，需要开启如下端口&lt;/p>
&lt;ul>
&lt;li>&lt;strong>TCP port 2377&lt;/strong> for cluster management communications&lt;/li>
&lt;li>&lt;strong>TCP&lt;/strong> and &lt;strong>UDP port 7946&lt;/strong> for communication among nodes&lt;/li>
&lt;li>&lt;strong>TCP&lt;/strong> and &lt;strong>UDP port 4789&lt;/strong> for overlay network traffic&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>创建swarm&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">docker swarm init --advertise-addr &amp;lt;MANAGER-IP&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我的实例里如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#666">[&lt;/span>root@manager0 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic"># docker swarm init --advertise-addr 10.42.0.243&lt;/span>
Swarm initialized: current node &lt;span style="color:#666">(&lt;/span>e5eqi0lue90uidzsfddeqwfl8&lt;span style="color:#666">)&lt;/span> is now a manager.
To add a worker to this swarm, run the following command:
docker swarm join &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> --token SWMTKN-1-3iskhw3lsc9pkdtijj1d23lg9tp7duj18f477i5ywgezry7zlt-dfwjbsjleoajcdj13psu702s6 &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> 10.42.0.243:2377
To add a manager to this swarm, run &lt;span style="color:#b44">&amp;#39;docker swarm join-token manager&amp;#39;&lt;/span> and follow the instructions.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 &lt;code>--advertise-addr&lt;/code> 来声明manager0的IP，其他的nodes必须可以和此IP互通，
一旦完整初始化，此node即是manger又是worker node.&lt;/p>
&lt;p>通过&lt;code>docker info&lt;/code>来查看&lt;/p>
&lt;pre tabindex="0">&lt;code>$ docker info
Containers: 2
Running: 0
Paused: 0
Stopped: 2
...snip...
Swarm: active
NodeID: e5eqi0lue90uidzsfddeqwfl8
Is Manager: true
Managers: 1
Nodes: 1
...snip...
&lt;/code>&lt;/pre>&lt;p>通过&lt;code>docker node ls&lt;/code>来查看集群的node信息&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@manager0 ~]# docker node ls
ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS
e5eqi0lue90uidzsfddeqwfl8 * manager0 Ready Active Leader
&lt;/code>&lt;/pre>&lt;p>这里的&lt;code>*&lt;/code>来指明docker client正在链接在这个node上。&lt;/p>
&lt;ol start="4">
&lt;li>加入swarm集群&lt;/li>
&lt;/ol>
&lt;p>执行在manager0上产生&lt;code>docker swarm init&lt;/code>产生的结果即可&lt;/p>
&lt;p>如果当时没记录下来，还可以在manager上补看
想把node以worker身份加入，在manager0上执行下面的命令来补看。&lt;/p>
&lt;pre tabindex="0">&lt;code>docker swarm join-token worker
&lt;/code>&lt;/pre>&lt;p>想把node以manager身份加入，在manager0上执行下面的命令来来补看。&lt;/p>
&lt;pre tabindex="0">&lt;code>docker swarm join-token manager
&lt;/code>&lt;/pre>&lt;p>为了manager的高可用，我这里需要在manager1上执行&lt;/p>
&lt;pre tabindex="0">&lt;code>docker swarm join \
--token SWMTKN-1-3iskhw3lsc9pkdtijj1d23lg9tp7duj18f477i5ywgezry7zlt-86dk7l9usp1yh4uc3rjchf2hu \
10.42.0.243:2377
&lt;/code>&lt;/pre>&lt;p>我这里就是依次在node0-2上执行&lt;/p>
&lt;pre tabindex="0">&lt;code>docker swarm join \
--token SWMTKN-1-3iskhw3lsc9pkdtijj1d23lg9tp7duj18f477i5ywgezry7zlt-dfwjbsjleoajcdj13psu702s6 \
10.42.0.243:2377
&lt;/code>&lt;/pre>&lt;p>这样node就会加入之前我们创建的swarm集群里。&lt;/p>
&lt;p>再通过&lt;code>docker node ls&lt;/code>来查看现在的集群情况， swarm的集群里是以node为实例的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#666">[&lt;/span>root@manager0 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic"># docker node ls&lt;/span>
ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS
0tr5fu8ebi27cp2ot210t67fx manager1 Ready Active Reachable
46irkik4idjk8rjy7pqjb84x0 node1 Ready Active
79hlu1m7x9p4cc4npa4xjuax3 node0 Ready Active
9535h8ow82s8mzuw5kud2mwl3 consul0 Ready Active
e5eqi0lue90uidzsfddeqwfl8 * manager0 Ready Active Leader
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里MANAFER标明各node的身份，空即为worker身份。&lt;/p>
&lt;ol start="5">
&lt;li>部署服务&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>Usage: docker service COMMAND
Manage Docker services
Options:
--help Print usage
Commands:
create Create a new service
inspect Display detailed information on one or more services
ps List the tasks of a service
ls List services
rm Remove one or more services
scale Scale one or multiple services
update Update a service
&lt;/code>&lt;/pre>&lt;p>部署示例如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>docker service create --replicas 2 --name helloworld alpine ping 300.cn
&lt;/code>&lt;/pre>&lt;p>&lt;code>docker service ls&lt;/code>罗列swarm集群的所有services
&lt;code>docker service ps helloworld&lt;/code>查看service部署到了哪个node上
&lt;code>docker service inspect helloworld&lt;/code> 查看service 资源、状态等具体信息
&lt;code>docker servcie scale helloworld=5&lt;/code>来扩容service的个数
&lt;code>docker service rm helloworld&lt;/code> 来删除service
&lt;code>docker service update&lt;/code> 来实现更新service的各项属性，包括滚动升级等。&lt;/p>
&lt;p>可更新的属性包含如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>Usage: docker service update [OPTIONS] SERVICE
Update a service
Options:
--args string Service command args
--constraint-add value Add or update placement constraints (default [])
--constraint-rm value Remove a constraint (default [])
--container-label-add value Add or update container labels (default [])
--container-label-rm value Remove a container label by its key (default [])
--endpoint-mode string Endpoint mode (vip or dnsrr)
--env-add value Add or update environment variables (default [])
--env-rm value Remove an environment variable (default [])
--help Print usage
--image string Service image tag
--label-add value Add or update service labels (default [])
--label-rm value Remove a label by its key (default [])
--limit-cpu value Limit CPUs (default 0.000)
--limit-memory value Limit Memory (default 0 B)
--log-driver string Logging driver for service
--log-opt value Logging driver options (default [])
--mount-add value Add or update a mount on a service
--mount-rm value Remove a mount by its target path (default [])
--name string Service name
--publish-add value Add or update a published port (default [])
--publish-rm value Remove a published port by its target port (default [])
--replicas value Number of tasks (default none)
--reserve-cpu value Reserve CPUs (default 0.000)
--reserve-memory value Reserve Memory (default 0 B)
--restart-condition string Restart when condition is met (none, on-failure, or any)
--restart-delay value Delay between restart attempts (default none)
--restart-max-attempts value Maximum number of restarts before giving up (default none)
--restart-window value Window used to evaluate the restart policy (default none)
--stop-grace-period value Time to wait before force killing a container (default none)
--update-delay duration Delay between updates
--update-failure-action string Action on update failure (pause|continue) (default &amp;quot;pause&amp;quot;)
--update-parallelism uint Maximum number of tasks updated simultaneously (0 to update all at once) (default 1)
-u, --user string Username or UID
--with-registry-auth Send registry authentication details to swarm agents
-w, --workdir string Working directory inside the container
&lt;/code>&lt;/pre></description></item><item><title>Docs: 离线安装kubernetes</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/kuberbetes-1.5-%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/kuberbetes-1.5-%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>虽然距离当前主流版本已经差之千里，但其中的思想仍记得借鉴。&lt;/p>
&lt;/div>
&lt;p>经常遇到全新初始安装k8s集群的问题，所以想着搞成离线模式，本着最小依赖原则，提高安装速度&lt;/p>
&lt;p>基于Centos7-1511-minimal, 非此版本脚本应该会运行出错，自行修改吧&lt;/p>
&lt;p>本离线安装所有的依赖都打包放到了&lt;a href="https://pan.baidu.com/s/1i5jusip">百度网盘&lt;/a>&lt;/p>
&lt;p>为了便于维护，已建立独立项目&lt;a href="https://github.com/xiaoping378/k8s-deploy">k8s-deploy&lt;/a>&lt;/p>
&lt;h2 id="第一步">第一步&lt;/h2>
&lt;p>基本思路是，在k8s-deploy目录下，临时启个http server， node节点上会从此拉取所依赖镜像和rpms&lt;/p>
&lt;pre tabindex="0">&lt;code># python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 ...
&lt;/code>&lt;/pre>&lt;p>windows上可以用hfs临时启个http server， 自行百度如何使用&lt;/p>
&lt;h2 id="master侧">master侧&lt;/h2>
&lt;p>运行以下命令，初始化master&lt;/p>
&lt;p>192.168.56.1:8000 是我的http-server, 注意要将k8s-deploy.sh 里的HTTP-SERVER变量也改下&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -L http://192.168.56.1:8000/k8s-deploy.sh | bash -s master
&lt;/code>&lt;/pre>&lt;h2 id="minion侧">minion侧&lt;/h2>
&lt;p>视自己的情况而定&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -L http://192.168.56.1:8000/k8s-deploy.sh | bash -s join --token=6669b1.81f129bc847154f9 192.168.56.100
&lt;/code>&lt;/pre>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>整个脚本实现比较简单， 坑都在脚本里解决了。脚本文件在&lt;a href="https://gist.github.com/xiaoping378/3a129aa6c81eaecae199a50236ad8bf7">这里&lt;/a>&lt;/p>
&lt;p>就一个master-up和node-up， 基本一个函数只做一件事，很清晰，可以自己查看具体过程。&lt;/p>
&lt;p>1.5 与 1.3给我感觉最大的变化是网络部分， 1.5启用了cni网络插件
不需要像以前一样非要把flannel和docker绑在一起了（先启flannel才能启docker）。&lt;/p>
&lt;p>具体可以看这里
&lt;a href="https://github.com/containernetworking/cni/blob/master/Documentation/flannel.md">https://github.com/containernetworking/cni/blob/master/Documentation/flannel.md&lt;/a>&lt;/p>
&lt;p>master侧如果是单核的话，会因资源不足， dns安装失败。&lt;/p></description></item><item><title>Docs: 自动托管markdown</title><link>https://xiaoping378.github.io/docs/1-site/actions_pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/1-site/actions_pages/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>利用github actions和pages实现自动更新托管内容。&lt;/p>
&lt;/div>
&lt;h2 id="项目仓库的名字由来">项目仓库的名字由来&lt;/h2>
&lt;p>本源码仓之所以起如此长的名字，完全是因为github pages的不成熟，不然会带个小尾巴：&lt;/p>
&lt;p>如果叫 &lt;em>blog&lt;/em>, github的托管页面的访问地址会是 &lt;em>xiaoping378.github.io/blog&lt;/em>，这也没什么，但会和hugo的&lt;a href="https://xiaoping378.github.io/docs/1-site/add_content/#%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">static机制&lt;/a>出现冲突。&lt;/p></description></item><item><title>Docs: 以太坊的truffle box开发实战</title><link>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-truffle-box%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-truffle-box%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</guid><description>
&lt;p>整个过程主要演示chrome扩展 METAMASK， OpenZepplin库和truffle框架的使用。&lt;/p>
&lt;h3 id="搭建私连网络">搭建私连网络&lt;/h3>
&lt;p>主要参考之前的&lt;a href="../%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5">以太坊-私有链搭建初步实践&lt;/a>， 这里只用单节点的网络。&lt;/p>
&lt;p>还是先准备账户：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">mkdir node0
&lt;span style="color:#080;font-style:italic"># 会在node0/keystore目录里生成一个keyfile json文件&lt;/span>
geth --datadir node0 account new
&lt;span style="color:#080;font-style:italic">#利用puppeth生成genesis.json的过程不表，参考上边的链接&lt;/span>
geth --datadir node0 init genesis.json
&lt;span style="color:#080;font-style:italic"># 把刚才的账号的密码写入node0/password文件&lt;/span>
&lt;span style="color:#080;font-style:italic"># 启动私链，顺便开启console&lt;/span>
&lt;span style="color:#a2f">echo&lt;/span> node0 &amp;gt; node0/password
geth --datadir node0 --port &lt;span style="color:#666">30000&lt;/span> --nodiscover --unlock &lt;span style="color:#b44">&amp;#39;0&amp;#39;&lt;/span> --password ./node0/password --mine --rpc --rpccorsdomain &lt;span style="color:#b44">&amp;#34;*&amp;#34;&lt;/span> --rpcapi &lt;span style="color:#b44">&amp;#34;eth,net,web3,admin,personal&amp;#34;&lt;/span> console
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们把这个账号的json文件导入到chorme插件metamask里，便于后面调试和演示&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethereum-new-account.png" alt="">&lt;/p>
&lt;p>ubuntu系统上的chrome插件会有窗口消失的bug，在URL栏里打开&lt;code>chrome-extension://nkbihfbeogaeaoehlefnkodbefgpgknn/popup.html&lt;/code>&lt;/p>
&lt;h3 id="truflle初始化项目">truflle初始化项目&lt;/h3>
&lt;p>需要下载truffle命令号&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">npm install -g truffle
mkdir token &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a2f">cd&lt;/span> token
&lt;span style="color:#080;font-style:italic"># 利用trulle下载token代笔示例&lt;/span>
truffle unbox tutorialtoken
npm intall zeppelin-solidity
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上必要的依赖框架和库已经下载到了本地， 接下来就创建自己的代币合约&lt;/p>
&lt;p>在contract目录创建TutorialToken.sol文件，内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">pragma solidity &lt;span style="color:#666">^&lt;/span>&lt;span style="color:#666">0.4&lt;/span>.&lt;span style="color:#666">11&lt;/span>;
&lt;span style="color:#a2f;font-weight:bold">import&lt;/span> &lt;span style="color:#b44">&amp;#39;zeppelin-solidity/contracts/token/StandardToken.sol&amp;#39;&lt;/span>;
&lt;span style="color:#080;font-style:italic">/**
&lt;/span>&lt;span style="color:#080;font-style:italic"> * @title SimpleToken
&lt;/span>&lt;span style="color:#080;font-style:italic"> * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.
&lt;/span>&lt;span style="color:#080;font-style:italic"> * Note they can later distribute these tokens as they wish using `transfer` and other
&lt;/span>&lt;span style="color:#080;font-style:italic"> * `StandardToken` functions.
&lt;/span>&lt;span style="color:#080;font-style:italic"> */&lt;/span>
contract TutorialToken is StandardToken {
string &lt;span style="color:#a2f;font-weight:bold">public&lt;/span> name &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#b44">&amp;#34;TutorialToken&amp;#34;&lt;/span>;
string &lt;span style="color:#a2f;font-weight:bold">public&lt;/span> symbol &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#b44">&amp;#34;SIM&amp;#34;&lt;/span>;
uint256 &lt;span style="color:#a2f;font-weight:bold">public&lt;/span> decimals &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">18&lt;/span>;
uint256 &lt;span style="color:#a2f;font-weight:bold">public&lt;/span> INITIAL_SUPPLY &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">10000&lt;/span>;
&lt;span style="color:#080;font-style:italic">/**
&lt;/span>&lt;span style="color:#080;font-style:italic"> * @dev Contructor that gives msg.sender all of existing tokens.
&lt;/span>&lt;span style="color:#080;font-style:italic"> */&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">function&lt;/span> TutorialToken() {
totalSupply &lt;span style="color:#666">=&lt;/span> INITIAL_SUPPLY;
balances[msg.sender] &lt;span style="color:#666">=&lt;/span> INITIAL_SUPPLY;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在以太坊里几乎所有操作都是当做交易来看的，部署合约就是一种交易，交易就要花钱(gas消耗)，所以truffle做的是增量部署（少消耗gas），现在在&lt;code>migrations&lt;/code>目录添加新的部署文件&lt;code>2_deploy_contracts.js&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a2f;font-weight:bold">var&lt;/span> TutorialToken &lt;span style="color:#666">=&lt;/span> artifacts.require(&lt;span style="color:#b44">&amp;#34;./TutorialToken.sol&amp;#34;&lt;/span>);
module.exports &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#a2f;font-weight:bold">function&lt;/span>(deployer) {
deployer.deploy(TutorialToken);
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>一切准备就绪，编译，部署开始：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 编译&lt;/span>
➜ truffle compile
Compiling ./contracts/Migrations.sol...
Compiling ./contracts/TutorialToken.sol...
Compiling zeppelin-solidity/contracts/math/SafeMath.sol...
Compiling zeppelin-solidity/contracts/token/BasicToken.sol...
Compiling zeppelin-solidity/contracts/token/ERC20.sol...
Compiling zeppelin-solidity/contracts/token/ERC20Basic.sol...
Compiling zeppelin-solidity/contracts/token/StandardToken.sol...
Writing artifacts to ./build/contracts
&lt;span style="color:#080;font-style:italic"># 根据truffle.js的配置进行部署&lt;/span>
➜ truffle migrate
Using network &lt;span style="color:#b44">&amp;#39;development&amp;#39;&lt;/span>.
Running migration: 1_initial_migration.js
Deploying Migrations...
... 0x65ccd2d6a4f4248466dd7887da7a2ac35d18c7ab0ec826cb25580bc785a2c3b8
Migrations: 0xc64569558f90302f4b3884929ac5540c645674dc
Saving successful migration to network...
... 0xf9043ca886d352f05a05642047f63eed11d9b328fb815becc68baffc4d953d60
Saving artifacts...
Running migration: 2_deploy_contracts.js
Deploying TutorialToken...
... 0x19350625474c36316046b103e671eaad45834a60c17a5b9c64cf96316754560f
TutorialToken: 0x7f469dc1ec17c3b7c52a3ad74611cb4b7e6807e1
Saving successful migration to network...
... 0xe57ba56dd5f1b18d410577def8bc7089f7de56e8d8718c3098430995d4b81353
Saving artifacts...
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Github开源项目的正确贡献姿势</title><link>https://xiaoping378.github.io/docs/3-devops/github-dev/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/github-dev/</guid><description>
&lt;p>常见的开源项目贡献指导里都是差不多的样子：&lt;/p>
&lt;pre>&lt;code>* 要先fork
* 然后change something
* 再然后fetch，rebase
* push origin， 最后发起pull request
&lt;/code>&lt;/pre>
&lt;p>具体到不同的项目，可能会要求更多的细节步骤,但大体如上。&lt;/p>
&lt;p>这些都没错，但实际操作起来，和习惯不符。因为我一般是先clone一个项目，然后使用中发现有问题，会尝试去修改，fix OK的话，才会想着去贡献代码
可事情到了这一步，再按照一开始的方式操作，会平白无辜耗费很多时间，还涉及到已经修改完代码如何同步过去的问题。
以下是我个人总结的一套方法，屡试不爽乎。&lt;/p>
&lt;p>这里我以k8s项目的贡献经历来举例，以备不时之需。git这个东西，不常用，会忘记的，即使你已经理解原理了。。。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先clone K8s的项目代码。&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone https://github.com/kubernetes/kubernetes.git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>然后自行编译 &lt;strong>make&lt;/strong>, 使用中发现一些问题&lt;/p>
&lt;p>就会去github的issue里找找看。。。竟然没人提这个问题，问问同事或同行，人家表示没碰到过你的问题，
好吧，自己尝试去修改... 不断编译 ... 测试... 最终OK了，我要贡献代码！！！
完啦，没有按照最佳习惯来，改动前忘记新建分支了。。。（这个习惯很重要，可以省掉很多麻烦）
只能如此操作了，可以来个大挪移到新建分支上&lt;/p>
&lt;pre tabindex="0">&lt;code>git stash
git checkout -b fix_something
git stash apply
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>此时去github上fork下原项目，拿到fork后的项目地址，再来个偷天换日。&lt;/p>
&lt;pre tabindex="0">&lt;code>git remote rename origin upstream
git remote add origin git@github.com:xiaoping378/kubernetes.git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>再然后就可以按一开始介绍的，fetch, rebase, push origin, 发起PR了。&lt;/p>
&lt;pre tabindex="0">&lt;code>git fetch upstream
git rebase upstream/master
# 有冲突就git mergetool
git push origin fix_something
# 然后去github页面发起pull request即可。
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>注意事项
值的注意的是，以后在master分支上&lt;strong>git pull&lt;/strong>，就是从upstream/master那里拉取的，和一般情况不一样的地方。
这样会少了烦人的merge msg（-ff可以解决）， 还可以用简单的pull来同步上游代码。
更可以意淫自己是原项目的核心开发人员了。。。
以后本地同步fork的项目到上游的最新状态，这样操作：&lt;/p>
&lt;pre tabindex="0">&lt;code>git checkout master
git pull
git push origin master
&lt;/code>&lt;/pre>&lt;p>其实github上那个fork的项目，只是用来提PR的，这样可以在原项目的分支上任意玩耍了。当然你也可以用来备份一些比较大的feature&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后记录下个人的git global配置&lt;/p>
&lt;pre tabindex="0">&lt;code># cat ~/.gitconfig
[user]
email = xiaoping378@163.com
name = xiaoping378
[merge]
tool = meld
[push]
default = simple
[core]
quotepath = false
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul></description></item><item><title>Docs: k8s的各组件认知</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/k8s%E5%90%84%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%A4%E7%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/k8s%E5%90%84%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%A4%E7%9F%A5/</guid><description>
&lt;h3 id="flannel">flannel&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>flannel的设计就是为集群中所有节点能重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，
并让属于不同节点上的容器能够直接通过内网IP通信。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>实际上就是给每个节点的docker重新设置容器上可分配的IP段， &lt;code>--bip&lt;/code>的妙用。
这恰好迎合了k8s的设计，即一个pod（container）在集群中拥有唯一、可路由到的IP，带来的好处就是减少跨主机容器间通信要port mapping的复杂性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原理&lt;/p>
&lt;ul>
&lt;li>flannle需要运行一个叫flanned的agent，其用etcd来存储网络配置、已经分配的子网、和辅助信息（主机IP),如下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#666">[&lt;/span>root@master1 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic"># etcdctl ls /coreos.com/network&lt;/span>
/coreos.com/network/config
/coreos.com/network/subnets
&lt;span style="color:#666">[&lt;/span>root@master1 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic">#&lt;/span>
&lt;span style="color:#666">[&lt;/span>root@master1 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic"># etcdctl get /coreos.com/network/config&lt;/span>
&lt;span style="color:#666">{&lt;/span>&lt;span style="color:#b44">&amp;#34;Network&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;172.16.0.0/16&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>
&lt;span style="color:#666">[&lt;/span>root@master1 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic">#&lt;/span>
&lt;span style="color:#666">[&lt;/span>root@master1 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic"># etcdctl ls /coreos.com/network/subnets&lt;/span>
/coreos.com/network/subnets/172.16.29.0-24
/coreos.com/network/subnets/172.16.40.0-24
/coreos.com/network/subnets/172.16.60.0-24
&lt;span style="color:#666">[&lt;/span>root@master1 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic">#&lt;/span>
&lt;span style="color:#666">[&lt;/span>root@master1 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic"># etcdctl get /coreos.com/network/subnets/172.16.29.0-24&lt;/span>
&lt;span style="color:#666">{&lt;/span>&lt;span style="color:#b44">&amp;#34;PublicIP&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;192.168.1.129&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>flannel0 还负责解封装报文,或者创建路由。
flannel有多种方式可以完成报文的转发。&lt;/p>
&lt;ul>
&lt;li>UDP&lt;/li>
&lt;li>vxlan&lt;/li>
&lt;li>host-gw&lt;/li>
&lt;li>aws-vpc&lt;/li>
&lt;li>gce&lt;/li>
&lt;li>alloc&lt;/li>
&lt;/ul>
&lt;p>下图是经典的UDP封装方式数据流图
&lt;img src="https://xiaoping378.github.io/flannel-packet-01.png" alt="UDP">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: 构建生产环境级的docker Swarm集群-3</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-sarm3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-sarm3/</guid><description>
&lt;p>如前文所述，默认已经搭建好环境，基于docker1.12版本。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#666">[&lt;/span>root@manager0 ~&lt;span style="color:#666">]&lt;/span>&lt;span style="color:#080;font-style:italic"># docker node ls&lt;/span>
ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS
0bbmd3r7aphs374qaea4zcieo node2 Ready Active
3qmxzyauc0bz4kjqvld9uogz5 manager1 Ready Active Reachable
5ewbdtvaopj4ltwqx0a4i65nt * manager0 Ready Drain Leader
5oxxpgk69fnwe5w210kovrqi9 node1 Ready Active
7s1ilay2wkjgt09bp2z0743m7 node0 Ready Active
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>创建第一个服务，以redis为例
swarm里容器间通信需要使用overlay模式，所以需要提前建立一个&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker network create -d overlay --subnet 10.254.0.0/16 --gateway 10.254.0.1 mynet1
docker service create --name redis --network mynet1 redis
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>在manager上查看服务部署情况&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>[root@manager0 ~]# docker service ps redis
ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR
9avksjfqr2gxm413dfrezrmgr redis.1 redis node1 Running Running 17 seconds ago
&lt;/code>&lt;/pre>&lt;p>实例里，同样可以去node1上用&lt;code>docker ps&lt;/code>查看&lt;/p>
&lt;p>以上只是最基本的集群创建服务的用法，从中可见，swarm的的调度基本单元是task, 没有pod的概念，一个task可以简单理解成一个docker run的结果。目前swarm里也不支持compose。&lt;/p>
&lt;p>docker官方称，以后会支持vm、pod的调度单元，具体日期未知。&lt;/p>
&lt;ol start="3">
&lt;li>服务调度策略&lt;/li>
&lt;/ol>
&lt;p>使用&lt;code>docker service create&lt;/code>创建服务， 这其中选择再哪个节点部署，docker 提供了三种调度策略；&lt;/p>
&lt;ul>
&lt;li>spread: 默认策略，尽量均匀分布，找容器数少的结点调度&lt;/li>
&lt;li>binpack: 和spread相反，尽量把一个结点占满再用其他结点&lt;/li>
&lt;li>random: 随机&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>服务的高可用和load-balance&lt;/li>
&lt;/ol>
&lt;p>通过&lt;code>--replicas&lt;/code>参数可以设置服务容器的数量，已达到高可用状态；&lt;/p>
&lt;pre tabindex="0">&lt;code>#创建多副本
docker service update --replicas 4 redis
#查看副本部署情况
[root@manager0 ~]# docker service ps redis
ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR
9avksjfqr2gxm413dfrezrmgr redis.1 redis node1 Running Running 13 minutes ago
0olv1sfz6d79wdnorw7jgoyri redis.2 redis manager1 Running Running about a minute ago
f3n6deesjlkxu4k48lzabieus redis.3 redis node2 Running Preparing 3 minutes ago
80bzarvkiytpv1690sla6unt2 redis.4 redis node0 Running Running about a minute ago
#验证多可用， 总共4个副本，docker内置的DNS服务会默认使用round-robin调度策略来解析主机。
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&amp;gt; set user 1
OK
redis:6379&amp;gt; exit
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&amp;gt; get user
(nil)
redis:6379&amp;gt; set user 2
OK
redis:6379&amp;gt; exit
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&amp;gt; get user
(nil)
redis:6379&amp;gt; set user 3
OK
redis:6379&amp;gt; exit
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&amp;gt; get user
(nil)
redis:6379&amp;gt; set user 4
OK
redis:6379&amp;gt; exit
root@9ed77b4b4432:/data# redis-cli -h redis
redis:6379&amp;gt; get user
&amp;quot;1&amp;quot;
redis:6379&amp;gt;
&lt;/code>&lt;/pre></description></item><item><title>Docs: 混合云网络SDN</title><link>https://xiaoping378.github.io/docs/4-cloud/%E6%B7%B7%E5%90%88%E4%BA%91sdn%E9%80%89%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/%E6%B7%B7%E5%90%88%E4%BA%91sdn%E9%80%89%E5%9E%8B/</guid><description>
&lt;ul>
&lt;li>TODO.&lt;/li>
&lt;/ul>
&lt;h3 id="为什么需要sdn">为什么需要SDN&lt;/h3>
&lt;ul>
&lt;li>网络可编程&lt;/li>
&lt;li>VPC（Virtual Private Cloud）&lt;/li>
&lt;/ul>
&lt;h3 id="现有sdn方案">现有SDN方案&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>硬件方案（软件定义，硬件实现）&lt;/p>
&lt;ul>
&lt;li>主流网络设备厂商有各自实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>软件方案（NFV）&lt;/p>
&lt;ul>
&lt;li>VMWare NSX, Juniper OpenContrail, OpenStack DVR...&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="业务需求">业务需求&lt;/h3>
&lt;ul>
&lt;li>用户网络隔离 - 多租户&lt;/li>
&lt;li>保证中等流量规模的高性能低延迟&lt;/li>
&lt;li>适应复杂异构的基础架构（混合云-- kubernetes，虚机，裸机）&lt;/li>
&lt;li>端点迁移，IP不变&lt;/li>
&lt;li>负载均衡（L2/L3）&lt;/li>
&lt;li>端到端流量精细ACL&lt;/li>
&lt;li>可API控制&lt;/li>
&lt;li>运维监控（包，字节流）&lt;/li>
&lt;/ul>
&lt;h3 id="方案选型">方案选型&lt;/h3>
&lt;ul>
&lt;li>成本&lt;/li>
&lt;li>设备依赖&lt;/li>
&lt;/ul>
&lt;h3 id="开源方案">开源方案&lt;/h3>
&lt;p>各开源SDN方案对比：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>flannel vxlan:
不具备网络隔离功能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OpenShift SDN:&lt;/p>
&lt;p>基于vxlan利用ovs-multienant可实现基于项目的网络隔离，和flannel vxlan相比，其使用的ovs-subnet插件，数据流场景大体一致，容器向外网发包也使用的NAT。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Calico:&lt;/p>
&lt;p>支持混合云，安全加密，
纯3层的路由实现保证了性能和低延迟
支持了网络隔离和ACL
但存在目前只支持TCP、UDP、ICMP、ICMPv6协议，四层协议不支持。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OpenStack Neutron&lt;/p>
&lt;p>支持网络隔离
性能和低延迟 -- 需要优化
支持多租户
基于ML2支持混合云方案 -- kubernetes的支持需要第三方的kubestack项目
虚机迁移，IP可不变，容器迁移，IP不变 -- 需要开发
支持负载均衡LBaaS
支持精细级的ACL
API ?
可运维监控基本数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OpenContrail&lt;/p>
&lt;p>&lt;strong>完全满足我们的网络需求&lt;/strong>, 值得深入研究&lt;/p>
&lt;p>Juniper开源的SDN &amp;amp; NFV方案&lt;/p>
&lt;p>已经集成支持OpenStack, VMware, Docker 和 Kubernetes.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="各大厂商公开资料">各大厂商公开资料&lt;/h3>
&lt;ul>
&lt;li>网易蜂巢： VxLAN, 基于Openstack Neutron&lt;/li>
&lt;li>待补充...&lt;/li>
&lt;/ul></description></item><item><title>Docs: 编写文章注意项</title><link>https://xiaoping378.github.io/docs/1-site/add_content/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/1-site/add_content/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>本章节主要描述日常编写文章的注意事项和docsy主题内的使用技巧。&lt;/p>
&lt;/div>
&lt;h2 id="编写markdown">编写markdown&lt;/h2>
&lt;h3 id="图片路径问题">图片路径问题&lt;/h3>
&lt;p>习惯md文件中的图片路径写成&lt;code>![](/images/file.png)&lt;/code> ，但hugo中图片实际要存放到&lt;code>/static/images/&lt;/code>路径下，hugo会自动渲染到站点的根路径&lt;code>/&lt;/code>上。&lt;/p>
&lt;p>这样的话，无法在编辑器中预览md了，有两种玩法如下：&lt;/p>
&lt;ul>
&lt;li>可以使用一个临时目录，把图片和md文件放到同一目录，编写完毕后，再把图片和md文件放置上述合适的目录位置上。&lt;/li>
&lt;li>日常一直启用&lt;code>hugo server&lt;/code>编写文章，放弃编辑器中预览md，后面还会有别的坑....&lt;/li>
&lt;/ul>
&lt;p>推荐后者，本人日常使用VSCode编写md，和代码开发同款，这里推荐安装&lt;code>mushan.vscode-paste-image&lt;/code>扩展，再额外如下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json"> &lt;span style="color:#b44">&amp;#34;pasteImage.namePrefix&amp;#34;&lt;/span>&lt;span style="">:&lt;/span> &lt;span style="color:#b44">&amp;#34;${currentFileNameWithoutExt}-&amp;#34;&lt;/span>&lt;span style="">,&lt;/span>
&lt;span style="color:#b44">&amp;#34;pasteImage.path&amp;#34;&lt;/span>&lt;span style="">:&lt;/span> &lt;span style="color:#b44">&amp;#34;${projectRoot}/static/images/&amp;#34;&lt;/span>&lt;span style="">,&lt;/span>
&lt;span style="color:#b44">&amp;#34;pasteImage.basePath&amp;#34;&lt;/span>&lt;span style="">:&lt;/span> &lt;span style="color:#b44">&amp;#34;${projectRoot}&amp;#34;&lt;/span>&lt;span style="">,&lt;/span>
&lt;span style="color:#b44">&amp;#34;pasteImage.insertPattern&amp;#34;&lt;/span>&lt;span style="">:&lt;/span> &lt;span style="color:#b44">&amp;#34;${imageSyntaxPrefix}/images/${imageFileName}${imageSyntaxSuffix}&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>日常编写文章，&lt;code>Alt+A&lt;/code>截图，&lt;code>Ctrl+Alt+A&lt;/code>粘贴到md文件，和hugo的配合，完美...&lt;/p>
&lt;h3 id="seo优化关注点">SEO优化关注点&lt;/h3>
&lt;p>日常文章编写，如下部分要精准描述，Google搜索引擎推荐使用&lt;code>description&lt;/code>的meta标签告诉它页面内容的，Docsy主题会自动把红框部分填充到&lt;code>layouts/partials/head.html&lt;/code>中。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/images/add_content-2022-01-25-09-38-48.png" alt="">&lt;/p>
&lt;p>hugo解析编译后，html页面会如下呈现：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/images/add_content-2022-01-25-09-37-12.png" alt="">&lt;/p>
&lt;h3 id="日常编写注意事项">日常编写注意事项&lt;/h3>
&lt;h4 id="md文件中相互引用内容的路径要记得对应到站点html的路径上">md文件中相互引用内容的路径要记得对应到站点html的路径上&lt;/h4>
&lt;p>比如此处引用&lt;code>自动托管markdown&lt;/code>文章，按照md习惯写,虽然编辑器上可以正常打开，但hugo渲染后的页面是404的。&lt;/p>
&lt;ul>
&lt;li>&lt;code>[引用](./actions_pages.md)&lt;/code> 需要改成 &lt;code>[引用](../actions_pages)&lt;/code>&lt;/li>
&lt;li>&lt;code>[引用](/content/docs/1-site/actions_pages.md)&lt;/code> 需要改成 &lt;code>[引用](/docs/1-site/actions_pages)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>不定时更新注意事项。日常编写，建议本机启用&lt;code>hugo server&lt;/code>实时预览，&lt;/p>
&lt;h4 id="文章weight的使用">文章weight的使用&lt;/h4>
&lt;p>文章开头的&lt;code>weight&lt;/code>部分决定了目录中的排序，推荐新开的系列文章，从两位数开始递增，比如&lt;code>30&lt;/code>, 以后老系列有更新的时候，免去批量修改调整排序的麻烦。&lt;/p></description></item><item><title>Docs: 项目开发实战</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</guid><description>
&lt;p>下面的所有操作，都可以通过cli，web console，RestFul API实现，默认使用cli说明&lt;/p>
&lt;h3 id="创建项目">创建项目&lt;/h3>
&lt;p>这里是接着oc cluster up后，来说的， 默认&lt;code>oc whoami&lt;/code>是 developer,拥有admin的Role角色，俗称项目经理（管理员）&lt;/p>
&lt;ol>
&lt;li>删除默认创建的项目，并创建一个实际中的项目&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">oc delete project myproject
oc new-project eshop --display-name&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;电商项目&amp;#34;&lt;/span> --description&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;一个神奇的网站&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在项目管理员可以创建任意多个项目，从前面的源码可以看到目前是没法针对项目管理员去限制可创建项目上限的。&lt;/p>
&lt;ol start="2">
&lt;li>查看项目状态&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>#oc status
In project 电商项目 (eshop) on server https://192.168.31.49:8443
You have no services, deployment configs, or build configs.
Run 'oc new-app' to create an application.
&lt;/code>&lt;/pre>&lt;p>空空如也，有提示语句提示可通过&lt;code>oc new-app&lt;/code>去创建具体应用的&lt;/p>
&lt;h3 id="创建应用">创建应用&lt;/h3>
&lt;p>前面也说过，openshift的核心就是围绕应用的整个生命周期来的，所以从new-app说起&lt;/p>
&lt;p>new-app的入口是&lt;code>NewCmdNewApplication()&lt;/code>, 大部分实现是 &lt;code>func (c *AppConfig) Run() (*AppResult, error)&lt;/code> 感兴趣的可以根据源码来理解openshift的devops理念。&lt;/p>
&lt;ol>
&lt;li>创建应用的方式
现在可以通过3种方式（源码， docker镜像， 模板）来创建一个应用。&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code># oc new-app -h
#此处省略。。。
Usage:
oc new-app (IMAGE | IMAGESTREAM | TEMPLATE | PATH | URL ...) [options]
#此处省略。。。
&lt;/code>&lt;/pre>&lt;p>有很多灵活简便的方式来创建应用，甚至可以直接&lt;code>oc new-app mysql&lt;/code>来创建一个mysql服务&lt;/p>
&lt;p>比如下面的例子，是基于nodejs-ex项目的master分支，创建应用&lt;/p>
&lt;pre tabindex="0">&lt;code>oc new-app https://github.com/xiaoping378/nodejs-ex.git#master
&lt;/code>&lt;/pre>&lt;p>接着上面的nodejs-ex项目来说， 实际上，&lt;code>oc new-app&lt;/code>就做了两件事，先build， 再deploy。&lt;/p>
&lt;p>new-app一般会先创建一个bc, bc会产出一个iamge，new-app典型的还会创建一个dc，去部署新生成的image，也会创建相应的service来负载均衡方访问刚部署上的镜像里的业务。&lt;/p>
&lt;p>这一切都是自动完成的，因为openshift origin里面有一些检测机制和默认规则，下面就针对上面那条命令看看内部都发生了什么&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先openshift会执行 &lt;code>git ls-remote&lt;/code>， 来查看此项目的所有remote分支，&lt;/p>
&lt;p>如果存在master分支，下一步则直接clone和checkout了&lt;/p>
&lt;p>checkout后，接着就是根据解析规则来定义如何build了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>build策略&lt;/p>
&lt;p>首先会探测nodejs-ex项目根目录下，是否有dockerfile或者jenkinsfile，如果两者都没有则会根据“典型文件”判断这个项目的开发语言， 举例&lt;/p>
&lt;p>如果存在app.json或者package.json文件，则认为是nodejs类型的项目， 更多的典型文件如下：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/new-app-detector.png" alt="detector">&lt;/p>
&lt;p>这部分的代码实现主要在 detector.go&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>未完，待续。。。&lt;/p></description></item><item><title>Docs: fomo3d-上线部署要点</title><link>https://xiaoping378.github.io/docs/5-blockchain/fomo3d-%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2%E8%A6%81%E7%82%B9/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/fomo3d-%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2%E8%A6%81%E7%82%B9/</guid><description>
&lt;p>fomo3d游戏一出，国内疯狂clone上线，这里谈下我上线的思路和部署方法（纯手动的^_^，落伍了）&lt;/p>
&lt;p>通过&lt;a href="https://etherscan.io/address/0xa62142888aba8370742be823c1782d17a0389da1#code">原版合约地址&lt;/a>，可以一层一层的拔下所有涉及到的合约代码。&lt;/p>
&lt;p>目前据我统计共有8个合约，其中有两个闭源合约：&lt;/p>
&lt;ul>
&lt;li>F3DexternalSettingsInterface&lt;/li>
&lt;li>JIincInterfaceForForwarder&lt;/li>
&lt;/ul>
&lt;p>闭源合约不可怕，看明白什么功能，自己hack掉是不影响游戏本身的。&lt;/p>
&lt;pre>&lt;code>提前预警，合约的内容细节还是要自己研究的，没时间写太细，
&lt;/code>&lt;/pre>
&lt;p>其实这个游戏本身只需要2个合约就可以跑起来，且没实质影响，只是单纯改变了部分利益分配方式。&lt;/p>
&lt;p>下面说明，我尽可能少改动原版的情况下，部署上线合约，移除p3d修改后的原版合约代码&lt;a href="https://github.com/ChungkueiBlock/fomo3d/tree/master/sols">在这里&lt;/a>&lt;/p>
&lt;h2 id="部署前的准备">部署前的准备&lt;/h2>
&lt;p>我一般使用&lt;a href="https://remix.ethereum.org/#optimize=true&amp;amp;version=soljson-v0.4.24">在线remix&lt;/a>工具部署合约在自己的私链上调试，私链建议如下启动（一键解万忧的方式，推荐创世块采用&lt;a href="https://github.com/ChungkueiBlock/tools/tree/master/privateEth">POA共识&lt;/a>-不消耗CPU），这样可以使用remix的debug功能&lt;/p>
&lt;pre tabindex="0">&lt;code>geth \
--datadir ./node0\
--ws\
--wsaddr 0.0.0.0\
--wsapi &amp;quot;eth,net,web3,admin,personal,txpool,miner,clique,debug&amp;quot;\
--wsport 8546\
--wsorigins &amp;quot;*&amp;quot;\
--rpc\
--rpcapi &amp;quot;eth,net,web3,admin,personal,txpool,miner,clique,debug&amp;quot;\
--rpccorsdomain &amp;quot;*&amp;quot;\
--rpcaddr 0.0.0.0\
--rpcport 8545\
--rpcvhosts &amp;quot;*&amp;quot;\
--mine\
--etherbase 0xdbeb69c655b666b3e17b8061df7ea4cc2399df11\
--unlock 0xdbeb69c655b666b3e17b8061df7ea4cc2399df11\
--password ./password\
--nodiscover\
--maxpeers '50'\
--networkid 378\
--targetgaslimit 471238800\
&amp;amp;
&lt;/code>&lt;/pre>&lt;h2 id="部署合约">部署合约&lt;/h2>
&lt;p>按先后顺序如下部署&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/ChungkueiBlock/sols/blob/master/fomo3d/Hourglass.sol">p3d合约&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>真心不推荐部署带有p3d合约的游戏，这样项目方就可以吃掉本来要流到这里25%左右的流水资金了&lt;/p>
&lt;p>我对p3d的合约内容还没有很深的研究，只知道它&lt;/p>
&lt;ul>
&lt;li>是一个自带“交易所”、发行总量为0的Token，&lt;/li>
&lt;li>通过Eth买入会自动增发，卖出会销毁&lt;/li>
&lt;li>买入和卖出都会扣掉10%的费用给仍持有Token的人&lt;/li>
&lt;li>每买一次都会使Token升值&lt;/li>
&lt;li>每卖一次会使Token降价&lt;/li>
&lt;/ul>
&lt;p>这个合约不需要改动，贴源码，编译后部署截图如下，点击红色记录下来部署后的合约地址&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/p3d%E9%83%A8%E7%BD%B2.jpg" alt="p3d">&lt;/p>
&lt;ol>
&lt;li>部署divies合约&lt;/li>
&lt;/ol>
&lt;p>这个合约专门往p3d持有者发分红的。&lt;/p>
&lt;p>把刚才记录的p3d合约地址，替换到&lt;code>HourglassInterface&lt;/code>后面的地址。如上贴源码，编译后部署&lt;code>Divies&lt;/code>合约，&lt;/p>
&lt;p>记录下divies的地址，并替换fomo3dlong.sol里的&lt;code>DiviesInterface&lt;/code>地址&lt;/p>
&lt;ol start="3">
&lt;li>&lt;del>部署JIincForwarder合约&lt;/del>&lt;/li>
&lt;/ol>
&lt;p>这个合约是管理流向社区2%的资金的，被fomo3dlong里调用，
这里需要hack，因为其中涉及到一个闭源的合约，既然知道它是管理2%资金流向的，那直接在fomo3dLong的合约如下hack&lt;/p>
&lt;ul>
&lt;li>把定义&lt;code>Jekyll_Island_Inc&lt;/code>的地方，直接定义成一个普通地址 &lt;code>address reward = 0xxxxxxx;&lt;/code>&lt;/li>
&lt;li>把调用Jekyll_Island_Inc的地方， 写成&lt;code>reward.transfer(_com);&lt;/code>， 注意有两个地方调用（都要换），一个是游戏进行时调用，一个是本轮结束后调用&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript"> &lt;span style="color:#080;font-style:italic">// // community rewards
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(&amp;#34;deposit()&amp;#34;))))
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// {
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// // This ensures Team Just cannot influence the outcome of FoMo3D with
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// // bank migrations by breaking outgoing transactions.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// // Something we would never do. But that&amp;#39;s not the point.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// // We spent 2000$ in eth re-deploying just to patch this, we hold the
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// // highest belief that everything we create should be trustless.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// // Team JUST, The name you shouldn&amp;#39;t have to trust.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// _p3d = _p3d.add(_com);
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// _com = 0;
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#080;font-style:italic">// }
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>
reward.transfer(_com);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以不需要部署这个合约，你只要想办法把流到这里的ETH，流到平台方就可以了。（流到开发者，我觉得也是可以的，哈哈～）&lt;/p>
&lt;ol start="4">
&lt;li>部署Team合约&lt;/li>
&lt;/ol>
&lt;p>这个合约利用多签技术限制了影响团队的操作，需要改的地方就是把这些地址全部换成自己的，&lt;/p>
&lt;p>把下面这些地址，改成你自己的地址，最好把&lt;code>deployer&lt;/code>地址写成你用来部署合约的那个地址，后面调用playbook合约的&lt;code>addGame&lt;/code>需要这里的权限&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">address inventor &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">0x18E90Fc6F70344f53EBd4f6070bf6Aa23e2D748C&lt;/span>;
address mantso &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">0x8b4DA1827932D71759687f925D17F81Fc94e3A9D&lt;/span>;
address justo &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">0x8e0d985f3Ec1857BEc39B76aAabDEa6B31B67d53&lt;/span>;
address sumpunk &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C&lt;/span>;
address deployer &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">0xF39e044e1AB204460e06E87c6dca2c6319fC69E3&lt;/span>;
admins_[inventor] &lt;span style="color:#666">=&lt;/span> Admin(&lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#b44">&amp;#34;inventor&amp;#34;&lt;/span>);
admins_[mantso] &lt;span style="color:#666">=&lt;/span> Admin(&lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#b44">&amp;#34;mantso&amp;#34;&lt;/span>);
admins_[justo] &lt;span style="color:#666">=&lt;/span> Admin(&lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#b44">&amp;#34;justo&amp;#34;&lt;/span>);
admins_[sumpunk] &lt;span style="color:#666">=&lt;/span> Admin(&lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#b44">&amp;#34;sumpunk&amp;#34;&lt;/span>);
admins_[deployer] &lt;span style="color:#666">=&lt;/span> Admin(&lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>, &lt;span style="color:#b44">&amp;#34;deployer&amp;#34;&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>改完后，如上贴源码，编译后部署&lt;code>TeamJust&lt;/code>合约，记录地址，替换playbook合约的&lt;code>TeamJustInterface&lt;/code>地址&lt;/p>
&lt;ol start="5">
&lt;li>部署playerBook合约&lt;/li>
&lt;/ol>
&lt;p>很有意思的合约，这里就是上面说的整个游戏其实只需要两个合约中的一个。
不解读细节了，直接改吧&lt;/p>
&lt;p>你会发现这里怎么还有个&lt;code>JIincForwarderInterface&lt;/code>地址，第三步不是说不部署这个了么 ？&lt;/p>
&lt;p>这里的主要是收取别人注册名字开启邀请返佣机制时需要支付的那0.01ETH的&lt;/p>
&lt;p>知道了这个，就跟第3步一样加个reward收款地址吧，细节不标&lt;/p>
&lt;p>如上贴源码，编译后部署&lt;code>PlayBook&lt;/code>合约，记录下地址， 替换fomo3d合约里的&lt;code>PlayerBookInterface&lt;/code>地址。&lt;/p>
&lt;ol start="6">
&lt;li>部署fomo3dLong合约&lt;/li>
&lt;/ol>
&lt;p>这个是另一个核心合约之一，这里也有个闭源合约，用来初始化控制时间的参数&lt;/p>
&lt;p>直接注释掉，然后如下改动&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">uint256 &lt;span style="color:#a2f;font-weight:bold">private&lt;/span> rndExtra_ &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">30&lt;/span>; &lt;span style="color:#080;font-style:italic">// 和rndInit一起控制第一轮游戏开始的初始时间的，单位是秒
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>uint256 &lt;span style="color:#a2f;font-weight:bold">private&lt;/span> rndGap_ &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">30&lt;/span>; &lt;span style="color:#080;font-style:italic">// 和rndInit一起控制下轮游戏开始的初始时间的，单位是秒
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有两个改动点就是&lt;code>activate&lt;/code>和&lt;code>setOtherFomo&lt;/code>里加上自己的deployer地址，&lt;/p>
&lt;p>额外把setOtherFomo里的往另一个游戏池子里输血的功能改到，因为我们没有其他的游戏，如第三步一样，换个收款码吧&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">otherF3D_.transfer(_long);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>部署吧！！！&lt;/p>
&lt;p>最后部署这一步，很有可能遇到&lt;code>errored: oversized data&lt;/code>的错误，刷新remix页面即可。&lt;/p>
&lt;h2 id="合约设置">合约设置&lt;/h2>
&lt;p>先setOtherFomo,然后再设置playbook里的addgame，最后activate即可。&lt;/p>
&lt;h2 id="页面">页面&lt;/h2>
&lt;p>页面直接Ctrl+s下载原版界面，把最后的fomo3dLong的合约地址替换下，另外那个后台API，其实没什么，自己试下就知道了，然后就可以上线了。。。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/fomo3d%E4%B8%8A%E7%BA%BF.png" alt="fomo3d上线">&lt;/p>
&lt;h1 id="感受">感受&lt;/h1>
&lt;ul>
&lt;li>合约debug难如上青天&lt;/li>
&lt;li>要替换一大堆合约里的地址，除了Interface类的要替成依赖的合约地址，其他的全可以写成你自己地址（即使都一样的也OK）就可以。&lt;/li>
&lt;/ul>
&lt;p>目前我们搞出来的定制版有：&lt;/p>
&lt;ul>
&lt;li>多级返佣模式， 可自定义级数&lt;/li>
&lt;li>空投fix版&lt;/li>
&lt;li>去除战队版&lt;/li>
&lt;li>移除p3d版本&lt;/li>
&lt;li>原版&lt;/li>
&lt;/ul></description></item><item><title>Docs: markdown语法</title><link>https://xiaoping378.github.io/docs/1-site/tutorial2/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/1-site/tutorial2/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>This is a placeholder page. Replace it with your own content.&lt;/p>
&lt;/div>
&lt;p>Text can be &lt;strong>bold&lt;/strong>, &lt;em>italic&lt;/em>, or &lt;del>strikethrough&lt;/del>. &lt;a href="https://gohugo.io">Links&lt;/a> should be blue with no underlines (unless hovered over).&lt;/p>
&lt;p>There should be whitespace between paragraphs. Vape migas chillwave sriracha poutine try-hard distillery. Tattooed shabby chic small batch, pabst art party heirloom letterpress air plant pop-up. Sustainable chia skateboard art party banjo cardigan normcore affogato vexillologist quinoa meggings man bun master cleanse shoreditch readymade. Yuccie prism four dollar toast tbh cardigan iPhone, tumblr listicle live-edge VHS. Pug lyft normcore hot chicken biodiesel, actually keffiyeh thundercats photo booth pour-over twee fam food truck microdosing banh mi. Vice activated charcoal raclette unicorn live-edge post-ironic. Heirloom vexillologist coloring book, beard deep v letterpress echo park humblebrag tilde.&lt;/p>
&lt;p>90's four loko seitan photo booth gochujang freegan tumeric listicle fam ugh humblebrag. Bespoke leggings gastropub, biodiesel brunch pug fashion axe meh swag art party neutra deep v chia. Enamel pin fanny pack knausgaard tofu, artisan cronut hammock meditation occupy master cleanse chartreuse lumbersexual. Kombucha kogi viral truffaut synth distillery single-origin coffee ugh slow-carb marfa selfies. Pitchfork schlitz semiotics fanny pack, ugh artisan vegan vaporware hexagon. Polaroid fixie post-ironic venmo wolf ramps &lt;strong>kale chips&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>There should be no margin above this first sentence.&lt;/p>
&lt;p>Blockquotes should be a lighter gray with a border along the left side in the secondary color.&lt;/p>
&lt;p>There should be no margin below this final sentence.&lt;/p>
&lt;/blockquote>
&lt;h2 id="first-header-2">First Header 2&lt;/h2>
&lt;p>This is a normal paragraph following a header. Knausgaard kale chips snackwave microdosing cronut copper mug swag synth bitters letterpress glossier &lt;strong>craft beer&lt;/strong>. Mumblecore bushwick authentic gochujang vegan chambray meditation jean shorts irony. Viral farm-to-table kale chips, pork belly palo santo distillery activated charcoal aesthetic jianbing air plant woke lomo VHS organic. Tattooed locavore succulents heirloom, small batch sriracha echo park DIY af. Shaman you probably haven't heard of them copper mug, crucifix green juice vape &lt;em>single-origin coffee&lt;/em> brunch actually. Mustache etsy vexillologist raclette authentic fam. Tousled beard humblebrag asymmetrical. I love turkey, I love my job, I love my friends, I love Chardonnay!&lt;/p>
&lt;p>Deae legum paulatimque terra, non vos mutata tacet: dic. Vocant docuique me plumas fila quin afuerunt copia haec o neque.&lt;/p>
&lt;p>On big screens, paragraphs and headings should not take up the full container width, but we want tables, code blocks and similar to take the full width.&lt;/p>
&lt;p>Scenester tumeric pickled, authentic crucifix post-ironic fam freegan VHS pork belly 8-bit yuccie PBR&amp;amp;B. &lt;strong>I love this life we live in&lt;/strong>.&lt;/p>
&lt;h2 id="second-header-2">Second Header 2&lt;/h2>
&lt;blockquote>
&lt;p>This is a blockquote following a header. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.&lt;/p>
&lt;/blockquote>
&lt;h3 id="header-3">Header 3&lt;/h3>
&lt;pre tabindex="0">&lt;code>This is a code block following a header.
&lt;/code>&lt;/pre>&lt;p>Next level leggings before they sold out, PBR&amp;amp;B church-key shaman echo park. Kale chips occupy godard whatever pop-up freegan pork belly selfies. Gastropub Belinda subway tile woke post-ironic seitan. Shabby chic man bun semiotics vape, chia messenger bag plaid cardigan.&lt;/p>
&lt;h4 id="header-4">Header 4&lt;/h4>
&lt;ul>
&lt;li>This is an unordered list following a header.&lt;/li>
&lt;li>This is an unordered list following a header.&lt;/li>
&lt;li>This is an unordered list following a header.&lt;/li>
&lt;/ul>
&lt;h5 id="header-5">Header 5&lt;/h5>
&lt;ol>
&lt;li>This is an ordered list following a header.&lt;/li>
&lt;li>This is an ordered list following a header.&lt;/li>
&lt;li>This is an ordered list following a header.&lt;/li>
&lt;/ol>
&lt;h6 id="header-6">Header 6&lt;/h6>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>What&lt;/th>
&lt;th>Follows&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A table&lt;/td>
&lt;td>A header&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A table&lt;/td>
&lt;td>A header&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A table&lt;/td>
&lt;td>A header&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>There's a horizontal rule above and below this.&lt;/p>
&lt;hr>
&lt;p>Here is an unordered list:&lt;/p>
&lt;ul>
&lt;li>Liverpool F.C.&lt;/li>
&lt;li>Chelsea F.C.&lt;/li>
&lt;li>Manchester United F.C.&lt;/li>
&lt;/ul>
&lt;p>And an ordered list:&lt;/p>
&lt;ol>
&lt;li>Michael Brecker&lt;/li>
&lt;li>Seamus Blake&lt;/li>
&lt;li>Branford Marsalis&lt;/li>
&lt;/ol>
&lt;p>And an unordered task list:&lt;/p>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> Create a Hugo theme&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> Add task lists to it&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Take a vacation&lt;/li>
&lt;/ul>
&lt;p>And a &amp;quot;mixed&amp;quot; task list:&lt;/p>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Pack bags&lt;/li>
&lt;li>?&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Travel!&lt;/li>
&lt;/ul>
&lt;p>And a nested list:&lt;/p>
&lt;ul>
&lt;li>Jackson 5
&lt;ul>
&lt;li>Michael&lt;/li>
&lt;li>Tito&lt;/li>
&lt;li>Jackie&lt;/li>
&lt;li>Marlon&lt;/li>
&lt;li>Jermaine&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TMNT
&lt;ul>
&lt;li>Leonardo&lt;/li>
&lt;li>Michelangelo&lt;/li>
&lt;li>Donatello&lt;/li>
&lt;li>Raphael&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Definition lists can be used with Markdown syntax. Definition headers are bold.&lt;/p>
&lt;dl>
&lt;dt>Name&lt;/dt>
&lt;dd>Godzilla&lt;/dd>
&lt;dt>Born&lt;/dt>
&lt;dd>1952&lt;/dd>
&lt;dt>Birthplace&lt;/dt>
&lt;dd>Japan&lt;/dd>
&lt;dt>Color&lt;/dt>
&lt;dd>Green&lt;/dd>
&lt;/dl>
&lt;hr>
&lt;p>Tables should have bold headings and alternating shaded rows.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Artist&lt;/th>
&lt;th>Album&lt;/th>
&lt;th>Year&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Michael Jackson&lt;/td>
&lt;td>Thriller&lt;/td>
&lt;td>1982&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Prince&lt;/td>
&lt;td>Purple Rain&lt;/td>
&lt;td>1984&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Beastie Boys&lt;/td>
&lt;td>License to Ill&lt;/td>
&lt;td>1986&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>If a table is too wide, it should scroll horizontally.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Artist&lt;/th>
&lt;th>Album&lt;/th>
&lt;th>Year&lt;/th>
&lt;th>Label&lt;/th>
&lt;th>Awards&lt;/th>
&lt;th>Songs&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Michael Jackson&lt;/td>
&lt;td>Thriller&lt;/td>
&lt;td>1982&lt;/td>
&lt;td>Epic Records&lt;/td>
&lt;td>Grammy Award for Album of the Year, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R&amp;amp;B Album, Brit Award for Best Selling Album, Grammy Award for Best Engineered Album, Non-Classical&lt;/td>
&lt;td>Wanna Be Startin' Somethin', Baby Be Mine, The Girl Is Mine, Thriller, Beat It, Billie Jean, Human Nature, P.Y.T. (Pretty Young Thing), The Lady in My Life&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Prince&lt;/td>
&lt;td>Purple Rain&lt;/td>
&lt;td>1984&lt;/td>
&lt;td>Warner Brothers Records&lt;/td>
&lt;td>Grammy Award for Best Score Soundtrack for Visual Media, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R&amp;amp;B Album, Brit Award for Best Soundtrack/Cast Recording, Grammy Award for Best Rock Performance by a Duo or Group with Vocal&lt;/td>
&lt;td>Let's Go Crazy, Take Me With U, The Beautiful Ones, Computer Blue, Darling Nikki, When Doves Cry, I Would Die 4 U, Baby I'm a Star, Purple Rain&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Beastie Boys&lt;/td>
&lt;td>License to Ill&lt;/td>
&lt;td>1986&lt;/td>
&lt;td>Mercury Records&lt;/td>
&lt;td>noawardsbutthistablecelliswide&lt;/td>
&lt;td>Rhymin &amp;amp; Stealin, The New Style, She's Crafty, Posse in Effect, Slow Ride, Girls, (You Gotta) Fight for Your Right, No Sleep Till Brooklyn, Paul Revere, Hold It Now, Hit It, Brass Monkey, Slow and Low, Time to Get Ill&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>Code snippets like &lt;code>var foo = &amp;quot;bar&amp;quot;;&lt;/code> can be shown inline.&lt;/p>
&lt;p>Also, &lt;code>this should vertically align&lt;/code> &lt;del>&lt;code>with this&lt;/code>&lt;/del> &lt;del>and this&lt;/del>.&lt;/p>
&lt;p>Code can also be shown in a block element.&lt;/p>
&lt;pre tabindex="0">&lt;code>foo := &amp;quot;bar&amp;quot;;
bar := &amp;quot;foo&amp;quot;;
&lt;/code>&lt;/pre>&lt;p>Code can also use syntax highlighting.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a2f;font-weight:bold">func&lt;/span> &lt;span style="color:#00a000">main&lt;/span>() {
input &lt;span style="color:#666">:=&lt;/span> &lt;span style="color:#b44">`var foo = &amp;#34;bar&amp;#34;;`&lt;/span>
lexer &lt;span style="color:#666">:=&lt;/span> lexers.&lt;span style="color:#00a000">Get&lt;/span>(&lt;span style="color:#b44">&amp;#34;javascript&amp;#34;&lt;/span>)
iterator, _ &lt;span style="color:#666">:=&lt;/span> lexer.&lt;span style="color:#00a000">Tokenise&lt;/span>(&lt;span style="color:#a2f;font-weight:bold">nil&lt;/span>, input)
style &lt;span style="color:#666">:=&lt;/span> styles.&lt;span style="color:#00a000">Get&lt;/span>(&lt;span style="color:#b44">&amp;#34;github&amp;#34;&lt;/span>)
formatter &lt;span style="color:#666">:=&lt;/span> html.&lt;span style="color:#00a000">New&lt;/span>(html.&lt;span style="color:#00a000">WithLineNumbers&lt;/span>())
&lt;span style="color:#a2f;font-weight:bold">var&lt;/span> buff bytes.Buffer
formatter.&lt;span style="color:#00a000">Format&lt;/span>(&lt;span style="color:#666">&amp;amp;&lt;/span>buff, style, iterator)
fmt.&lt;span style="color:#00a000">Println&lt;/span>(buff.&lt;span style="color:#00a000">String&lt;/span>())
}
&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.
&lt;/code>&lt;/pre>&lt;p>Inline code inside table cells should still be distinguishable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Language&lt;/th>
&lt;th>Code&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Javascript&lt;/td>
&lt;td>&lt;code>var foo = &amp;quot;bar&amp;quot;;&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ruby&lt;/td>
&lt;td>&lt;code>foo = &amp;quot;bar&amp;quot;{&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;p>Small images should be shown at their actual size.&lt;/p>
&lt;p>&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9e/Picea_abies_shoot_with_buds%2C_Sogndal%2C_Norway.jpg/240px-Picea_abies_shoot_with_buds%2C_Sogndal%2C_Norway.jpg" alt="">&lt;/p>
&lt;p>Large images should always scale down and fit in the content container.&lt;/p>
&lt;p>&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9e/Picea_abies_shoot_with_buds%2C_Sogndal%2C_Norway.jpg/1024px-Picea_abies_shoot_with_buds%2C_Sogndal%2C_Norway.jpg" alt="">&lt;/p>
&lt;p>&lt;em>The photo above of the Spruce Picea abies shoot with foliage buds: Bjørn Erik Pedersen, CC-BY-SA.&lt;/em>&lt;/p>
&lt;h2 id="components">Components&lt;/h2>
&lt;h3 id="alerts">Alerts&lt;/h3>
&lt;p>
&lt;div class="alert alert-primary" role="alert">
This is an alert.
&lt;/div>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">Note&lt;/h4>
This is an alert with a title.
&lt;/div>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">Note&lt;/h4>
This is an alert with a title and &lt;strong>Markdown&lt;/strong>.
&lt;/div>
&lt;div class="alert alert-success" role="alert">
This is a successful alert.
&lt;/div>
&lt;div class="alert alert-warning" role="alert">
This is a warning.
&lt;/div>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">Warning&lt;/h4>
This is a warning with a title.
&lt;/div>
&lt;/p>
&lt;h2 id="another-heading">Another Heading&lt;/h2>
&lt;p>Add some sections here to see how the ToC looks like. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.&lt;/p>
&lt;h3 id="this-document">This Document&lt;/h3>
&lt;p>Inguina genus: Anaphen post: lingua violente voce suae meus aetate diversi. Orbis unam nec flammaeque status deam Silenum erat et a ferrea. Excitus rigidum ait: vestro et Herculis convicia: nitidae deseruit coniuge Proteaque adiciam &lt;em>eripitur&lt;/em>? Sitim noceat signa &lt;em>probat quidem&lt;/em>. Sua longis &lt;em>fugatis&lt;/em> quidem genae.&lt;/p>
&lt;h3 id="pixel-count">Pixel Count&lt;/h3>
&lt;p>Tilde photo booth wayfarers cliche lomo intelligentsia man braid kombucha vaporware farm-to-table mixtape portland. PBR&amp;amp;B pickled cornhole ugh try-hard ethical subway tile. Fixie paleo intelligentsia pabst. Ennui waistcoat vinyl gochujang. Poutine salvia authentic affogato, chambray lumbersexual shabby chic.&lt;/p>
&lt;h3 id="contact-info">Contact Info&lt;/h3>
&lt;p>Plaid hell of cred microdosing, succulents tilde pour-over. Offal shabby chic 3 wolf moon blue bottle raw denim normcore poutine pork belly.&lt;/p>
&lt;h3 id="external-links">External Links&lt;/h3>
&lt;p>Stumptown PBR&amp;amp;B keytar plaid street art, forage XOXO pitchfork selvage affogato green juice listicle pickled everyday carry hashtag. Organic sustainable letterpress sartorial scenester intelligentsia swag bushwick. Put a bird on it stumptown neutra locavore. IPhone typewriter messenger bag narwhal. Ennui cold-pressed seitan flannel keytar, single-origin coffee adaptogen occupy yuccie williamsburg chillwave shoreditch forage waistcoat.&lt;/p>
&lt;pre tabindex="0">&lt;code>This is the final element on the page and there should be no margin below this.
&lt;/code>&lt;/pre></description></item><item><title>Docs: Golang开发-glog日志库</title><link>https://xiaoping378.github.io/docs/3-devops/golang%E5%BC%80%E5%8F%91-%E6%97%A5%E5%BF%97%E7%AF%87/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/golang%E5%BC%80%E5%8F%91-%E6%97%A5%E5%BF%97%E7%AF%87/</guid><description>
&lt;p>基于Golang 1.7.5版本&lt;/p>
&lt;p>软件项目里的日志输出是很重要的环节，可以用于日后BI分析，或者线上调试（万能调试大法printf）等等。&lt;/p>
&lt;blockquote>
&lt;p>对于当年刚入软件行业时，自己的printf(&amp;quot;11111\n&amp;quot;)的做法，记忆犹新呀，调试完再删掉自己胡乱加的打印语句，偶尔还有漏删的情况，就commit，push上去了。&lt;/p>
&lt;/blockquote>
&lt;p>golang语言里有个&lt;code>golang/glog&lt;/code>包，是类似google内部&lt;a href="https://github.com/google/glog">glog&lt;/a>的开源实现，其可以做到无侵入式调试程序，主要是通过启动时命令行传参来控制打印级别。&lt;/p>
&lt;p>有以下特性，&lt;/p>
&lt;ul>
&lt;li>有四个级别的打印 Info, Warning, Error, Fatal，级别越来越高，分别都支持格式化输出Infof, Warningf, Errorf, Fatalf&lt;/li>
&lt;li>支持 -v传参，指定打印级别&lt;/li>
&lt;li>支持 -vmodule=file=2， 指定特殊文件开启打印，避免日志输出过多。&lt;/li>
&lt;li>支持 -log_dir=&amp;quot;&amp;quot;, 指定日志输出目录， 默认会按级别输出/tmp目录下， 高级别的会记录到低级别里日志文件里&lt;/li>
&lt;/ul>
&lt;p>下面举个简单的例子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#080;font-style:italic">//file name: glog.go
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>&lt;span style="color:#a2f;font-weight:bold">package&lt;/span> main
&lt;span style="color:#a2f;font-weight:bold">import&lt;/span> (
&lt;span style="color:#b44">&amp;#34;flag&amp;#34;&lt;/span>
&lt;span style="color:#b44">&amp;#34;github.com/golang/glog&amp;#34;&lt;/span>
)
&lt;span style="color:#a2f;font-weight:bold">func&lt;/span> &lt;span style="color:#00a000">main&lt;/span>() {
flag.&lt;span style="color:#00a000">Parse&lt;/span>()
&lt;span style="color:#080;font-style:italic">//flag.Set(&amp;#34;logtostderr&amp;#34;, &amp;#34;true&amp;#34;)
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span> &lt;span style="color:#a2f;font-weight:bold">defer&lt;/span> glog.&lt;span style="color:#00a000">Flush&lt;/span>()
glog.&lt;span style="color:#00a000">Info&lt;/span>(&lt;span style="color:#b44">&amp;#34;这里是Info级别的日志&amp;#34;&lt;/span>)
glog.&lt;span style="color:#00a000">Warning&lt;/span>(&lt;span style="color:#b44">&amp;#34;这里是Warning级别的日志&amp;#34;&lt;/span>)
glog.&lt;span style="color:#00a000">Errorf&lt;/span>(&lt;span style="color:#b44">&amp;#34;这里是Error级别的日志: %s&amp;#34;&lt;/span>, &lt;span style="color:#b44">&amp;#34;error&amp;#34;&lt;/span>)
glog.&lt;span style="color:#00a000">V&lt;/span>(&lt;span style="color:#666">3&lt;/span>).&lt;span style="color:#00a000">Infoln&lt;/span>(&lt;span style="color:#b44">&amp;#34;级别3的日志&amp;#34;&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码如上运行，你需要执行&lt;code>go get github.com/golang/glog&lt;/code>下载依赖包， 然后运行&lt;/p>
&lt;pre tabindex="0">&lt;code>➜ go run glog.go -v 3
E0408 09:35:38.703186 8663 glog.go:15] This is a Error log error
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>Error级别的会输出到标准输出，并记录到文件，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>日志默认输出到/tmp目录， 每次执行都会记录新的文件，日志文件如下样式命名， glog是文件名，air13是主机名，xxp是用户名&lt;/p>
&lt;pre tabindex="0">&lt;code> ➜ ls /tmp/glog.* -l
-rw-rw-r-- 1 xxp xxp 260 4月 8 10:11 /tmp/glog.air13.xxp.log.ERROR.20170408-101153.12771
-rw-rw-r-- 1 xxp xxp 405 4月 8 10:11 /tmp/glog.air13.xxp.log.INFO.20170408-101153.12771
-rw-rw-r-- 1 xxp xxp 334 4月 8 10:11 /tmp/glog.air13.xxp.log.WARNING.20170408-101153.12771
lrwxrwxrwx 1 xxp xxp 46 4月 8 10:11 /tmp/glog.ERROR -&amp;gt; glog.air13.xxp.log.ERROR.20170408-101153.12771
lrwxrwxrwx 1 xxp xxp 45 4月 8 10:11 /tmp/glog.INFO -&amp;gt; glog.air13.xxp.log.INFO.20170408-101153.12771
lrwxrwxrwx 1 xxp xxp 48 4月 8 10:11 /tmp/glog.WARNING -&amp;gt; glog.air13.xxp.log.WARNING.20170408-101153.12771
&lt;/code>&lt;/pre>&lt;p>``&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-v 3&lt;/code> 指定运行时的记录的日志级别，因为3&amp;gt;=3, 这样&lt;code>V(3).Infoln&lt;/code>会输出， 如果是传入 &lt;code>-v 2&lt;/code>, 则不会&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code> go run glog.go -v 2 -logtostderr=true&lt;/code>， 则会关闭记录文件，输出到标准输出。
当然可以在程序里加上 &lt;code>flag.Set(&amp;quot;logtostderr&amp;quot;, &amp;quot;true&amp;quot;)&lt;/code>来关闭记录文件。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>总之，glog包对日志的控制非常实用和灵活，大型Golang项目必备包之一。&lt;/p></description></item><item><title>Docs: DevOps实战-0</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0/</guid><description>
&lt;p>主要涉及到&lt;code>一键发布&lt;/code>，&lt;code>快速回滚&lt;/code>，&lt;code>弹性伸缩&lt;/code>，&lt;code>蓝绿部署&lt;/code>方面。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>启动openshift&lt;/p>
&lt;pre>&lt;code>oc cluster up --version=v1.5.0-rc.0 --metrics --use-existing-config=true
&lt;/code>&lt;/pre>
&lt;p>默认负责监控的pods占用资源太大了，可以这样限制下，或者cluster up时不加 &lt;code>--metrics&lt;/code>&lt;/p>
&lt;pre>&lt;code>oc login -u system:admin
oc env rc hawkular-cassandra-1 MAX_HEAP_SIZE=1024M -n openshift-infra
#重建下,变量才会生效
oc scale rc hawkular-cassandra-1 --replicas 0 -n openshift-infra
oc scale rc hawkular-cassandra-1 --replicas 1 -n openshift-infra
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>建立本地Git仓&lt;/p>
&lt;p>默认官方给出的例子基本都需要和Github结合，实在不好本地实战演示，所以本地要来一个&lt;code>gogs&lt;/code>代码仓。&lt;/p>
&lt;pre>&lt;code>oc login -u devloper
oc new-project ci
#先拉取所依赖镜像
docker pull openshiftdemos/gogs:0.9.97
docker pull centos/postgresql-94-centos7
#创建gogs服务，并禁用webhook时的TLS校验，不然无法触发build
oc new-app -f https://raw.githubusercontent.com/xiaoping378/gogs-openshift-docker/master/openshift/gogs-persistent-template.yaml -p SKIP_TLS_VERIFY=true -p HOSTNAME=gogs-ci.192.168.31.49.xip.io
&lt;/code>&lt;/pre>
&lt;p>上面的HOSTNAME，注意要换成自己宿主机的IPv4地址，默认创建的其他服务的路由都是这个形式的，&lt;/p>
&lt;p>有个有意思的地方，为什么默认路由会是这种 &lt;code>name+IP+xip.io&lt;/code> 形式呢，奥秘在 &lt;a href="http://xip.io">http://xip.io&lt;/a> 的公共服务上。
这其实是个特殊的域DNS server，比如我们查询域名&lt;code>gogs-ci.192.168.31.49.xip.io&lt;/code>时 ，会返回192.168.31.49的地址回来，
而这个地址恰好是我们Router的地址，这样子Router会根据route的配置负责负载到对应的POD上。自己试验下就知道怎么回事了。&lt;/p>
&lt;pre>&lt;code>dig http://gogs-ci.192.168.31.49.xip.io +short
&lt;/code>&lt;/pre>
&lt;p>只做功能性演示，先不考虑https加密安全访问，创建完后，访问gogs服务 &lt;code>http://gogs-ci.192.168.31.49.xip.io&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-gogs.png" alt="gogs">&lt;/p>
&lt;p>这个项目，第一个注册用户即为管理员，比如我现在去页面注册一个叫&lt;code>developer&lt;/code>的用户。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>找个项目来实战吧&lt;/p>
&lt;ul>
&lt;li>
&lt;p>克隆远程项目，并设置&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/xiaoping378/nodejs-ex.git &amp;amp;&amp;amp; cd nodejs-ex
git remote add gogs http://gogs-ci.192.168.31.49.xip.io/developer/nodejs-ex.git
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>通过web页面，在gogs上创建一个&lt;code>nodejs-ex&lt;/code>仓库, 并如下push刚才克隆的项目&lt;/p>
&lt;pre>&lt;code>$ git push gogs master
Username for 'http://gogs-ci.192.168.31.49.xip.io': developer
Password for 'http://developer@gogs-ci.192.168.31.49.xip.io':
Counting objects: 431, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (210/210), done.
Writing objects: 100% (431/431), 145.16 KiB | 0 bytes/s, done.
Total 431 (delta 159), reused 431 (delta 159)
To http://gogs-ci.192.168.31.49.xip.io/developer/nodejs-ex.git
* [new branch] master -&amp;gt; master
&lt;/code>&lt;/pre>
&lt;p>gogs的页面上会如实反馈信息&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/gogs-create-push.png" alt="gogs">&lt;/p>
&lt;p>OK，现在本地项目就有了，接下来进入正题&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>在openshift部署此nodejs应用&lt;/p>
&lt;pre>&lt;code> #创建web namespace
oc new-project web
#先拉取依赖镜像
docker pull centos/mongodb-32-centos7
docker pull centos/nodejs-4-centos7
#部署此项目，并启用国内npm源和对应的git仓
oc new-app nodejs-mongo-persistent --name=nodejs-ex -p NPM_MIRROR=https://registry.npm.taobao.org -p SOURCE_REPOSITORY_URL=http://gogs-ci.192.168.31.49.xip.io/developer/nodejs-ex.git
&lt;/code>&lt;/pre>
&lt;p>默认此模板会从指定的URL地址拉取代码，并根据预先的配置，采取&lt;code>Source&lt;/code>编译策略，基于istag nodejs:4镜像编译出nodejs-mongo-persistent:latest镜像，编译出来的镜像又会自动触发部署。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最基本的DevOps能力&lt;/p>
&lt;p>即push代码通过webhook触发自动编译，继而滚动部署&lt;/p>
&lt;p>要实现这个目标前，需要先把webhook填写到gogs里。&lt;/p>
&lt;p>在openshift界面上复制webhook地址&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-github-webhook.png" alt="find_webhook">&lt;/p>
&lt;p>然后在gogs上填加一个webhook&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-gogs-webhook.png" alt="add_webhook">&lt;/p>
&lt;p>这里我们随意修改些，然后推送代码，就会自动触发编译并滚动升级&lt;/p>
&lt;pre>&lt;code>➜ nodejs-ex git:(master) vim views/index.html
➜ nodejs-ex git:(master) ✗ git add .
➜ nodejs-ex git:(master) ✗ git commit -m &amp;quot;这又是个测试&amp;quot;
[master 082f05e] 这又是个测试
1 file changed, 1 insertion(+), 1 deletion(-)
➜ nodejs-ex git:(master) git push gogs master
Username for 'http://gogs-ci.192.168.31.49.xip.io': developer
Password for 'http://developer@gogs-ci.192.168.31.49.xip.io':
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 365 bytes | 0 bytes/s, done.
Total 4 (delta 2), reused 0 (delta 0)
To http://gogs-ci.192.168.31.49.xip.io/developer/nodejs-ex.git
c3592e6..082f05e master -&amp;gt; master
&lt;/code>&lt;/pre>
&lt;p>编译成功后，会产生新镜像，继而触发滚动升级的截图&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/push-build-deploy.png" alt="auto-deploy">&lt;/p>
&lt;p>现实中，如果项目没有很好的自动化测试的话，我们肯定不会这样操作的，除非想被开掉了。&lt;/p>
&lt;p>其实可以简单的去掉webhook，采用手动触发build： 界面操作的话，去build界面点击&lt;code>Start Build&lt;/code>，命令行的话如下&lt;/p>
&lt;pre>&lt;code>oc start-build nodejs-mongo-persistent
&lt;/code>&lt;/pre>
&lt;p>另外，如果发现新版本的应用有重大缺陷，想回滚以前的部署版本，也有对应的界面和命令&lt;/p>
&lt;pre>&lt;code>oc rollback nodejs-mongo-persistent --to-version=3
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-roll-back.png" alt="rollBack">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>弹性伸缩&lt;/p>
&lt;p>目前可以根据CPU使用率来进行弹性伸缩&lt;/p>
&lt;p>有人问能不能基本mem进行弹性呢，其实这个是没什么意义的，一般应用都会自行缓存，内存基本只增不长， 所以cpu才能很好的实时反应业务的负载。&lt;/p>
&lt;p>弹性伸缩前，要确保应用先行设置了cpu request，这点还没明白原因，为什么要这样，按理说，heapster一直会采集pod的资源使用情况的，HPA周期拿数据和设置的阈值对比就完了。&lt;/p>
&lt;p>这里是部署界面的菜单栏，可以手动加上cpu request&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-dc-menu.png" alt="dc-menu">&lt;/p>
&lt;p>添加 cpu request.&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-cpu-request.png" alt="cpu-request">&lt;/p>
&lt;p>然后开启弹性伸缩特性，这里就不截图了，展示下命令行，我们设置成： 当cpu使用率达到80%时，就弹，最大可以弹出3个实例&lt;/p>
&lt;pre>&lt;code>oc autoscale dc/nodejs-mongo-persistent --max=3 --cpu-percent=80
&lt;/code>&lt;/pre>
&lt;p>OK，之后我们通过ab工具简单做个压力模拟，因为环境在我的笔记本上，所以只模拟发送100万个连接，并发100的量&lt;/p>
&lt;pre>&lt;code>ab -n 1000000 -c 100 http://nodejs-mongo-persistent-web.192.168.31.49.xip.io/
&lt;/code>&lt;/pre>
&lt;p>后台每1分钟采集一次cpu使用率，过不了一会儿，就会看到nodejs实例自动扩展了&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-autoscale-0.png" alt="autoscale-0">&lt;/p>
&lt;p>当业务量降下来时，会自动减少实例，是根据平均CPU使用率来操作的。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-autoscale-1.png" alt="autoscale-1">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>蓝绿部署&lt;/p>
&lt;p>这个也是API级别的支持，不描述具体操作细节了，原理还是以前的，从负载均衡层面入手。 实现新旧版本同时存在。
并不是所有业务都适合蓝绿部署的，要看后台数据是否允许，新旧版本同时发生读写数据&lt;/p>
&lt;p>在openshift里实现蓝绿部署的，就太简单了。具体就是在Route层面添加同一应用的多个版本的service，并设置分流权重
截图如下&lt;/p>
&lt;p>界面设置，只是为了展示功能，我随便添加了个service&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-blue-green-0.png" alt="bluegreen-0">&lt;/p>
&lt;p>实际展示效果&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-blue-green-1.png" alt="bluegreen-1">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>Openshift平台本身在API层面实现了DevOps，所以基于它很容易做到DevOps as an service， 上面的演示可能与现实世界不太一样，&lt;/p>
&lt;p>比如真实情况是有，测试，预发布，线上环境的，下次再分享: openshift基于jenkins pipeline如果实现更真实场景的需求。&lt;/p></description></item><item><title>Docs: Helm模板介绍</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/kubernetes-helm%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/kubernetes-helm%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</guid><description>
&lt;h3 id="概要">概要&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Helm是一个管理kubernetes集群内应用的工具，提供了一系列管理应用的快捷方式，例如 inspect， install， upgrade， delete等，经验可以沿用以前apt，yum，homebrew的,区别就是helm管理的是kubernetes集群内的应用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有一个概念必须得提，就是&lt;code>chart&lt;/code>， 它代表的就是被helm管理的应用包，里面具体就是放一些预先配置的Kubernetes资源(pod, rc, deployment, service, ingress)，一个包描述文件(&lt;code>Chart.yaml&lt;/code>), 还可以通过指定依赖来组织成更复杂的应用，支持go template语法，可参数化模板，让使用者定制化安装
charts可以存放在本地，也可以放在远端，这点理解成yum仓很合适。。。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这里有个&lt;a href="https://kubeapps.com">应用市场&lt;/a> ，里面罗列了各种应用charts。由开源项目&lt;a href="https://github.com/helm/monocular">monocular&lt;/a>支撑&lt;/p>
&lt;p>下面主要介绍helm的基本使用流程和具体场景的实践。&lt;/p>
&lt;h3 id="初始化k8s集群v1-6-2">初始化k8s集群v1.6.2&lt;/h3>
&lt;p>先来准备k8s环境，可以通过&lt;a href="https://github.com/xiaoping378/k8s-deploy">k8s-deploy&lt;/a>项目来离线安装高可用kubernetes集群，我这里是单机演示环境。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubeadm init --kubernetes-version v1.6.2 --pod-network-cidr 12.240.0.0/12
&lt;span style="color:#080;font-style:italic">#方便命令自动补全&lt;/span>
&lt;span style="color:#a2f">source&lt;/span> &amp;lt;&lt;span style="color:#666">(&lt;/span>kubectl completion zsh&lt;span style="color:#666">)&lt;/span>
&lt;span style="color:#080;font-style:italic">#安装cni网络&lt;/span>
cp /etc/kubernetes/admin.conf &lt;span style="color:#b8860b">$HOME&lt;/span>/.kube/config
kubectl apply -f kube-flannel-rbac.yml
kubectl apply -f kube-flannel.yml
&lt;span style="color:#080;font-style:italic">#使能master可以被调度&lt;/span>
kubectl taint node --all node-role.kubernetes.io/master-
&lt;span style="color:#080;font-style:italic">#安装ingress-controller, 边界路由作用&lt;/span>
kubectl create -f ingress-traefik-rbac.yml
kubectl create -f ingress-traefik-deploy.yml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样一个比较完整的k8s环境就具备了，另外监控和日志不在此文的讨论范围内。&lt;/p>
&lt;h3 id="初始化helm环境">初始化Helm环境&lt;/h3>
&lt;p>由于刚才创建的k8s集群默认启用RBAC机制，个人认为这个特性是k8s真正走向成熟的一大标志，废话不表，为了helm可以安装任何应用，我们先给他最高权限。&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl create serviceaccount helm --namespace kube-system
kubectl create clusterrolebinding cluster-admin-helm --clusterrole=cluster-admin --serviceaccount=kube-system:helm
&lt;/code>&lt;/pre>&lt;p>初始化helm，如下执行，会在kube-system namepsace里安装一个tiller服务端，这个服务端就是用来解析helm语义的，后台再转成api-server的API执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ helm init --service-account helm
&lt;span style="color:#b8860b">$HELM_HOME&lt;/span> has been configured at /home/xxp/.helm.
Tiller &lt;span style="color:#666">(&lt;/span>the helm server side component&lt;span style="color:#666">)&lt;/span> has been installed into your Kubernetes Cluster.
Happy Helming!
➜ helm version
Client: &amp;amp;version.Version&lt;span style="color:#666">{&lt;/span>SemVer:&lt;span style="color:#b44">&amp;#34;v2.4.1&amp;#34;&lt;/span>, GitCommit:&lt;span style="color:#b44">&amp;#34;46d9ea82e2c925186e1fc620a8320ce1314cbb02&amp;#34;&lt;/span>, GitTreeState:&lt;span style="color:#b44">&amp;#34;clean&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>
Server: &amp;amp;version.Version&lt;span style="color:#666">{&lt;/span>SemVer:&lt;span style="color:#b44">&amp;#34;v2.4.1&amp;#34;&lt;/span>, GitCommit:&lt;span style="color:#b44">&amp;#34;46d9ea82e2c925186e1fc620a8320ce1314cbb02&amp;#34;&lt;/span>, GitTreeState:&lt;span style="color:#b44">&amp;#34;clean&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>
&lt;span style="color:#080;font-style:italic">#命令行补全&lt;/span>
➜ &lt;span style="color:#a2f">source&lt;/span> &amp;lt;&lt;span style="color:#666">(&lt;/span>helm completion zsh&lt;span style="color:#666">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装第一个应用">安装第一个应用&lt;/h3>
&lt;p>初始化Helm后，默认就导入了2个repos，后面安装和搜索应用时，都是从这2个仓里出的，当然也可以自己通过&lt;code>helm repo add&lt;/code>添加本地私有仓&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ helm repo list
NAME URL
stable https://kubernetes-charts.storage.googleapis.com
&lt;span style="color:#a2f">local&lt;/span> http://127.0.0.1:8879/charts
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实上面的repo仓的索引信息是存放在&lt;code>~/.helm/repository&lt;/code>的, 类似/etc/yum.repos.d/的作用&lt;/p>
&lt;p>helm的使用基本流程如下:&lt;/p>
&lt;ul>
&lt;li>helm search: 搜索自己想要安装的应用（chart）&lt;/li>
&lt;li>helm fetch: 下载应用（chart）到本地，可以忽略此步&lt;/li>
&lt;li>helm install: 安装应用&lt;/li>
&lt;li>helm ls: 查看已安装的应用情况&lt;/li>
&lt;/ul>
&lt;p>这里举例安装redis&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ helm install stable/redis --set persistence.enabled&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#a2f">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上，如果网络给力的话，很快就会装上最新的redis版本，Helm安装应用，目前有四种方式：&lt;/p>
&lt;ul>
&lt;li>&lt;code>helm install stable/mariadb&lt;/code> 通过chart仓来安装&lt;/li>
&lt;li>&lt;code>helm install ./nginx-1.2.3.tgz&lt;/code> 通过本地打包后的压缩chart包来安装&lt;/li>
&lt;li>&lt;code>helm install ./nginx&lt;/code> 通过本地的chart目录来安装&lt;/li>
&lt;li>&lt;code>helm install https://example.com/charts/nginx-1.2.3.tgz&lt;/code> 通过绝对网络地址来安装chart压缩包&lt;/li>
&lt;/ul>
&lt;h3 id="实战演示">实战演示&lt;/h3>
&lt;p>主要从&lt;code>制作自己的chart&lt;/code>， &lt;code>构建自己的repo&lt;/code>， &lt;code>组装复杂应用的实战&lt;/code>三方面来演示&lt;/p>
&lt;h4 id="制作自己的chart">制作自己的chart&lt;/h4>
&lt;p>helm有一个很好的引导教程模板, 如下会自动创建一个通用的应用模板&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ helm create myapp
Creating myapp
➜ tree myapp
myapp
├── charts //此应用包的依赖包定义（如果有的话，也会是类似此包的目录结构）
├── Chart.yaml // 包的描述文件
├── templates // 包的主体目录
│ ├── deployment.yaml // kubernetes里的deployment yaml文件
│ ├── _helpers.tpl // 模板里如果复杂的话，可能需要函数或者其他数据结构，这里就是定义的地方
│ ├── ingress.yaml // kubernetes里的ingress yaml文件
│ ├── NOTES.txt // 想提供给使用者的一些注意事项，一般提供install后，如何访问之类的信息
│ └── service.yaml // kubernetes里的service yaml文件
└── values.yaml // 参数的默认值
&lt;span style="color:#666">2&lt;/span> directories, &lt;span style="color:#666">7&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上操作，我们就有了一个&lt;code>myapp&lt;/code>的应用，目录结构如上，来看看看values.yaml的内容, 这个里面就是模板里可定制参数的默认值&lt;/p>
&lt;p>很容易看到，kubernetes里的rc实例数，镜像名，servie配置，路由ingress配置都可以轻松定制。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-YAML" data-lang="YAML">&lt;span style="color:#080;font-style:italic"># Default values for myapp.&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-style:italic"># This is a YAML-formatted file.&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-style:italic"># Declare variables to be passed into your templates.&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">replicaCount&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#666">1&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">image&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">repository&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">tag&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>stable&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">pullPolicy&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>IfNotPresent&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">service&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">name&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>nginx&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">type&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>ClusterIP&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">externalPort&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#666">80&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">internalPort&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#666">80&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">ingress&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">enabled&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#a2f;font-weight:bold">false&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-style:italic"># Used to create Ingress record (should used with service.type: ClusterIP).&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">hosts&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- chart-example.local&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">annotations&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-style:italic"># kubernetes.io/ingress.class: nginx&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-style:italic"># kubernetes.io/tls-acme: &amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">tls&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-style:italic"># Secrets must be manually created in the namespace.&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-style:italic"># - secretName: chart-example-tls&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-style:italic"># hosts:&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-style:italic"># - chart-example.local&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#008000;font-weight:bold">resources&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">limits&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>100m&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>128Mi&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">requests&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">cpu&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>100m&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">memory&lt;/span>:&lt;span style="color:#bbb"> &lt;/span>128Mi&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>note.&lt;/p>
&lt;blockquote>
&lt;p>一般拿到一个现有的app chart后，这个文件是必看的，通过&lt;code>helm fetch myapp&lt;/code>会得到一个类似上面目录的压缩包&lt;/p>
&lt;/blockquote>
&lt;p>我们可以通过 &lt;code>--set&lt;/code>或传入values.yaml文件来定制化安装，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 安装myapp模板： 启动2个实例，并可通过ingress对外提供myapp.192.168.31.49.xip.io的域名访问&lt;/span>
➜ helm install --name myapp --set &lt;span style="color:#b8860b">replicaCount&lt;/span>&lt;span style="color:#666">=&lt;/span>2,ingress.enabled&lt;span style="color:#666">=&lt;/span>true,ingress.hosts&lt;span style="color:#666">={&lt;/span>myapp.192.168.31.49.xip.io&lt;span style="color:#666">}&lt;/span> ./myapp
➜ helm ls
NAME REVISION UPDATED STATUS CHART NAMESPACE
exasperated-rottweiler &lt;span style="color:#666">1&lt;/span> Wed May &lt;span style="color:#666">10&lt;/span> 13:58:56 2017 DEPLOYED redis-0.5.2 default
myapp &lt;span style="color:#666">1&lt;/span> Wed May &lt;span style="color:#666">10&lt;/span> 21:46:51 2017 DEPLOYED myapp-0.1.0 default
&lt;span style="color:#080;font-style:italic">#通过传入yml文件来安装&lt;/span>
&lt;span style="color:#080;font-style:italic">#helm install --name myapp -f myvalues.yaml ./myapp&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="构建私有charts-repo">构建私有charts repo&lt;/h4>
&lt;p>通过 &lt;code>helm repo list&lt;/code>, 得知默认的local repo地址是&lt;code>http://127.0.0.1:8879/charts&lt;/code>， 可以简单的通过&lt;code>helm serve&lt;/code>来操作，再或者自己起个web server也是一样的。&lt;/p>
&lt;p>这里举例，把刚才创建的myapp放到本地仓里&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ helm search myapp
No results found
➜
➜ &lt;span style="color:#a2f">source&lt;/span> &amp;lt;&lt;span style="color:#666">(&lt;/span>helm completion zsh&lt;span style="color:#666">)&lt;/span>
➜
➜ helm package myapp
➜
➜ helm serve &amp;amp;
&lt;span style="color:#666">[&lt;/span>1&lt;span style="color:#666">]&lt;/span> &lt;span style="color:#666">10619&lt;/span>
➜ Regenerating index. This may take a moment.
Now serving you on 127.0.0.1:8879
➜ deis helm search myapp
NAME VERSION DESCRIPTION
local/myapp 0.1.0 A Helm chart &lt;span style="color:#a2f;font-weight:bold">for&lt;/span> Kubernetes
&lt;/code>&lt;/pre>&lt;/div>&lt;p>目前个人感觉体验不太好的是，私有仓里的app必须以tar包的形式存在。&lt;/p>
&lt;h4 id="构建复杂应用">构建复杂应用&lt;/h4>
&lt;p>透过例子学习，会加速理解，我们从deis里的workflow应用来介绍&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ ~ helm repo add deis https://charts.deis.com/workflow
&lt;span style="color:#b44">&amp;#34;deis&amp;#34;&lt;/span> has been added to your repositories
➜ ~
➜ ~ helm search workflow
NAME VERSION DESCRIPTION
deis/workflow v2.14.0 Deis Workflow
➜ ~
➜ ~ helm fetch deis/workflow --untar
➜ ~ helm dep list workflow
NAME VERSION REPOSITORY STATUS
builder v2.10.1 https://charts.deis.com/builder unpacked
slugbuilder v2.4.12 https://charts.deis.com/slugbuilder unpacked
dockerbuilder v2.7.2 https://charts.deis.com/dockerbuilder unpacked
controller v2.14.0 https://charts.deis.com/controller unpacked
slugrunner v2.3.0 https://charts.deis.com/slugrunner unpacked
database v2.5.3 https://charts.deis.com/database unpacked
fluentd v2.9.0 https://charts.deis.com/fluentd unpacked
redis v2.2.6 https://charts.deis.com/redis unpacked
logger v2.4.3 https://charts.deis.com/logger unpacked
minio v2.3.5 https://charts.deis.com/minio unpacked
monitor v2.9.0 https://charts.deis.com/monitor unpacked
nsqd v2.2.7 https://charts.deis.com/nsqd unpacked
registry v2.4.0 https://charts.deis.com/registry unpacked
registry-proxy v1.3.0 https://charts.deis.com/registry-proxy unpacked
registry-token-refresher v1.1.2 https://charts.deis.com/registry-token-refresher unpacked
router v2.12.1 https://charts.deis.com/router unpacked
workflow-manager v2.5.0 https://charts.deis.com/workflow-manager unpacked
➜ ~ ls workflow
charts Chart.yaml requirements.lock requirements.yaml templates values.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上操作，我们会得到一个巨型应用，实际上便是deis出品的workflow开源paas平台，具体这个平台的介绍下次有机会再分享&lt;/p>
&lt;p>整个大型应用是通过 wofkflow/requirements.yaml组织起来的，所有依赖的chart放到charts目录，然后charts目录里就是些类似myapp的小应用&lt;/p>
&lt;p>更复杂的应用，甚至有人把openstack用helm安装到Kubernetes上，感兴趣的可以参考&lt;a href="https://github.com/openstack/openstack-helm">这里&lt;/a>&lt;/p></description></item><item><title>Docs: Vagrant实践整理</title><link>https://xiaoping378.github.io/docs/4-cloud/vagrant%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/vagrant%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>
&lt;p>很早就听说vagrant的大名，是个创建和管理虚机环境的工具，但一直没有机会实践下，近日我的VirtuablBox让我搞砸了，决定试用下，便于快速搭建各种环境。&lt;/p>
&lt;h2 id="安装vagrant">安装vagrant&lt;/h2>
&lt;p>图省事儿的话，直接&lt;code>sudo apt install vagrant&lt;/code>就可以安装，不过版本有点儿低，是1.8.1。&lt;/p>
&lt;p>通过官方&lt;a href="https://www.vagrantup.com/downloads.html">下载地址&lt;/a>, 可直接下载最新的安装包。我这里安装的是1.9.4&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ ~ vagrant -v
Vagrant 1.9.4
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常用命令">常用命令&lt;/h2>
&lt;p>一个打包好的操作系统在Vagrant中称为Box，即Box是一个打包好的操作系统环境，网上有很多打包好的环境，官方也有下载各种Boxes的&lt;a href="https://atlas.hashicorp.com/boxes/search">地址&lt;/a>&lt;/p>
&lt;p>一般使用流程如下：&lt;/p>
&lt;ul>
&lt;li>vagrant box add 添加box的操作&lt;/li>
&lt;li>vagrant init 初始化box的操作&lt;/li>
&lt;li>vagrant up 启动虚拟机的操作&lt;/li>
&lt;li>vagrant ssh 登录虚拟机的操作&lt;/li>
&lt;/ul>
&lt;p>额外还有些常用的命令&lt;/p>
&lt;ul>
&lt;li>vagrant box list 显示当前已经添加的box列表&lt;/li>
&lt;li>vagrant box remove 删除相应的box&lt;/li>
&lt;li>vagrant halt -f 冷关机（切断电源）&lt;/li>
&lt;li>vagrant suspend 挂起当前的虚拟机&lt;/li>
&lt;/ul>
&lt;h2 id="实践">实践&lt;/h2>
&lt;p>目前vagrant 1.9.4支持适配VirtualBox, VMware，Hyper-V, 和 Docker，本文使用的是VirtualBox。&lt;/p>
&lt;p>需要你本机已经&lt;a href="https://www.virtualbox.org/wiki/Downloads">安装virtuablbox&lt;/a>环境&lt;/p>
&lt;p>一般只要如下初始化，就会有个最新的centos-7虚机环境&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ vagrant init centos/7
A &lt;span style="color:#b44">`&lt;/span>Vagrantfile&lt;span style="color:#b44">`&lt;/span> has been placed in this directory. You are now
ready to &lt;span style="color:#b44">`&lt;/span>vagrant up&lt;span style="color:#b44">`&lt;/span> your first virtual environment! Please &lt;span style="color:#a2f">read&lt;/span>
the comments in the Vagrantfile as well as documentation on
&lt;span style="color:#b44">`&lt;/span>vagrantup.com&lt;span style="color:#b44">`&lt;/span> &lt;span style="color:#a2f;font-weight:bold">for&lt;/span> more information on using Vagrant.
➜ ls
Vagrantfile
➜ vagrant up --provider virtualbox
Bringing machine &lt;span style="color:#b44">&amp;#39;default&amp;#39;&lt;/span> up with &lt;span style="color:#b44">&amp;#39;virtualbox&amp;#39;&lt;/span> provider...
&lt;span style="color:#666">==&lt;/span>&amp;gt; default: Box &lt;span style="color:#b44">&amp;#39;centos/7&amp;#39;&lt;/span> could not be found. Attempting to find and install...
default: Box Provider: virtualbox
default: Box Version: &amp;gt;&lt;span style="color:#666">=&lt;/span> &lt;span style="color:#b8860b">0&lt;/span>
&lt;span style="color:#666">==&lt;/span>&amp;gt; default: Loading metadata &lt;span style="color:#a2f;font-weight:bold">for&lt;/span> box &lt;span style="color:#b44">&amp;#39;centos/7&amp;#39;&lt;/span>
default: URL: https://atlas.hashicorp.com/centos/7
&lt;span style="color:#666">==&lt;/span>&amp;gt; default: Adding box &lt;span style="color:#b44">&amp;#39;centos/7&amp;#39;&lt;/span> &lt;span style="color:#666">(&lt;/span>v1704.01&lt;span style="color:#666">)&lt;/span> &lt;span style="color:#a2f;font-weight:bold">for&lt;/span> provider: virtualbox
default: Downloading: https://atlas.hashicorp.com/centos/boxes/7/versions/1704.01/providers/virtualbox.box
default: Progress: 2% &lt;span style="color:#666">(&lt;/span>Rate: 94086/s, Estimated &lt;span style="color:#a2f">time&lt;/span> remaining: 1:52:14&lt;span style="color:#666">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但如上需要依赖外网, 国内环境一般会下载失败，我这里介绍一种通过本地iso创建Box的方法，然后通过本地Box启动虚机环境。&lt;/p>
&lt;p>这个iso转box的方法需要&lt;code>Packer&lt;/code>工具，此工具同样和vagrant都是&lt;code>HashiCorp&lt;/code>公司出品的，目前国外很火的工具，
支持创建各式各样的镜像，包括各种国内外主流的公有云, openstack的镜像，甚至docker镜像都是可以OK的。&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/01.2.md">https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/01.2.md&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: fomo3d-钱都去哪儿了</title><link>https://xiaoping378.github.io/docs/5-blockchain/fomo3d-%E9%92%B1%E9%83%BD%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/fomo3d-%E9%92%B1%E9%83%BD%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/</guid><description>
&lt;p>fomo3d里有战队系统、邀请分佣机制、持key分红、空投系统、持p3d分红等玩法, 相信通过之前各类媒体的解读都有所了解。&lt;/p>
&lt;p>下面通过分析合约代码，以讲解ETH数据流向的方式串下所有流程，让大家明明白白的知道自己的ETH都去了哪里。&lt;/p>
&lt;p>以10ETH充币到fomod3d合约举例，分三种情况&lt;/p>
&lt;ul>
&lt;li>早期用户（游戏刚启动时的激进者）&lt;/li>
&lt;li>中期用户（为了赚分红、返佣的用户）&lt;/li>
&lt;li>晚期用户（为了赢48%大奖的人）&lt;/li>
&lt;/ul>
&lt;h2 id="早期">早期&lt;/h2>
&lt;p>当合约被激活后，开发者做了一个很“仇富”的举动，每个地址在合约收到100ETH之前，只能购买1ETH的keys，防止被资本大鳄收割本轮后面入场的玩家。这里有个小hack的点，就是提前多准备些小号，多个地址去投，也可以做到比别人便宜多的价格买到keys。&lt;/p>
&lt;p>这个阶段以买入10ETH举例，你只会买到等同于1ETH价值的keys，其余9个ETH会直接进入你的收益里，
演示如下：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethLimiter2.png" alt="ethLimiter2">&lt;/p>
&lt;p>下面是实现此功能的代码&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/ethLimiter.png" alt="ethLimiter">&lt;/p>
&lt;p>代码里的规则(不限阶段)梳理：&lt;/p>
&lt;ul>
&lt;li>提款功能可以无限次提，不影响本轮接下来的分红收益，你的收益来自于你持有keys的分红。&lt;/li>
&lt;li>最低可以支付1e-09个Ether，当购买的Key数量大于或者等于1个时，倒计时会加30秒。&lt;/li>
&lt;li>当支付的eth不小于0.1时，会送一次“彩票”，买key支付的金额越大，中奖的奖金也越大，最大可中“彩票池”里额度的75%，直译过来这个功能叫空投。&lt;/li>
&lt;/ul>
&lt;h2 id="中期">中期&lt;/h2>
&lt;p>所有阶段的用户如果是直接打开的官网，充币买keys时会触发合约的这个接口，&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/buyXaddr.png" alt="buyXaddr">&lt;/p>
&lt;p>其中_affcode是值邀请人的地址，_team是指用户所有购买key所选的战队，默认的2是指蛇队。&lt;/p>
&lt;p>如果是从别人的邀请进入的官网，要看邀请人给你发的是哪个链接，有三种形式的链接：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/affiliate.png" alt="affiliate">,&lt;/p>
&lt;p>从上到下，分别会走&lt;code>buyXaddr&lt;/code>、&lt;code>buyXid&lt;/code>、&lt;code>buyXname&lt;/code>的接口，比如我给人发了&lt;a href="http://exitscam.me/xxp">exitscam.me/xxp&lt;/a>的邀请链接，被邀的人买keys时会触发如下接口：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/affiliate2.png" alt="affiliate2">&lt;/p>
&lt;p>这其中我个人会收到他买key总额度的10%佣金，这里还有个隐藏的点：&lt;/p>
&lt;pre>&lt;code>如果用户是直接从官网进入买key的，那同样会有10%佣金的产生，只不过是流向p3d的持有者。
&lt;/code>&lt;/pre>
&lt;h2 id="晚期">晚期&lt;/h2>
&lt;p>当有人买key时，都会选择一个战队，默认会被勾选蛇队的，当买到keys数量不小于1个时，会使所选战队成为本轮的潜在获胜队。&lt;/p>
&lt;p>说了这么多废话，回归正体，你的10ETH到底去了哪里？？？&lt;/p>
&lt;p>如果支付10ETH时，选的是蛇队，你10个ETH里的5.6个会被持keys的人均分，1个看情况是给p3d的人还是给邀请你的人，还有1个必定会分给持有p3d的人，另外2个会进入大池子，其中0.2个会分给社区贡献人，0.1个会给TeamJust的另一个游戏合约，还有0.1个会流到“彩票池”里。&lt;/p>
&lt;p>这里面根据你选的战队不通，分配比例不一样，具体看下的代码，执行这些ETH分配的是走&lt;code>distributeExternal&lt;/code>，&lt;code>distributeInternal&lt;/code> 出去的。&lt;/p>
&lt;p>后面的PotSpit是本轮游戏结束后，如何分配大池子里的金额。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#080;font-style:italic">// Team allocation structures
&lt;/span>&lt;span style="color:#080;font-style:italic">// 0 = whales
&lt;/span>&lt;span style="color:#080;font-style:italic">// 1 = bears
&lt;/span>&lt;span style="color:#080;font-style:italic">// 2 = sneks
&lt;/span>&lt;span style="color:#080;font-style:italic">// 3 = bulls
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>
&lt;span style="color:#080;font-style:italic">// Team allocation percentages
&lt;/span>&lt;span style="color:#080;font-style:italic">// (F3D, P3D) + (Pot , Referrals, Community)
&lt;/span>&lt;span style="color:#080;font-style:italic">// Referrals / Community rewards are mathematically designed to come from the winner&amp;#39;s share of the pot.
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>fees_[&lt;span style="color:#666">0&lt;/span>] &lt;span style="color:#666">=&lt;/span> F3Ddatasets.TeamFee(&lt;span style="color:#666">30&lt;/span>,&lt;span style="color:#666">6&lt;/span>); &lt;span style="color:#080;font-style:italic">//50% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>fees_[&lt;span style="color:#666">1&lt;/span>] &lt;span style="color:#666">=&lt;/span> F3Ddatasets.TeamFee(&lt;span style="color:#666">43&lt;/span>,&lt;span style="color:#666">0&lt;/span>); &lt;span style="color:#080;font-style:italic">//43% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>fees_[&lt;span style="color:#666">2&lt;/span>] &lt;span style="color:#666">=&lt;/span> F3Ddatasets.TeamFee(&lt;span style="color:#666">56&lt;/span>,&lt;span style="color:#666">10&lt;/span>); &lt;span style="color:#080;font-style:italic">//20% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>fees_[&lt;span style="color:#666">3&lt;/span>] &lt;span style="color:#666">=&lt;/span> F3Ddatasets.TeamFee(&lt;span style="color:#666">43&lt;/span>,&lt;span style="color:#666">8&lt;/span>); &lt;span style="color:#080;font-style:italic">//35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>
&lt;span style="color:#080;font-style:italic">// how to split up the final pot based on which team was picked
&lt;/span>&lt;span style="color:#080;font-style:italic">// (F3D, P3D)
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>potSplit_[&lt;span style="color:#666">0&lt;/span>] &lt;span style="color:#666">=&lt;/span> F3Ddatasets.PotSplit(&lt;span style="color:#666">15&lt;/span>,&lt;span style="color:#666">10&lt;/span>); &lt;span style="color:#080;font-style:italic">//48% to winner, 25% to next round, 2% to com
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>potSplit_[&lt;span style="color:#666">1&lt;/span>] &lt;span style="color:#666">=&lt;/span> F3Ddatasets.PotSplit(&lt;span style="color:#666">25&lt;/span>,&lt;span style="color:#666">0&lt;/span>); &lt;span style="color:#080;font-style:italic">//48% to winner, 25% to next round, 2% to com
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>potSplit_[&lt;span style="color:#666">2&lt;/span>] &lt;span style="color:#666">=&lt;/span> F3Ddatasets.PotSplit(&lt;span style="color:#666">20&lt;/span>,&lt;span style="color:#666">20&lt;/span>); &lt;span style="color:#080;font-style:italic">//48% to winner, 10% to next round, 2% to com
&lt;/span>&lt;span style="color:#080;font-style:italic">&lt;/span>potSplit_[&lt;span style="color:#666">3&lt;/span>] &lt;span style="color:#666">=&lt;/span> F3Ddatasets.PotSplit(&lt;span style="color:#666">30&lt;/span>,&lt;span style="color:#666">10&lt;/span>); &lt;span style="color:#080;font-style:italic">//48% to winner, 10% to next round, 2% to com
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有很多细节要分享，碍于时间有限，不过我会持续更新这里的&lt;/p>
&lt;h2 id="感想">感想&lt;/h2>
&lt;ul>
&lt;li>持有p3d的人和早期进入的才是最大的受益者&lt;/li>
&lt;li>后期进入的人只有通过拉人赚佣金的方式回本了&lt;/li>
&lt;li>这轮游戏应该是结束不了的： 总有人赔了，要拉人进来捞本，被拉的人周而复始。。。&lt;/li>
&lt;li>结束只有两个可能： 1. 合约有重大漏洞，资金被盗 2. 当大池子里48%的收益足以对整个以太网络发动51%攻击。。。&lt;/li>
&lt;li>矿工在背后偷着乐&lt;/li>
&lt;li>你们谁知道TeamJust的下个游戏的合约地址么？ 我知道！！！&lt;/li>
&lt;/ul>
&lt;p>如果你也找到了，可以加我微信&lt;code>yiyemeishui&lt;/code>， 加好友时请输入TeamJust的下个游戏合约地址，我们一起来票大的。。。&lt;/p></description></item><item><title>Docs: VSCode-开发已有的java项目</title><link>https://xiaoping378.github.io/docs/3-devops/java-in-vscode/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/java-in-vscode/</guid><description>
&lt;p>个人经验记录：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>install deps&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/vscode-java.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>clean workspace&lt;/p>
&lt;p>代开设置 Ctrl+Shift+P, 输入 &lt;code>clean java workspace&lt;/code> and restart&lt;/p>
&lt;/li>
&lt;li>
&lt;p>support lombok&lt;/p>
&lt;p>java代码出了名的冗长，lombok可以优雅解决此类问题，如果项目依赖了lombok， vsocde打开java项目就会显示各种&lt;code>cannot be resloved&lt;/code>错误,&lt;/p>
&lt;p>下面是我个人的配置,其中&lt;code>java.jdt.ls.vmargs&lt;/code>的配置（看个人项目maven依赖和安装路径了），会消除错误，并可以支持跳转：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#008000;font-weight:bold">&amp;#34;window.menuBarVisibility&amp;#34;&lt;/span>: &lt;span style="color:#b44">&amp;#34;toggle&amp;#34;&lt;/span>,
&lt;span style="color:#008000;font-weight:bold">&amp;#34;window.zoomLevel&amp;#34;&lt;/span>: &lt;span style="color:#666">1&lt;/span>,
&lt;span style="color:#008000;font-weight:bold">&amp;#34;explorer.confirmDelete&amp;#34;&lt;/span>: &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>,
&lt;span style="color:#008000;font-weight:bold">&amp;#34;workbench.colorTheme&amp;#34;&lt;/span>: &lt;span style="color:#b44">&amp;#34;Solarized Dark&amp;#34;&lt;/span>,
&lt;span style="color:#008000;font-weight:bold">&amp;#34;files.associations&amp;#34;&lt;/span>: {
&lt;span style="color:#008000;font-weight:bold">&amp;#34;default&amp;#34;&lt;/span>: &lt;span style="color:#b44">&amp;#34;toml&amp;#34;&lt;/span>
},
&lt;span style="color:#008000;font-weight:bold">&amp;#34;editor.fontLigatures&amp;#34;&lt;/span>: &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>,
&lt;span style="color:#008000;font-weight:bold">&amp;#34;java.configuration.checkProjectSettingsExclusions&amp;#34;&lt;/span>: &lt;span style="color:#a2f;font-weight:bold">false&lt;/span>,
&lt;span style="color:#008000;font-weight:bold">&amp;#34;go.autocompleteUnimportedPackages&amp;#34;&lt;/span>: &lt;span style="color:#a2f;font-weight:bold">true&lt;/span>,
&lt;span style="color:#008000;font-weight:bold">&amp;#34;java.jdt.ls.vmargs&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;-javaagent:/home/xxp/.m2/repository/./org/projectlombok/lombok/1.16.20/lombok-1.16.20.jar -Xbootclasspath/a:/home/xxp/.m2/repository/./org/projectlombok/lombok/1.16.20/lombok-1.16.20.jar&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>参考链接&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/redhat-developer/vscode-java/wiki/Lombok-support">https://github.com/redhat-developer/vscode-java/wiki/Lombok-support&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://code.visualstudio.com/docs/languages/java">https://code.visualstudio.com/docs/languages/java&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/redhat-developer/vscode-java/wiki/Troubleshooting">https://github.com/redhat-developer/vscode-java/wiki/Troubleshooting&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: DevOps实战-1</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-1/</guid><description>
&lt;p>本文主要介绍基于openshift如何完成&lt;code>开发-&amp;gt;测试-&amp;gt;线上&lt;/code>场景的变更，这是一个典型的应用生产流程，来看看openshift是如何利用容器优雅的完成整个过程的吧&lt;/p>
&lt;p>下文基于上篇&lt;a href="../openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0">DevOps实战-0&lt;/a> 的&lt;code>nodejs-ex&lt;/code>项目来说, 假设到这里，你本地已经有了nodejs-ex项目&lt;/p>
&lt;h3 id="准备3个project">准备3个project&lt;/h3>
&lt;p>用这3个project来模拟开发，测试，线上环境&lt;/p>
&lt;p>现实中一般各个场景的服务器都是物理隔离的，这里可以利用&lt;code>--node-selector&lt;/code>，来指定项目可以跑在哪些节点上。&lt;/p>
&lt;pre tabindex="0">&lt;code>oc login -u sysetm:admin
#晚上在笔记本上写此blog，没合适的环境，单机模拟多台 -- start
oc label node 192.168.31.49 web-prod=true web-dev=true web-test=true
#晚上在笔记本上写此blog，没合适的环境，单机模拟多台 -- end
#1.创建web-dev项目
#2.授权developer为开发组项目管理员
#3.授权测试和运维人员可以从开发组拉取镜像
oc adm new-project web-dev --node-selector='web-dev=true'
oc policy add-role-to-user admin developer
oc policy add-role-to-group system:image-puller system:serviceaccounts:web-test -n web-dev
oc policy add-role-to-group system:image-puller system:serviceaccounts:web-prod -n web-dev
oc adm new-project web-test --node-selector='web-test=true'
oc policy add-role-to-user admin tester
oc adm new-project web-prod --node-selector='web-prod=true'
oc policy add-role-to-user admin ops
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>你可能会注意到，这里用的&lt;code>new-project&lt;/code> 前面还加了adm， 其实&lt;code>oc adm&lt;/code>等效于&lt;code>oadm&lt;/code>， 一般管理集群相关的用这个命令，这里是因为需要读取节点的标签（label）信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指定项目要运行那些节点，则是利用了注解-annotations， 即在原有的project结构上设置了注解，这样openshift在相应的项目里创建任何pod时，都对会自动注入node-selector&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另外需要注意的，默认项目的管理员（developer）是没有权限读取node标签信息的，以前写过&lt;a href="../openshift%E5%AE%9E%E8%B7%B5-%E6%9D%83%E9%99%90%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86">权限管理相关blog&lt;/a>，集群管理员可以授权node访问权限，即使如此developer还是不能改写项目级别的标签的，举个例子: developer在开发环境的pod上指定了&lt;code>--node-selector='web-dev=false'&lt;/code>， 最终这个pod的node-selector会是&lt;code>'web-dev=true, web-dev=flase'&lt;/code>, 导致最终不会被调度到任何节点上。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>上面分别授权了3个用户，这里是不关心这些用户是否真实存在的，只是一个RABC的描述，因为是&lt;code>oc cluster up&lt;/code>起来的环境，默认使用&lt;code>anypassword&lt;/code>的身份认证，所以登录时，任意用户名和密码都是可以登录OK的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>oc describe policybinding -n web-dev&lt;/code> 可以查看授权情况， 如果觉得默认的role不满足需求的话，也可以自定义role，另外通过&lt;code>oc policy remove-role-from-group/user &amp;lt;Role&amp;gt; &amp;lt;name&amp;gt;&lt;/code>可以移除相关授权，&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="初始化web-dev-web-test-web-prod环境">初始化web-dev, web-test, web-prod环境&lt;/h3>
&lt;p>按照上篇&lt;code>DevOps实战-0&lt;/code>里的方式&lt;/p>
&lt;p>初始化我们的开发环境, 进入源码&lt;code>nodejs-ex&lt;/code>目录&lt;/p>
&lt;pre tabindex="0">&lt;code>oc new-app -f openshift/template/nodejs-mongo-persistent.json --name=nodejs-ex \
-p NPM_MIRROR=https://registry.npm.taobao.org \
-p SOURCE_REPOSITORY_URL=http://gogs-ci.192.168.31.49.xip.io/developer/nodejs-ex.git \
-n web-dev
&lt;/code>&lt;/pre>&lt;p>初始化测试环境，相较于上一步的模板json，只是注掉bc和更改了triggers的is,后面会详细介绍之间的差异&lt;/p>
&lt;pre tabindex="0">&lt;code>oc new-app -f openshift/template/nodejs-mongo-persistent-test.json --name=nodejs-ex-test -n web-test
&lt;/code>&lt;/pre>&lt;p>以tester登录web console，会发现只有mongodb部署上了，而前端nodejs还在等待依赖的镜像 &lt;code>web-dev/nodejs-mongo-persistent:test&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-web-test-wait.png" alt="webtest-wait">&lt;/p>
&lt;p>初始化生产环境, 这个生产的template.json有点儿简单，负载均衡和弹性伸缩都没有启用。&lt;/p>
&lt;pre tabindex="0">&lt;code>oc new-app -f openshift/template/nodejs-mongo-persistent-prod.json --name=nodejs-ex-prod -n web-prod
&lt;/code>&lt;/pre>&lt;h3 id="实战模拟-开发-测试-发布">实战模拟，开发-&amp;gt;测试-&amp;gt;发布&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>developer开发完特性或者修复完bug，push代码到镜像仓。&lt;/p>
&lt;p>这里分享一个很方便的技巧，就是 &lt;code>oc rsync&lt;/code>, 这个可以实时的同步本地目录到容器了，避免了频繁编译镜像和临时挂载目录到镜像里的hack了。&lt;/p>
&lt;pre tabindex="0">&lt;code>vim ...
git add .
git commit -m &amp;quot;fix bugs&amp;quot;
git push gogs master
&lt;/code>&lt;/pre>&lt;p>如上，由于上篇中设置了webhook, developer提交代码会触发了自动编译并部署，确认部署后的环境是否修复了bug，如果单元测试通过，那就要通知测试团队（如今大部分公司，应该没有测试人员了吧，也可以直接变更到线上）&lt;/p>
&lt;p>测试那边的环境里一直在等待这个镜像&lt;code>web-dev/nodejs-mongo-persistent:test&lt;/code>， 而默认developer配置成默认编译出来的是&lt;code>web-dev/nodejs-mongo-persistent:latest&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>oc login -u developer
oc tag web-dev/nodejs-mongo-persistent:latest web-dev/nodejs-mongo-persistent:v1.1
oc tag web-dev/nodejs-mongo-persistent:v1.1 web-dev/nodejs-mongo-persistent:test
&lt;/code>&lt;/pre>&lt;p>如上操作后，开发人员更新版本号，然后在web-dev环境里会打上一个test的镜像tag出来，操作完如下所示&lt;/p>
&lt;pre tabindex="0">&lt;code>➜ nodejs-ex git:(master) oc get is
NAME DOCKER REPO TAGS UPDATED
nodejs-mongo-persistent 172.30.1.1:5000/web-dev/nodejs-mongo-persistent test,v1.1,latest 49 seconds ago
➜ nodejs-ex git:(master)
➜ nodejs-ex git:(master) oc get istag
NAME DOCKER REF UPDATED IMAGENAME
nodejs-mongo-persistent:latest 172.30.1.1:5000/web-dev/nodejs-mongo-persistent@sha256:55615da49dd299064e7bba75923ac7996bf0d109e0322d4f84f9b41665b2e4c7 3 minutes ago sha256:55615da49dd299064e7bba75923ac7996bf0d109e0322d4f84f9b41665b2e4c7
nodejs-mongo-persistent:v1.1 172.30.1.1:5000/web-dev/nodejs-mongo-persistent@sha256:55615da49dd299064e7bba75923ac7996bf0d109e0322d4f84f9b41665b2e4c7 2 minutes ago sha256:55615da49dd299064e7bba75923ac7996bf0d109e0322d4f84f9b41665b2e4c7
nodejs-mongo-persistent:test 172.30.1.1:5000/web-dev/nodejs-mongo-persistent@sha256:55615da49dd299064e7bba75923ac7996bf0d109e0322d4f84f9b41665b2e4c7 55 seconds ago sha256:55615da49dd299064e7bba75923ac7996bf0d109e0322d4f84f9b41665b2e4c7
&lt;/code>&lt;/pre>&lt;p>这样一来，测试环境里就会自动部署上刚才开发人员的环境了，再也不会有因为环境差异问题和测试吵吵了。&lt;/p>
&lt;p>这一切都得益于openshift里新添加的imageStreams，它打通了编译和部署的环节，能自动通知对方，继而自动触发下一步动作。&lt;/p>
&lt;p>测试通过后，通知Ops再重新tag成线上所需要的镜像tag，这样线上就会根据配置自动滚动升级了。&lt;/p>
&lt;pre tabindex="0">&lt;code>#假设一个叫ops的人负责上线,那首先ops得有具备web-dev项目里编辑is的能力
oc login -u developer
#不该给ops这么高权限的，应该自定义一个只能tag is的role，这里为了简单演示
oc policy add-role-to-user edit ops -n web-dev
&lt;/code>&lt;/pre>&lt;p>如上操纵，ops就具备了tag web-dev项目的镜像的能力，也可以通过UI来查看和授权&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-add-role.png" alt="">&lt;/p>
&lt;pre tabindex="0">&lt;code>oc login -u ops
oc tag web-dev/nodejs-mongo-persistent:v1.1 web-dev/nodejs-mongo-persistent:prod
&lt;/code>&lt;/pre>&lt;p>然后打上线上依赖的镜像tag即可，发布上线，这样就完成了开发-&amp;gt;测试-&amp;gt;发布一条线，很快捷的&lt;code>人工干预&lt;/code>上线了&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>openshift 利用镜像tag的能力，来实现不同场景的同步，单纯基于docker也可以实现以上目标的，只是不够平台化，还是以前的脚本打天下，远不如openshift在API层面解决来的强大和灵活。&lt;/p></description></item><item><title>Docs: k8s的监控方案</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/kuerbernetes%E7%9A%84%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/kuerbernetes%E7%9A%84%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/</guid><description>
&lt;h2 id="方案选型">方案选型&lt;/h2>
&lt;p>如果已存在完善的监控系统的话，推荐使用k8s原生的&lt;strong>heapster&lt;/strong>，比较轻量，容易集成。&lt;/p>
&lt;p>我选择的是&lt;strong>prometheus&lt;/strong>, 它是比较完善的云平台级监控方案，继k8s之后同样已被列入&lt;a href="https://cncf.io/projects">云计算基金会&lt;/a>项目, 除了具备heapster的能力之外，还支持监控广泛的应用(mysql, JMX, HAProxy等)和灵活的告警的能力，并具备多IDC federation的能力，兼容多种开源监控系统（StatsD, Ganglia, collectd, nagios等）。&lt;/p>
&lt;p>本文主要参考&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/heapster/issues/645">prometheus和heapster开发者之间的对话&lt;/a>&lt;/li>
&lt;li>CoreOS的blog&lt;a href="https://coreos.com/blog/monitoring-kubernetes-with-prometheus.html">Monitoring Kubernetes with Prometheus&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>下面分别介绍下两种方案&lt;/p>
&lt;h3 id="heapster">heapster&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>heapster的介绍:&lt;/p>
&lt;p>通过向kubelet拉取stats的方式， 可提供15分钟内的缓存供k8s的dashboard用，也支持第三方存储，如influxdb等，还具备REST API(经我实验，这个API还不完善 &lt;a href="https://github.com/kubernetes/heapster/issues/1155">缺少diskIO API&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>heapster的监控范围&lt;/p>
&lt;p>可监控的内容包括集群内的Container, Pod, Node 和 Namespace的性能或配置信息，
目前container级别还不支持网络和硬盘信息，具体性能项如下&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Metric Name&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>cpu/limit&lt;/td>
&lt;td>CPU hard limit in millicores.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cpu/node_capacity&lt;/td>
&lt;td>Cpu capacity of a node.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cpu/node_allocatable&lt;/td>
&lt;td>Cpu allocatable of a node.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cpu/node_reservation&lt;/td>
&lt;td>Share of cpu that is reserved on the node allocatable.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cpu/node_utilization&lt;/td>
&lt;td>CPU utilization as a share of node allocatable.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cpu/request&lt;/td>
&lt;td>CPU request (the guaranteed amount of resources) in millicores.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cpu/usage&lt;/td>
&lt;td>Cumulative CPU usage on all cores.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cpu/usage_rate&lt;/td>
&lt;td>CPU usage on all cores in millicores.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filesystem/usage&lt;/td>
&lt;td>Total number of bytes consumed on a filesystem.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filesystem/limit&lt;/td>
&lt;td>The total size of filesystem in bytes.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filesystem/available&lt;/td>
&lt;td>The number of available bytes remaining in a the filesystem&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/limit&lt;/td>
&lt;td>Memory hard limit in bytes.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/major_page_faults&lt;/td>
&lt;td>Number of major page faults.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/major_page_faults_rate&lt;/td>
&lt;td>Number of major page faults per second.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/node_capacity&lt;/td>
&lt;td>Memory capacity of a node.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/node_allocatable&lt;/td>
&lt;td>Memory allocatable of a node.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/node_reservation&lt;/td>
&lt;td>Share of memory that is reserved on the node allocatable.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/node_utilization&lt;/td>
&lt;td>Memory utilization as a share of memory allocatable.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/page_faults&lt;/td>
&lt;td>Number of page faults.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/page_faults_rate&lt;/td>
&lt;td>Number of page faults per second.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/request&lt;/td>
&lt;td>Memory request (the guaranteed amount of resources) in bytes.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/usage&lt;/td>
&lt;td>Total memory usage.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>memory/working_set&lt;/td>
&lt;td>Total working set usage. Working set is the memory being used and not easily dropped by the kernel.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network/rx&lt;/td>
&lt;td>Cumulative number of bytes received over the network.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network/rx_errors&lt;/td>
&lt;td>Cumulative number of errors while receiving over the network.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network/rx_errors_rate&lt;/td>
&lt;td>Number of errors while receiving over the network per second.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network/rx_rate&lt;/td>
&lt;td>Number of bytes received over the network per second.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network/tx&lt;/td>
&lt;td>Cumulative number of bytes sent over the network&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network/tx_errors&lt;/td>
&lt;td>Cumulative number of errors while sending over the network&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network/tx_errors_rate&lt;/td>
&lt;td>Number of errors while sending over the network&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network/tx_rate&lt;/td>
&lt;td>Number of bytes sent over the network per second.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uptime&lt;/td>
&lt;td>Number of milliseconds since the container was started.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="prometheus">Prometheus&lt;/h3>
&lt;p>Prometheus集成了数据采集，存储，异常告警多项功能，是一款一体化的完整方案。 它针对大规模的集群环境设计了拉取式的数据采集方式、多维度数据存储格式以及服务发现等创新功能。&lt;/p>
&lt;h4 id="功能特点">功能特点：&lt;/h4>
&lt;pre>&lt;code>* 多维数据模型（有metric名称和键值对确定的时间序列）
* 灵活的查询语言
* 不依赖分布式存储
* 通过pull方式采集时间序列，通过http协议传输
* 支持通过中介网关的push时间序列的方式
* 监控数据通过服务或者静态配置来发现
* 支持多维度可视化分析和dashboard等
&lt;/code>&lt;/pre>
&lt;h4 id="组件介绍">组件介绍：&lt;/h4>
&lt;p>这个生态里包含的组件，大多是可选的：
* 核心prometheus server提供收集和存储时间序列数据
* 大量的&lt;a href="https://prometheus.io/docs/instrumenting/clientlibs/">client libraries&lt;/a>来支持应用业务代码的探针
* 适用于短时任务的push gateway
* 基于Rails/SQL语句的可视化分析
* 特殊用途的exporter（包括HAProxy、StatsD、Ganglia等）
* 用于报警的alertmanager
* 支持命令行查询的工具
* 其他工具
大多数的组件都是用Go语言来完成的，使得它们方便构建和部署。&lt;/p>
&lt;h4 id="架构图">架构图：&lt;/h4>
&lt;p>&lt;img src="https://xiaoping378.github.io/prometheus-architecture.png" alt="架构图">&lt;/p>
&lt;p>Promethues直接或通过短期Jobs的中介网关拉取收集指标。 它在本地存储所有抓取的数据样本，并对数据进行规则匹配检测，这样可以基于现有数据创建新的时间系列指标或生成警报。
PromDash或其他API使用者对收集的数据进行可视化。&lt;/p>
&lt;h4 id="引入prometheus对k8s的影响">引入Prometheus对k8s的影响&lt;/h4>
&lt;p>下图是Redhat研发人员的回答&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/prometheus-affect-k8s.png" alt="promethue-affect-k8s">&lt;/p>
&lt;p>并不会对k8s产生太大的影响，其主要是通过api-server来发现需要监控的目标，然后会周期性的通过各个Node上kubelet来拉取数据。
更详细的讨论见&lt;a href="https://github.com/prometheus/prometheus/pull/905">这里&lt;/a>&lt;/p>
&lt;h3 id="部署prometheus">部署Prometheus&lt;/h3>
&lt;p>下文是基于&lt;a href="https://github.com/xiaoping378/k8s-monitor">k8s-monitor项目&lt;/a>来说的&lt;/p>
&lt;p>&lt;a href="https://prometheus.io/">Prometheus&lt;/a> is an open-source monitoring solution that includes the gathering of metrics, their storage in an internal time series database as well as querying and alerting based on that data.&lt;/p>
&lt;p>It offers a lot of integrations incl. Docker, Kubernetes, etc.&lt;/p>
&lt;p>Prometheus can also visualize your data. However, in this recipe we include another open-source tool, &lt;a href="http://grafana.org/">Grafana&lt;/a>, for the visualization part, as it offers a more powerful and flexible way to generate visuals and dashboards.&lt;/p>
&lt;p>If you just want to get Prometheus and Grafana up and running you can deploy the whole recipe with a single command instead of going through all steps detailed out below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl create --filename manifests/
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="deploying-prometheus">Deploying Prometheus&lt;/h2>
&lt;p>First, we need to create the configuration for our Prometheus. For this we use a Config Map, which we later mount into our Prometheus pod to configure it. This way we can change the configuration without having to redeploy Prometheus itself.&lt;/p>
&lt;p>&lt;code>kubectl create --filename manifests/prometheus-core-configmap.yaml&lt;/code>&lt;/p>
&lt;p>Then, we create a service to be able to access Prometheus.&lt;/p>
&lt;p>&lt;code>kubectl create --filename manifests/prometheus-core-service.yaml&lt;/code>&lt;/p>
&lt;p>Finally, we can deploy Prometheus itself.&lt;/p>
&lt;p>&lt;code>kubectl create --filename manifests/prometheus-core-deployment.yaml&lt;/code>&lt;/p>
&lt;p>Further, we need the Prometheus Node Exporter deployed to each node. For this we use a Daemon Set and a fronting service for Prometheus to be able to access the node exporters.&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl create --filename manifests/prometheus-node-exporter-service.yaml
kubectl create --filename manifests/prometheus-node-exporter-daemonset.yaml
&lt;/code>&lt;/pre>&lt;p>Wait a bit for all the pods to come up. Then Prometheus should be ready and running. We can check the Prometheus targets at &lt;a href="https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/prometheus/targets">https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/prometheus/targets&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/prometheus_targets.png" alt="Prometheus Targets">&lt;/p>
&lt;h2 id="deploying-alertmanager">Deploying Alertmanager&lt;/h2>
&lt;p>we need to create the configuration for our Alertmanager. For this we use a Config Map, which we later mount into our Alertmanager pod to configure it. This way we can change the configuration without having to redeploy Alertmanager itself.&lt;/p>
&lt;p>&lt;code>kubectl create --filename manifests/prometheus-alert-configmap.yaml&lt;/code>&lt;/p>
&lt;p>Then, we create a service to be able to access Alertmanager.&lt;/p>
&lt;p>&lt;code>kubectl create --filename manifests/prometheus-alert-service.yaml&lt;/code>&lt;/p>
&lt;p>Finally, we can deploy Alertmanager itself.&lt;/p>
&lt;p>&lt;code>kubectl create --filename manifests/prometheus-alert-deployment.yaml&lt;/code>&lt;/p>
&lt;p>Wait a bit for all the pods to come up. Then Alertmanager should be ready and running. We can check the Alertmanager targets at
&lt;a href="https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/alertmanager/">https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/alertmanager/&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/alertmanager.png" alt="Alertmanager">&lt;/p>
&lt;h2 id="deploying-grafana">Deploying Grafana&lt;/h2>
&lt;p>Now that we have Prometheus up and running we can deploy Grafana to have a nicer frontend for our metrics.&lt;/p>
&lt;p>Again, we create a service to be able to access Grafana and a deployment to manage the pods.&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl create --filename manifests/grafana-services.yaml
kubectl create --filename manifests/grafana-deployment.yaml
&lt;/code>&lt;/pre>&lt;p>Wait a bit for Grafana to come up. Then you can access Grafana at &lt;a href="https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/grafana/">https://mycluster.k8s.gigantic.io/api/v1/proxy/namespaces/default/services/grafana/&lt;/a>&lt;/p>
&lt;h2 id="setting-up-grafana">Setting Up Grafana&lt;/h2>
&lt;p>TLDR: If you don't want to go through all the manual steps below you can let the following job use the API to configure Grafana to a similar state.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl create --filename manifests/grafana-import-dashboards-job.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once we're in Grafana we need to first configure &lt;a href="https://grafana.net/plugins/prometheus">Prometheus&lt;/a> as a data source.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Grafana UI / Data Sources / Add data source&lt;/code>
&lt;ul>
&lt;li>&lt;code>Name&lt;/code>: &lt;code>prometheus&lt;/code>&lt;/li>
&lt;li>&lt;code>Type&lt;/code>: &lt;code>Prometheus&lt;/code>&lt;/li>
&lt;li>&lt;code>Url&lt;/code>: &lt;code>http://prometheus:9090&lt;/code>&lt;/li>
&lt;li>&lt;code>Add&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://xiaoping378.github.io/grafana_datasource.png" alt="Grafana Datasource">&lt;/p>
&lt;p>Then go to the Dashboards tab and import the &lt;a href="https://grafana.net/dashboards/2">Prometheus Stats dashboard&lt;/a>, which shows the status of Prometheus itself.&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/grafana_datasource_dashboard.png" alt="Grafana Datasource Dashboard">&lt;/p>
&lt;p>You can check it out to see how your Prometheus is doing.&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/grafana_prometheus_stats.png" alt="Grafana Datasource Dashboard">&lt;/p>
&lt;p>Last, but not least we can import a sample &lt;a href="https://grafana.net/dashboards/597">Kubernetes cluster monitoring dashboard&lt;/a>, to get a first overview over our cluster metrics.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Grafana UI / Dashboards / Import&lt;/code>
&lt;ul>
&lt;li>&lt;code>Grafana.net Dashboard&lt;/code>: &lt;code>https://grafana.net/dashboards/597&lt;/code>&lt;/li>
&lt;li>&lt;code>Load&lt;/code>&lt;/li>
&lt;li>&lt;code>Prometheus&lt;/code>: &lt;code>prometheus&lt;/code>&lt;/li>
&lt;li>&lt;code>Save &amp;amp; Open&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://xiaoping378.github.io/grafana_import_dashboard.png" alt="Grafana Import Dashboard">&lt;/p>
&lt;p>Voilá. You have a nice first dashboard with metrics of your Kubernetes cluster.&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/grafana_cluster_overview.png" alt="Grafana Import Dashboard">&lt;/p>
&lt;h2 id="next-steps">Next Steps&lt;/h2>
&lt;p>Next, you should get into the &lt;a href="http://docs.grafana.org/">Grafana&lt;/a> and &lt;a href="https://prometheus.io/docs/introduction/overview/">Prometheus&lt;/a> documentations to get to know the tools and either build your own dashboards or extend the samples from above.&lt;/p>
&lt;p>You can also check out grafana.net for some more example &lt;a href="https://grafana.net/dashboards">dashboards&lt;/a> and &lt;a href="https://grafana.net/plugins">plugins&lt;/a>.&lt;/p>
&lt;p>More Alertmanager documentations in &lt;a href="https://prometheus.io/docs/alerting/overview/">here&lt;/a>&lt;/p></description></item><item><title>Docs: KVM和Libvirt的实践整理</title><link>https://xiaoping378.github.io/docs/4-cloud/kvm-virsh%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/kvm-virsh%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/</guid><description>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>此前一直用Virtualbox操作虚机的东西，对于个人搭建环境还是显的有些笨重，不能实现Iac的目标，故尝试了Vagrant和Libvirt，综合考虑我选择libvirt继续深入下去，也是希望以后有机会可以深入搞下openstack的nova组件。&lt;/p>
&lt;h2 id="安装必要依赖">安装必要依赖&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo apt install bridge-utils qemu-kvm virtinst -y
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>qemu-kvm: 这个负责hypervisor层和仿真器（可以模拟x86, arm体系）.&lt;/li>
&lt;li>virtinst: 安装和管理虚机的命令行工具&lt;/li>
&lt;li>bridge-utils： 创建和管理bridge网络&lt;/li>
&lt;/ul>
&lt;p>安装完输入&lt;code>kvm-ok&lt;/code>查看是否安装OK，另外还&lt;code>需要重启&lt;/code>以使kvm和libvirt daemon启动。&lt;/p>
&lt;h2 id="配置网络">配置网络&lt;/h2>
&lt;p>未完。。。&lt;/p></description></item><item><title>Docs: 解读cosmos-sdk系列(1)</title><link>https://xiaoping378.github.io/docs/5-blockchain/cosmos_sdk_1/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/cosmos_sdk_1/</guid><description>
&lt;p>通过本系列，可以了解tendermint共识和cosmos-sdk架构的设计思想，并学习到如何通过Cosmos-SDK来快速开发自己的区块链应用。&lt;/p>
&lt;p>cosmos团队把区块链分成了三层&lt;/p>
&lt;ul>
&lt;li>网络层 - p2p负责广播交易&lt;/li>
&lt;li>共识层 - 对哪些交易打包进块形成共识&lt;/li>
&lt;li>应用层 - 执行交易，负责交易结果落盘（状态一致）&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里的应用层可能会有误解，并非是Dapp层，对于SDK底层的Tendermint来说，除p2p网络和打包块共识外，其他都算是应用部分，
拿实现比特币公链的例子来讲，应用部分就是维护账户的UTXO数据库，如果对比以太的话，keystore账户和EVM虚机部分就是应用范畴，所以SDK内置了账户、质押、治理、权限等应用模块，可以帮助我们简单地实现底层链的开发。&lt;/p>
&lt;/blockquote>
&lt;p>可以把这几层简单理解成各节点通过同步交易集（块）日志，实现数据（状态）一致性。数据库的主从模式不也是同步binlog日志，各自执行（replay，回放）日志后，实现数据（状态）最终落盘，区块节点本身同步块的时候，默认就是去下载交易日志，把执行结果按照逻辑链的形式写入本地leveldb的，然后才能对外提供各类RPC服务。&lt;/p>
&lt;h2 id="tendermint共识">tendermint共识&lt;/h2>
&lt;p>为后续更好的利用cosmos-sdk，要先了解下Tendermint。&lt;/p>
&lt;p>Tendermint Core 提供了网络和共识层功能，而应用层要通过ABCI协议和Core互通消息msg，简单讲tendermint负责起一个replication engine进程，而应用层要运行一个state macheine进程，进程间通过ABCI消息来通信。&lt;/p>
&lt;p>ABCI协议的消息体用protobuf定义在&lt;a href="https://github.com/tendermint/tendermint/blob/master/abci/types/types.proto">这里&lt;/a>，app侧可以响应的request如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-golang" data-lang="golang">message Request {
oneof value {
RequestEcho echo = &lt;span style="color:#666">2&lt;/span>;
RequestFlush flush = &lt;span style="color:#666">3&lt;/span>;
RequestInfo info = &lt;span style="color:#666">4&lt;/span>;
RequestSetOption set_option = &lt;span style="color:#666">5&lt;/span>;
RequestInitChain init_chain = &lt;span style="color:#666">6&lt;/span>;
RequestQuery query = &lt;span style="color:#666">7&lt;/span>;
RequestBeginBlock begin_block = &lt;span style="color:#666">8&lt;/span>;
RequestCheckTx check_tx = &lt;span style="color:#666">9&lt;/span>;
RequestDeliverTx deliver_tx = &lt;span style="color:#666">19&lt;/span>;
RequestEndBlock end_block = &lt;span style="color:#666">11&lt;/span>;
RequestCommit commit = &lt;span style="color:#666">12&lt;/span>;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ABCI的设计主要有以下几个特点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>消息协议&lt;/p>
&lt;ul>
&lt;li>成对出现的消息: &lt;code>request&lt;/code>/&lt;code>reponse&lt;/code>&lt;/li>
&lt;li>tendermint发起Request， app来响应&lt;/li>
&lt;li>使用protobuf定义&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>server/client&lt;/p>
&lt;ul>
&lt;li>tendermint运行client&lt;/li>
&lt;li>app侧运行server端&lt;/li>
&lt;li>可以由TSP（支持checkTx和DeliverTx消息的异步处理）、grpc两种方式实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>区块相关&lt;/p>
&lt;ul>
&lt;li>abci是面向连接的&lt;/li>
&lt;li>tendermint会创建三个socket连接来和app通信，分别是&lt;code>Mempool&lt;/code>, &lt;code>Cosensus&lt;/code>, &lt;code>Query&lt;/code>连接
&lt;ul>
&lt;li>
&lt;p>&lt;code>Mempool连接&lt;/code>: 钱包客户端发起交易，会首先进入钱包后台连接的节点的local mempool，该节点通过发送&lt;code>checkTx&lt;/code>消息来通知app，去检验交易签名是否有效等等，如果OK节点则会p2p广播该交易到其他节点的mempool里。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Cosensus连接&lt;/code>: 出块节点从mempool的交易集里选出一个块提案（proposer），之后会经过3阶段提交（pre-vote, pre-commit， commit）处理，这个块才能说达成共识（上链了），，只有块被commited了，app侧才会更新状态，比如改变某地址余额等等。app更新状态的时候，是通过Core发送&lt;code>BeginBlock&lt;/code>， &lt;code>DeliverTx ...&lt;/code>， &lt;code>EndBlock&lt;/code>, &lt;code>Commit&lt;/code>消息给app侧来完成的，任何写入操作都是通过此连接完成的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Query连接&lt;/code>： 主要负责一些和共识无关的查询操作，比如块信息，地址余额等等，主要用到&lt;code>Info&lt;/code>, &lt;code>SetOption&lt;/code>, &lt;code>Query&lt;/code>消息&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>整个abci的信息流大致如下：
&lt;img src="https://xiaoping378.github.io/abci.png" alt="abci">&lt;/p>
&lt;p>关于Tendermint和app间数据流的更多细节见下：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/tm-transaction-flow.png" alt="dataFlow">&lt;/p>
&lt;p>&lt;a href="https://github.com/mobfoundry/hackatom/blob/master/tminfo.pdf">高清图地址&lt;/a>&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>可以理解成，Tendermint主要负责在BFT环境下同步app间的块交易日志，无论任何交易类型，只要交易块的执行结果是确定性的（唯一性），Tendermint就可以为我们形成区块的共识。&lt;/p>
&lt;pre>&lt;code>比如说，一个交易的内容在合约里创建一个真随机数，这种交易，tendermint是无法为我们形成共识的，因为多个节点的执行结果是不一样的， 因为这个结果是要在下个区块头的，这样就无法对下个区块形成共识了，所有节点都认为对方在恶意“搞分叉”了。
&lt;/code>&lt;/pre>
&lt;p>目前基于tendermint的项目有很多：&lt;/p>
&lt;p>我个人看到好的是&lt;code>BigchainDB&lt;/code>和超级账本&lt;code>Burrow&lt;/code>项目，更多可以看&lt;a href="https://tendermint.com/ecosystem">这里&lt;/a>&lt;/p>
&lt;p>后续源码介绍，如何基于tendermint创建一个区块链&lt;/p></description></item><item><title>Docs: 编译和目录结构介绍</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E6%BA%90%E7%A0%81-%E7%BC%96%E8%AF%91%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E6%BA%90%E7%A0%81-%E7%BC%96%E8%AF%91%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid><description>
&lt;p>介绍openshift的源码编译和目录结构组织，为了方便代码调试和了解大型Golang项目的构建方式&lt;/p>
&lt;h3 id="编译">编译&lt;/h3>
&lt;p>无论是openshift还是Kubernetes等大型Golang项目都用到了&lt;code>Makefile&lt;/code>, 所以有必要从此开始说起，这里只说项目里用到的makefile特性，想了解更多的可以参考&lt;a href="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf">跟我一起写Makefile&lt;/a>&lt;/p>
&lt;h4 id="makefile介绍">Makefile介绍&lt;/h4>
&lt;blockquote>
&lt;p>makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、
模块分别放在若干个目录中，makefile 定义了一系列的规则来指定，哪些文件需要先编译，
哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为
makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。 makefile 带来的好
处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，
极大的提高了软件开发的效率。&lt;/p>
&lt;/blockquote>
&lt;p>Makefile里的规则，就在做两件事，一个是指明依赖关系，另一个是生成目标的方法&lt;/p>
&lt;p>Golang项目里用到的Makefile规则比较简单，基本就是定义一个目标的生成方法，下面的示例是Openshift项目里makefile中定义的第一个目标。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="color:#00a000">all build&lt;/span>&lt;span style="color:#666">:&lt;/span>
hack/build-go.sh &lt;span style="color:#a2f;font-weight:bold">$(&lt;/span>WHAT&lt;span style="color:#a2f;font-weight:bold">)&lt;/span> &lt;span style="color:#a2f;font-weight:bold">$(&lt;/span>GOFLAGS&lt;span style="color:#a2f;font-weight:bold">)&lt;/span>
&lt;span style="color:#00a000">.PHONY&lt;/span>&lt;span style="color:#666">:&lt;/span> all build
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>all build&lt;/code>，是定义的目标，看到这个就知道可以在源码的根目录上执行&lt;code>make all build&lt;/code>来编译了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二行说明生成目标的方法，就是去hack目录下执行build-go.sh脚本，这里还支持传入一些参数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第三行 &lt;code>.PHONY&lt;/code>，起到一个标识的作用，没什么实际意义，是用来告诉make命令，这里是个伪目标，也可以说成是默认目标，所以在openshift的根目录上直接执行&lt;code>make&lt;/code>, 等效于&lt;code>make all build&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>还可以自己决定是否编译出镜像或者rpm包（make release, make build-rpms）&lt;/p>
&lt;h4 id="编译openshift">编译openshift&lt;/h4>
&lt;p>上边介绍了，直接敲&lt;code>make&lt;/code>就可以自动编译出所有平台（linux, mac, windows）的二进制，编译前介绍两个hack方法，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在hack/build-go.sh的第二行加上&lt;code>set -x&lt;/code>， 这样的话，shell脚本在运行时，里面的所有变量和执行路径会全部打印出来，一目了然，不用自己一行一行的加echo debug了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如下修改hack/build-cross.sh，不然会编译出多平台的二进制，花的时间略长啊。。。&lt;/p>
&lt;pre tabindex="0">&lt;code># by default, build for these platforms
platforms=(
linux/amd64
# darwin/amd64
# windows/amd64
# linux/386
)
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>下面简易说下执行make后，都发生了什么，只会捡关键点说。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">➜ origin git:&lt;span style="color:#666">(&lt;/span>xxpDev&lt;span style="color:#666">)&lt;/span> ✗ make
hack/build-go.sh
&lt;span style="color:#080;font-style:italic"># 初始化一大堆变量，关键函数都在common.sh里实现的&lt;/span>
&lt;span style="color:#a2f">source&lt;/span> hack/common.sh hack/util.sh hack/lib目录下的所有脚本
&lt;span style="color:#080;font-style:italic"># 还会改动GOPATH,然后会在$GOPATH/src/github.com/openshift下建个软连指向origin目录&lt;/span>
&lt;span style="color:#a2f">export&lt;/span> &lt;span style="color:#b8860b">GOPATH&lt;/span>&lt;span style="color:#666">=&lt;/span>_output/local/go
&lt;span style="color:#080;font-style:italic"># 最终组合成下面一条最原始的命令，来进行编译&lt;/span>
go install &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> -pkgdir /home/xxp/Github/src/github.com/openshift/origin/_output/local/pkgdir/linux/amd64 &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> -tags &lt;span style="color:#b44">&amp;#39; &amp;#39;&lt;/span> &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> -ldflags &lt;span style="color:#b44">&amp;#39;-X github.com/openshift/origin/pkg/bootstrap/docker.defaultImageStreams=centos7 \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/pkg/cmd/util/variable.DefaultImagePrefix=openshift/origin \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/pkg/version.majorFromGit=3 \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/pkg/version.minorFromGit=6+ \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/pkg/version.versionFromGit=v3.6.0-alpha.0+83e3250-176-dirty \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/pkg/version.commitFromGit=83e3250 \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/pkg/version.buildDate=2017-04-06T05:34:29Z \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/vendor/k8s.io/kubernetes/pkg/version.gitCommit=43a9be4 \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/vendor/k8s.io/kubernetes/pkg/version.gitVersion=v1.5.2+43a9be4 \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/vendor/k8s.io/kubernetes/pkg/version.buildDate=2017-04-06T05:34:29Z \
&lt;/span>&lt;span style="color:#b44"> -X github.com/openshift/origin/vendor/k8s.io/kubernetes/pkg/version.gitTreeState=clean&amp;#39;&lt;/span> &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> github.com/openshift/origin/cmd/openshift &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> github.com/openshift/origin/cmd/oc &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> github.com/openshift/origin/pkg/sdn/plugin/sdn-cni-plugin &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> github.com/openshift/origin/vendor/github.com/containernetworking/cni/plugins/ipam/host-local &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> github.com/openshift/origin/vendor/github.com/containernetworking/cni/plugins/main/loopback
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到openshift会编译出5个二进制来，其中3个和网络CNI接口有关，最后会放置到_output/local/bin/linux/amd64, 并作相关的软链接（oadm, kubelet）&lt;/p>
&lt;p>所以以后分析程序的切入点就从cmd/openshift和 cmd/oc入手就行了&lt;/p>
&lt;p>来看下编译成果&lt;/p>
&lt;pre tabindex="0">&lt;code>➜ origin git:(xxpDev) ✗ _output/local/bin/linux/amd64/oc version
oc v3.6.0-alpha.0+83e3250-176-dirty
kubernetes v1.5.2+43a9be4
features: Basic-Auth
&lt;/code>&lt;/pre>&lt;p>看到输出&lt;code>v3.6.0-alpha.0+83e3250-176-dirty&lt;/code>， 这就是上面编译时传进去的参数。&lt;/p>
&lt;p>&lt;code>-X github.com/openshift/origin/pkg/version.majorFromGit=3&lt;/code>,意思是说编译文件&lt;code>github.com/openshift/origin/pkg/version.go&lt;/code>时，对常量majorFromGit赋值为3&lt;/p>
&lt;h3 id="项目目录结构">项目目录结构&lt;/h3>
&lt;p>-- 未完待续&lt;/p></description></item><item><title>Docs: MongoDB之初见</title><link>https://xiaoping378.github.io/docs/3-devops/mogodb-0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/mogodb-0/</guid><description>
&lt;ol>
&lt;li>手动启动&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 下载二进制&lt;/span>
wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.9.tgz
tar -zxvf mongodb-linux-x86_64-3.4.9.tgz
ln -s &lt;span style="color:#b8860b">$PWD&lt;/span>/mongodb-linux-x86_64-3.4.9/bin/* /home/xxp/Software/bin
&lt;span style="color:#080;font-style:italic"># 创建数据存储目录 &lt;/span>
mkdir mongodb
sudo chown -R &lt;span style="color:#b8860b">$USER&lt;/span> ./mongodb
mongod -dbpath&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b8860b">$PWD&lt;/span>/mongodb
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认监听27017， 根据情况选择关闭warning。&lt;/p>
&lt;ol start="2">
&lt;li>推荐调试方法&lt;/li>
&lt;/ol>
&lt;p>默认可以使用&lt;code>mongo&lt;/code>进入shell交互模式，
亦可使用图形管理界面，推荐&lt;code>robo3T&lt;/code>, 目前1.1.1版本在ubuntu桌面上有crash问题，需要如下操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl -O https://download.robomongo.org/1.1.1/linux/robo3t-1.1.1-linux-x86_64-c93c6b0.tar.gz
tar zxvf robo3t-1.1.1-linux-x86_64-c93c6b0.tar.gz
mkdir ~/robo-backup
mv robo3t-1.1.1-linux-x86_64-c93c6b0/lib/libstdc++* ~/robo-backup/
robo3t-1.1.1-linux-x86_64-c93c6b0/bin/robo3t
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://xiaoping378.github.io/robo3t.png" alt="">&lt;/p>
&lt;ol>
&lt;li>基本使用&lt;/li>
&lt;/ol>
&lt;p>shell里敲mongo进入交互界面，&lt;/p>
&lt;p>手续推荐查看&lt;a href="http://www.mongoing.com/docs/reference/sql-comparison.html">mongodb中文文档&lt;/a>&lt;/p></description></item><item><title>Docs: 配置harbor默认https访问</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/harbor_https/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/harbor_https/</guid><description>
&lt;p>因为使用自签证书（reg.300.cn），所以需要把中间过程生成的ca.crt拷贝到需要pull/push的node上 (懒的翻译了，很详细的文档，已验证OK)&lt;/p>
&lt;p>Because Harbor does not ship with any certificates, it uses HTTP by default to serve registry requests. This makes it relatively simple to configure. However, it is highly recommended that security be enabled for any production environment. Harbor has an Nginx instance as a reverse proxy for all services, you can configure Nginx to enable https.&lt;/p>
&lt;p>##Getting a certificate&lt;/p>
&lt;p>Assuming that your registry's &lt;strong>hostname&lt;/strong> is &lt;strong>reg.yourdomain.com&lt;/strong>, and that its DNS record points to the host where you are running Harbor. You first should get a certificate from a CA. The certificate usually contains a .crt file and a .key file, for example, &lt;strong>yourdomain.com.crt&lt;/strong> and &lt;strong>yourdomain.com.key&lt;/strong>.&lt;/p>
&lt;p>In a test or development environment, you may choose to use a self-signed certificate instead of the one from a CA. The below commands generate your own certificate:&lt;/p>
&lt;ol>
&lt;li>Create your own CA certificate:&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code> openssl req \
-newkey rsa:4096 -nodes -sha256 -keyout ca.key \
-x509 -days 365 -out ca.crt
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>Generate a Certificate Signing Request:&lt;/li>
&lt;/ol>
&lt;p>If you use FQDN like &lt;strong>reg.yourdomain.com&lt;/strong> to connect your registry host, then you must use &lt;strong>reg.yourdomain.com&lt;/strong> as CN (Common Name).
Otherwise, if you use IP address to connect your registry host, CN can be anything like your name and so on:&lt;/p>
&lt;pre tabindex="0">&lt;code> openssl req \
-newkey rsa:4096 -nodes -sha256 -keyout yourdomain.com.key \
-out yourdomain.com.csr
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>Generate the certificate of your registry host:&lt;/li>
&lt;/ol>
&lt;p>On Ubuntu, the config file of openssl locates at &lt;strong>/etc/ssl/openssl.cnf&lt;/strong>. Refer to openssl document for more information. The default CA directory of openssl is called demoCA. Let's create necessary directories and files:&lt;/p>
&lt;pre tabindex="0">&lt;code> mkdir demoCA
cd demoCA
touch index.txt
echo '01' &amp;gt; serial
cd ..
&lt;/code>&lt;/pre>&lt;p>If you're using FQDN like &lt;strong>reg.yourdomain.com&lt;/strong> to connect your registry host, then run this command to generate the certificate of your registry host:&lt;/p>
&lt;pre tabindex="0">&lt;code> openssl ca -in yourdomain.com.csr -out yourdomain.com.crt -cert ca.crt -keyfile ca.key -outdir .
&lt;/code>&lt;/pre>&lt;p>If you're using &lt;strong>IP&lt;/strong> to connect your registry host, you may instead run the command below:&lt;/p>
&lt;pre tabindex="0">&lt;code>
echo subjectAltName = IP:your registry host IP &amp;gt; extfile.cnf
openssl ca -in yourdomain.com.csr -out yourdomain.com.crt -cert ca.crt -keyfile ca.key -extfile extfile.cnf -outdir .
&lt;/code>&lt;/pre>&lt;p>##Configuration of Nginx
After obtaining the &lt;strong>yourdomain.com.crt&lt;/strong> and &lt;strong>yourdomain.com.key&lt;/strong> files, change the directory to Deploy/config/nginx in Harbor project.&lt;/p>
&lt;pre tabindex="0">&lt;code> cd Deploy/config/nginx
&lt;/code>&lt;/pre>&lt;p>Create a new directory cert/, if it does not exist. Then copy &lt;strong>yourdomain.com.crt&lt;/strong> and &lt;strong>yourdomain.com.key&lt;/strong> to cert/, e.g. :&lt;/p>
&lt;pre tabindex="0">&lt;code> cp yourdomain.com.crt cert/
cp yourdomain.com.key cert/
&lt;/code>&lt;/pre>&lt;p>Rename the existing configuration file of Nginx:&lt;/p>
&lt;pre tabindex="0">&lt;code> mv nginx.conf nginx.conf.bak
&lt;/code>&lt;/pre>&lt;p>Copy the template &lt;strong>nginx.https.conf&lt;/strong> as the new configuration file:&lt;/p>
&lt;pre tabindex="0">&lt;code> cp nginx.https.conf nginx.conf
&lt;/code>&lt;/pre>&lt;p>Edit the file nginx.conf and replace two occurrences of &lt;strong>harbordomain.com&lt;/strong> to your own host name, such as reg.yourdomain.com . If you use a customized port rather than the default port 443, replace the port &amp;quot;443&amp;quot; in the line &amp;quot;rewrite ^/(.*) https://$server_name:443/$1 permanent;&amp;quot; as well. Please refer to the &lt;a href="https://github.com/vmware/harbor/blob/master/docs/installation_guide.md">installation guide&lt;/a> for other required steps of port customization.&lt;/p>
&lt;pre tabindex="0">&lt;code> server {
listen 443 ssl;
server_name harbordomain.com;
...
server {
listen 80;
server_name harbordomain.com;
rewrite ^/(.*) https://$server_name:443/$1 permanent;
&lt;/code>&lt;/pre>&lt;p>Then look for the SSL section to make sure the files of your certificates match the names in the config file. Do not change the path of the files.&lt;/p>
&lt;pre tabindex="0">&lt;code> ...
# SSL
ssl_certificate /etc/nginx/cert/yourdomain.com.crt;
ssl_certificate_key /etc/nginx/cert/yourdomain.com.key;
&lt;/code>&lt;/pre>&lt;p>Save your changes in nginx.conf.&lt;/p>
&lt;p>##Installation of Harbor
Next, edit the file Deploy/harbor.cfg , update the hostname and the protocol:&lt;/p>
&lt;pre tabindex="0">&lt;code> #set hostname
hostname = reg.yourdomain.com
#set ui_url_protocol
ui_url_protocol = https
&lt;/code>&lt;/pre>&lt;p>Generate configuration files for Harbor:&lt;/p>
&lt;pre tabindex="0">&lt;code>./prepare
&lt;/code>&lt;/pre>&lt;p>If Harbor is already running, stop and remove the existing instance. Your image data remain in the file system&lt;/p>
&lt;pre tabindex="0">&lt;code> docker-compose stop
docker-compose rm
&lt;/code>&lt;/pre>&lt;p>Finally, restart Harbor:&lt;/p>
&lt;pre tabindex="0">&lt;code> docker-compose up -d
&lt;/code>&lt;/pre>&lt;p>After setting up HTTPS for Harbor, you can verify it by the following steps:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Open a browser and enter the address: &lt;a href="https://reg.yourdomain.com">https://reg.yourdomain.com&lt;/a> . It should display the user interface of Harbor.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>On a machine with Docker daemon, make sure the option &amp;quot;-insecure-registry&amp;quot; does not present, and you must copy ca.crt generated in the above step to &lt;strong>/etc/docker/certs.d/yourdomain.com&lt;/strong>(or your registry host IP), if the directory does not exist, create it.
If you mapped nginx port 443 to another port, then you should instead create the directory /etc/docker/certs.d/yourdomain.com:port(or your registry host IP:port). Then run any docker command to verify the setup, e.g.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code> docker login reg.yourdomain.com
&lt;/code>&lt;/pre>&lt;p>If you've mapped nginx 443 port to another, you need to add the port to login, like below:&lt;/p>
&lt;pre tabindex="0">&lt;code> docker login reg.yourdomain.com:port
&lt;/code>&lt;/pre>&lt;p>##Troubleshooting&lt;/p>
&lt;ol>
&lt;li>
&lt;p>You may get an intermediate certificate from a certificate issuer. In this case, you should merge the intermediate certificate with your own certificate to create a certificate bundle. You can achieve this by the below command:&lt;/p>
&lt;pre tabindex="0">&lt;code>cat intermediate-certificate.pem &amp;gt;&amp;gt; yourdomain.com.crt
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>On some systems where docker daemon runs, you may need to trust the certificate at OS level.
On Ubuntu, this can be done by below commands:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">cp youdomain.com.crt /usr/local/share/ca-certificates/reg.yourdomain.com.crt
update-ca-certificates
&lt;/code>&lt;/pre>&lt;/div>&lt;p>On Red Hat (CentOS etc), the commands are:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">cp yourdomain.com.crt /etc/pki/ca-trust/source/anchors/reg.yourdomain.com.crt
update-ca-trust
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol></description></item><item><title>Docs: farbic-搭建高并发交易网络</title><link>https://xiaoping378.github.io/docs/5-blockchain/farbic-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/farbic-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA/</guid><description>
&lt;p>针对每秒数千笔交易的场景，默认的CCVC（并发控制版本检查）会导致交易失败率的上升，其实不需要对基础网络本身做特殊设置，从合约代码入手可以解决，参考官方例子&lt;a href="https://github.com/hyperledger/fabric-samples">farbic-samples&lt;/a>.&lt;/p>
&lt;h3 id="下载项目">下载项目&lt;/h3>
&lt;p>基于目前最新的v1.0.3版本来说&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/hyperledger/fabric-samples.git
&lt;span style="color:#a2f">cd&lt;/span> fabric-samples/first-network
&lt;/code>&lt;/pre>&lt;/div>&lt;p>未完...&lt;/p></description></item><item><title>Docs: Openldap之拨云见日</title><link>https://xiaoping378.github.io/docs/3-devops/openldap%E4%B9%8B%E6%8B%A8%E4%BA%91%E5%8E%BB%E6%97%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/openldap%E4%B9%8B%E6%8B%A8%E4%BA%91%E5%8E%BB%E6%97%A5/</guid><description>
&lt;p>很早就听说LDAP/AD之流的企业级概念，认为是做统一用户认证的，具体怎么使用对接，一直有点儿糊涂，今天决定搞明白这些，并深入实践下openldap。&lt;/p>
&lt;p>未完...TODO&lt;/p></description></item><item><title>Docs: 多负载均衡方案</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-router%E5%92%8Chaproxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-router%E5%92%8Chaproxy/</guid><description>
&lt;p>haproxy在openshift里默认有两种用处，一个种负责master的高可用，一种是负责外部对内服务的访问（ingress controller）&lt;/p>
&lt;p>平台部署情况：&lt;/p>
&lt;ul>
&lt;li>3台master，etcd&lt;/li>
&lt;li>1台node&lt;/li>
&lt;li>1台lb（haproxy）&lt;/li>
&lt;/ul>
&lt;h2 id="haproxy负载均衡master的高可用">haproxy负载均衡master的高可用&lt;/h2>
&lt;p>lb负责master间的负载均衡，其实负载没那么大，更多得是用来避免单点故障&lt;/p>
&lt;h3 id="debug介绍">Debug介绍&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>默认安装haproxy1.5.18版本，开启debug方法&lt;/p>
&lt;pre tabindex="0">&lt;code># 默认systemd对haproxy做了封装，会以-Ds后台形式启动，debug信息是看不到的
systemctl stop harproxy
# vi /etc/haproxy/haproxy.cfg
log 127.0.0.1 local3 debug
# 手动启动haproxy
haproxy -f /etc/haproxy/haproxy.cfg -p /run/haproxy.pid -d
&lt;/code>&lt;/pre>&lt;p>不知道是不是哪里还需要设置，打印出来的日志，信息并不是不太多&lt;/p>
&lt;p>另外浏览&lt;code>https://lbIP:9000&lt;/code>, 可以看到统计信息&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="配置介绍">配置介绍&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>使用&lt;a href="https://github.com/xiaoping378/openshift-deploy">openshift-ansible&lt;/a>部署后，harpxy的配置如下&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@node4 ~]# cat /etc/haproxy/haproxy.cfg
# Global settings
#---------------------------------------------------------------------
global
chroot /var/lib/haproxy
pidfile /var/run/haproxy.pid
maxconn 20000
user haproxy
group haproxy
daemon
log /dev/log local0 info #定义debug级别
# turn on stats unix socket
stats socket /var/lib/haproxy/stats
#---------------------------------------------------------------------
# common defaults that all the 'listen' and 'backend' sections will
# use if not designated in their block
#---------------------------------------------------------------------
defaults #默认配置，后面同KEY的设置会覆盖此处
mode http #工作在七层代理，客户端请求在转发至后端服务器之前将会被深度分板，所有不与RFC格式兼容的请求都会被拒绝，一些七层的过滤处理手段，可以使用。
log global #默认启用gloabl的日志设置
option httplog #默认日志类别为http日志格式
option dontlognull #不记录健康检查日志信息（端口扫描，空信息）
# option http-server-close
option forwardfor except 127.0.0.0/8 #如果上游服务器上的应用程序想记录客户端的真实IP地址，haproxy会把客户端的IP信息发送给上游服务器，在HTTP请求中添加”X-Forwarded-For”字段,但当是haproxy自身的健康检测机制去访问上游服务器时是不应该把这样的访问日志记录到日志中的，所以用except来排除127.0.0.0，即haproxy自身
option redispatch #代理的服务器挂掉后，强制定向到其他健康的服务器，避免cookie信息过时，仍可正常访问
retries 3 #3次连接失败就认为后端服务器不可用
timeout http-request 10s #默认客户端发送http请求的超时时间， 防DDOS攻击手段
timeout queue 1m #当后台服务器maxconn满了后，haproxy会把client发送来的请求放进一个队列中，一旦事件超过timeout queue，还没被处理，haproxy会自动返回503错误。
timeout connect 10s #haproxy与后端服务器连接超时时间，如果在同一个局域网可设置较小的时间
timeout client 300s #默认客户端与haproxy连接后，数据传输完毕，不再有数据传输，即非活动连接的超时时间
timeout server 300s #定义haproxy与后台服务器非活动连接的超时时间
timeout http-keep-alive 10s #默认新的http请求建立连接的超时时间，时间较短时可以尽快释放出资源，节约资源。和http-request配合使用
timeout check 10s #健康检测的时间的最大超时时间
maxconn 20000 #最大连接数
listen stats :9000
mode http
stats enable
stats uri /
frontend atomic-openshift-api
bind *:8443
default_backend atomic-openshift-api
mode tcp #在此模式下，客户端和服务器端之前将建立一个全双工的连接，不会对七层（http）报文做任何检查
option tcplog
backend atomic-openshift-api
balance source #是基于请求源IP的算法，此算法对请求的源IP时行hash运算，然后将结果除以后端服务器的权重总和，来判断转发至哪台后端服务器，这种方法可保证同一客户端IP的请求始终转发到固定定的后端服务器。
mode tcp
server master0 192.168.56.100:8443 check
server master1 192.168.56.101:8443 check
server master2 192.168.56.102:8443 check
&lt;/code>&lt;/pre>&lt;p>&lt;a href="http://cbonte.github.io/haproxy-dconv/1.5/configuration.html">官方文档&lt;/a>介绍的非常详细，感兴趣的可以继续深入研究&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="router负责外部对内服务的访问">Router负责外部对内服务的访问&lt;/h2>
&lt;h3 id="部署一个router并实现高可用">部署一个Router并实现高可用&lt;/h3>
&lt;p>router是由harpoxy来承担的， 可以理解成kubernetes里的ingress controller部分，默认跑在容器里。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使能 default项目下router，可以访问hostnetwork&lt;/p>
&lt;pre>&lt;code>oc adm policy add-scc-to-user hostnetwork system:serviceaccount:default:router
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>使能其可以查看 label&lt;/p>
&lt;pre>&lt;code>oc adm policy add-cluster-role-to-user \
cluster-reader \
system:serviceaccount:default:router
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>部署1个router， 选择具有标签&lt;code>router=true&lt;/code>的节点&lt;/p>
&lt;pre>&lt;code># 对节点设置标签
oc label 192.168.56.110 router=true
# 部署并指定serviceaccount
oc adm router router --replicas=1 --selector='router=true' --service-account=router
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>设置router自身的高可用，参考&lt;a href="https://docs.openshift.org/latest/admin_guide/high_availability.html#admin-guide-high-availability">这里&lt;/a>&lt;/p>
&lt;p>默认使用keepalived实现多个router的高可用，访问router变成访问VIP地址，keepalived再根据权重和健康监测，利用VRRP通告外界后台到底那个router在服务。&lt;/p>
&lt;pre>&lt;code># 添加另一个node作为冗余
oc label no 192.168.56.111 router=true
oc scale dc router --replicas=2
#绑定serviceaccount特权，因为keepalived要操作iptables
oc adm policy add-scc-to-user privileged system:serviceaccount:default:ipfailover
#创建keepalived并指定VIP
oc adm ipfailover ha-router \
--replicas=2 --watch-port=80 \
--selector=&amp;quot;router=true&amp;quot; \
--virtual-ips=&amp;quot;192.168.56.170&amp;quot; \
--iptables-chain=&amp;quot;INPUT&amp;quot; \
--service-account=ipfailover --create
&lt;/code>&lt;/pre>
&lt;p>这样，刚才创建的router就自高可用了，通过&lt;code>192.168.56.170&lt;/code>来访问，有一点值得注意，&lt;/p>
&lt;ul>
&lt;li>按照现在的例子，如果以后还有router做高可用的话，要加上&lt;code>--vrrp-id-offset=1&lt;/code>，保证一个vip用一个独有的vrrp-id。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="router分片">Router分片&lt;/h3>
&lt;p>路由分片的概念，就是集群内有多个router，通过label来负责不同的routes。&lt;/p>
&lt;p>这样可以实现一个project独享一个router，或者某几个route独享一个router，再或者大型集群，更多样化的需求，用这个router sharding的概念也可以满足。&lt;/p>
&lt;p>我现在还没有具体的场景，先不实践，后续有机会会跟进更新下。&lt;/p></description></item><item><title>Docs: fabric-示例集群化操作</title><link>https://xiaoping378.github.io/docs/5-blockchain/frabic-%E7%A4%BA%E4%BE%8B%E9%9B%86%E7%BE%A4%E5%8C%96%E6%93%8D%E4%BD%9C/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/frabic-%E7%A4%BA%E4%BE%8B%E9%9B%86%E7%BE%A4%E5%8C%96%E6%93%8D%E4%BD%9C/</guid><description>
&lt;p>fabric给出的cc样例都是跑在docker-compose上，这里介绍利用已有的docker-compose.yaml如何集群化运行。&lt;/p>
&lt;h3 id="准备样例cc">准备样例CC&lt;/h3>
&lt;p>以官方&lt;code>fabric-samples&lt;/code>项目里的balance-transfer为例，准备拆分运行在4个虚机里。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/hyperledger/fabric-samples.git
&lt;span style="color:#a2f">cd&lt;/span> fabric-samples/balance-transfer
&lt;/code>&lt;/pre>&lt;/div>&lt;p>本CC的示例，主要由3个部分组成:&lt;/p>
&lt;ul>
&lt;li>2 CAs&lt;/li>
&lt;li>1 SOLO orderer&lt;/li>
&lt;li>4 peers (2 peers per Org)&lt;/li>
&lt;/ul>
&lt;p>其中&lt;code>artifacts&lt;/code>目录里放置了：&lt;/p>
&lt;ul>
&lt;li>由 &lt;strong>cryptogen&lt;/strong> 工具生成的证书信息，后面运行时需要挂载到各自的peer节点里&lt;/li>
&lt;li>由 &lt;strong>configtxgen&lt;/strong> 工具生成的初始块 &lt;code>genesis.block&lt;/code> 和 channel配置信息&lt;code>mychannell.tx&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="准备集群">准备集群&lt;/h3>
&lt;p>根据上面的情况，下面准备四个虚机来集群化操作, 虚机规划信息如下：&lt;/p>
&lt;ul>
&lt;li>air13, 192.168.10.78, 运行ca1，ca2, 这是我的本机&lt;/li>
&lt;li>node0, 192.168.10.110, 运行orderer&lt;/li>
&lt;li>node1, 192.168.10.114, 运行org1的peer0、peer1&lt;/li>
&lt;li>node2, 192.168.10.115, 运行org2的peer0、peer1&lt;/li>
&lt;/ul>
&lt;p>每个虚机都预先安装docker和docker-compose&lt;/p>
&lt;p>修改&lt;code>artifacts/docker-compose.yaml&lt;/code>文件，在每个service下添加如下信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#008000;font-weight:bold">extra_hosts&lt;/span>:&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#b44">&amp;#34;ca.org1.example.com:192.168.10.78&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#b44">&amp;#34;ca.org2.example.com:192.168.10.78&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#b44">&amp;#34;orderer.example.com:192.168.10.110&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#b44">&amp;#34;peer0.org1.example.com:192.168.10.114&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#b44">&amp;#34;peer1.org1.example.com:192.168.10.114&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#b44">&amp;#34;peer0.org2.example.com:192.168.10.115&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;span style="color:#bbb"> &lt;/span>- &lt;span style="color:#b44">&amp;#34;peer1.org2.example.com:192.168.10.115&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此举的作用是在每个容器的&lt;code>/etc/hosts&lt;/code>文件里，添加上面的映射，最终docker-compose.yaml文件放置&lt;a href="https://gist.github.com/xiaoping378/8ba8e796552e27277073e56cfd7b281a">gist&lt;/a>上了.&lt;/p>
&lt;p>最后一步，因为此CC样例运行时，需要挂载本地目录里一些提前生成好的证书，我们还需要把这么需要挂载的东西，同步到每个虚机里，如下操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">rsync -az balance-transfer root@192.168.10.110:~/
rsync -az balance-transfer root@192.168.10.114:~/
rsync -az balance-transfer root@192.168.10.115:~/
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="集群化运行">集群化运行&lt;/h3>
&lt;p>ssh进入虚机，按照规划启动各自的服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 进入air13虚机&lt;/span>
&lt;span style="color:#a2f">cd&lt;/span> balance-transfer/artifacts/
docker-compose up --no-deps ca.org1.example.com ca.org2.example.com
&lt;span style="color:#080;font-style:italic"># ssh进入node0虚机&lt;/span>
&lt;span style="color:#a2f">cd&lt;/span> balance-transfer/artifacts/
docker-compose up --no-deps orderer.example.com
&lt;span style="color:#080;font-style:italic"># ssh进入node1虚机&lt;/span>
&lt;span style="color:#a2f">cd&lt;/span> balance-transfer/artifacts/
docker-compose up --no-deps peer0.org1.example.com peer1.org1.example.com
&lt;span style="color:#080;font-style:italic"># ssh进入node2虚机&lt;/span>
&lt;span style="color:#a2f">cd&lt;/span> balance-transfer/artifacts/
docker-compose up --no-deps peer0.org2.example.com peer1.org2.example.com
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上fabric的区块链网络已经集群化运行了&lt;/p>
&lt;h3 id="运行app并测试cc">运行APP并测试CC&lt;/h3>
&lt;p>在虚机air13上运行我们的前端APP，并测试在网络集群化后的的CC，&lt;/p>
&lt;p>此外由于此APP样例的特殊性，还需要修改其他的地方&lt;/p>
&lt;ul>
&lt;li>config.json文件里的orderer地址改为&lt;code>&amp;quot;grpcs://192.168.10.110:7050&amp;quot;&lt;/code>&lt;/li>
&lt;li>app/network-config.json里指定地址的地方需要改成&lt;a href="https://gist.github.com/xiaoping378/a599e3bb3080135b2548c1242ca8cc80">这样&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>进入balance-transfer目录，如下执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ npm isntall
$ &lt;span style="color:#b8860b">PORT&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#666">4000&lt;/span> node app
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样前端APP就运行起来了，接下来利用测试脚本&lt;code>testAPIs.sh&lt;/code>测试下我们的CC,运行前，还需要修改下脚本里的peer地址，修改后的文件在&lt;a href="https://gist.github.com/xiaoping378/dbfd8801b7b125b0d7add7fce7d4e854">这里&lt;/a>&lt;/p>
&lt;p>运行脚本：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">./testAPIs.sh
POST request Enroll on Org1 ...
&lt;span style="color:#666">{&lt;/span>&lt;span style="color:#b44">&amp;#34;success&amp;#34;&lt;/span>:true,&lt;span style="color:#b44">&amp;#34;secret&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;DbzvtdmATgve&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;message&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;Jim2 enrolled Successfully&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;token&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MDE4NzQ5MjUsInVzZXJuYW1lIjoiSmltMiIsIm9yZ05hbWUiOiJvcmcxIiwiaWF0IjoxNTAxODM4OTI1fQ.LUmfEstviquaD5k5oBMd9KUFaKF1s6ZMY8iO67dKiH0&amp;#34;&lt;/span>&lt;span style="color:#666">}&lt;/span>
。
。
。
GET query Installed chaincodes
&lt;span style="color:#666">[&lt;/span>&lt;span style="color:#b44">&amp;#34;name: mycc, version: v0, path: github.com/example_cc&amp;#34;&lt;/span>&lt;span style="color:#666">]&lt;/span>
GET query Instantiated chaincodes
&lt;span style="color:#666">[&lt;/span>&lt;span style="color:#b44">&amp;#34;name: mycc, version: v0, path: github.com/example_cc&amp;#34;&lt;/span>&lt;span style="color:#666">]&lt;/span>
GET query Channels
&lt;span style="color:#666">{&lt;/span>&lt;span style="color:#b44">&amp;#34;channels&amp;#34;&lt;/span>:&lt;span style="color:#666">[{&lt;/span>&lt;span style="color:#b44">&amp;#34;channel_id&amp;#34;&lt;/span>:&lt;span style="color:#b44">&amp;#34;mychannel&amp;#34;&lt;/span>&lt;span style="color:#666">}]}&lt;/span>
Total execution &lt;span style="color:#a2f">time&lt;/span> : &lt;span style="color:#666">13&lt;/span> secs ...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>本样例修改后的完整地址在&lt;a href="https://github.com/xiaoping378/fabric-samples">这里&lt;/a>&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>目前集群化后网络里的peers ledger和orderer的数据还是存储在容器里，是否要考虑挂载出来，不然容器挂了再启动后，数据是否会乱了，后续研究下。&lt;/p>
&lt;p>后续还会继续搞下CA，MSP和动态添加节点以及合约迭代升级等问题。&lt;/p></description></item><item><title>Docs: Casbin的权限管理解读</title><link>https://xiaoping378.github.io/docs/3-devops/casbin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/casbin/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>项目一般都要包含权限管理功能，或集成IAM，或自身实现。本文介绍一个强大、高效的开源访问控制框架--Casbin。&lt;/p>
&lt;/div>
&lt;h2 id="基本介绍">基本介绍&lt;/h2>
&lt;p>Casbin的由来，是出自开源作者&lt;code>罗杨&lt;/code>的一篇论文&lt;a href="https://arxiv.org/abs/1903.09756">《PML：一种基于Interpreter的Web服务访问控制策略语言》&lt;/a>，该论文的主要摘要如下：&lt;/p>
&lt;blockquote>
&lt;p>为了保护云资源的安全,防止数据泄露和非授权访问,必须对云平台的资源访问实施访问控制.然而,目前主流云平台通常采用自己的安全策略语言和访问控制机制,从而造成两个问题:&lt;/p>
&lt;ul>
&lt;li>（1）云用户若要使用多个云平台,则需要学习不同的策略语言,分别编写安全策略;&lt;/li>
&lt;li>（2）云服务提供商需要自行设计符合自己平台的安全策略语言及访问控制机制,开发成本较高.&lt;/li>
&lt;/ul>
&lt;p>对此,提出一种基于元模型的访问控制策略描述语言PML及其实施机制PML-EM. PML支持表达BLP、RBAC、ABAC等访问控制模型.
PML-EM实现了3个性质:&lt;/p>
&lt;ul>
&lt;li>策略语言无关性&lt;/li>
&lt;li>访问控制模型无关性&lt;/li>
&lt;li>程序设计语言无关性&lt;/li>
&lt;/ul>
&lt;p>从而降低了用户编写策略的成本与云服务提供商开发访问控制机制的成本. 在OpenStack云平台上实现了PML-EM机制.实验结果表明,PML策略支持从其他策略进行自动转换,
在表达云中多租户场景时具有优势.性能方面,与OpenStack原有策略相比,PML策略的评估开销为4.8%.PML-EM机制的侵入性较小,与云平台原有代码相比增加约0.42%.&lt;/p>
&lt;/blockquote>
&lt;p>目前Casbin的权限策略管理支持主流的&lt;strong>ACL、RBAC、ABAC&lt;/strong>、RESTful等模型，实现的编程语言主要有Go、java、Nodejs、PHP、Python、.Net、C++、Rust等。目前Go和Java的实现最为全面。&lt;/p>
&lt;p>先介绍下主流的访问控制模型：&lt;/p>
&lt;ul>
&lt;li>&lt;em>ACL（access control list）&lt;/em>：是一种与访问对象关联的权限列表，在基础设施领域应用非常广泛：
&lt;ul>
&lt;li>文件系统：用户（组）对文件或进程等的访问权限控制&lt;/li>
&lt;li>网络：常见的有防火墙（安全组、路由器、交换机）内的对目的IP和端口的规则控制&lt;/li>
&lt;li>SQL：库、表的权限管理&lt;/li>
&lt;li>&lt;a href="../openldap%E4%B9%8B%E6%8B%A8%E4%BA%91%E5%8E%BB%E6%97%A5">LDAP&lt;/a>：层级结构的实体权限管理：网络域权限管理...&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;em>RBAC（role-based access control）&lt;/em>：基于角色的权限控制，围绕角色和权限定义的策略中立的访问控制机制，和组ACL等价，具体表现为在用户和权限之间加了一层角色，先建立具有某种权限的角色，然后用角色和用户绑定，目前多用于业务系统内的权限管理，还支持支持角色权限继承。&lt;/li>
&lt;li>&lt;em>ABAC（Attribute-based access control）&lt;/em>：基于属性的权限控制，属性可以是用户侧（所属组织、访问IP、访问时间）或资源侧（帖子的评论开关、留言再编辑）的，因为用户或资源的属性是动态的，不像前面两个(需要预先定义好策略，略显死板,,,）被称为是“下一代”的权限模型。&lt;/li>
&lt;li>&lt;em>Restful&lt;/em>：一种Web API规范，常用GET, POST等动作来实现与后台交互。&lt;/li>
&lt;/ul>
&lt;p>和Casbin结合，使用的基本示意图如下：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/images/Casbin-%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio.png" alt="">&lt;/p>
&lt;ul>
&lt;li>1-2为管理人员下发权限策略&lt;/li>
&lt;li>3-6为用户日常操作资源的简易流程，实际应用场景一般如下：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code class="language-plantuml" data-lang="plantuml">@startuml
!theme aws-orange
用户 -&amp;gt; 认证中心: 登录操作
认证中心 -&amp;gt; 缓存: 存放(key=token+ip,value=token)token
用户 &amp;lt;- 认证中心 : 认证成功返回token
用户 -&amp;gt; 认证中心: 下次访问头部携带token认证
认证中心 &amp;lt;- 缓存: key=token+ip获取token
Casbin &amp;lt;- 认证中心: 存在且校验成功,则进入授权校验
Casbin -&amp;gt; 其他服务: 权限合规，则跳转到用户请求的其他服务
其他服务 -&amp;gt; 用户: 信息
@enduml
&lt;/code>&lt;/pre>&lt;h2 id="抽象模型">抽象模型&lt;/h2>
&lt;p>正如上面提到的，要支持这么多的权限模型，，所以Casbin基于开头提到的PML（PERM modeling language）引入一种抽象的元模型控制，其中&lt;strong>PERM&lt;/strong>是指的&lt;strong>Policy, Effect, Request, Matchers&lt;/strong>，具体工作流如下：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/images/Casbin-2022-01-26-23-21-26.png" alt="">&lt;/p>
&lt;p>这里的&lt;code>PERM&lt;/code>是Casbin在启动时要加载的抽象校验模型，可以理解成一种权限校验模板。 简单说个场景串下这里的概念：&lt;/p>
&lt;ul>
&lt;li>管理员分配给用户权限&lt;strong>Policy&lt;/strong>，可以得到&lt;code>谁能操作什么资源&lt;/code>的信息&lt;/li>
&lt;li>用户发起请求&lt;strong>Request&lt;/strong>，可以得到&lt;code>谁要操作什么资源&lt;/code>的信息&lt;/li>
&lt;li>Casbin拿到Request和Policy做匹配&lt;strong>Matcher&lt;/strong>，也支持自定义函数匹配。&lt;/li>
&lt;li>根据匹配结果&lt;strong>Effect&lt;/strong>来决定是否允许用户的操作&lt;/li>
&lt;/ul>
&lt;p>实际场景中，用户可能被分配了多个权限（角色），那具体权限校验如下：
&lt;img src="https://xiaoping378.github.io/images/Casbin-2022-01-26-23-47-48.png" alt="">&lt;/p>
&lt;p>既然是一种语言，就是有语法的，&lt;a href="https://casbin.org/docs/zh-CN/syntax-for-models">PERM语法&lt;/a>至少要有四部分：&lt;code>[request_definition], [policy_definition], [policy_effect], [matchers]&lt;/code>。
具体就不展开介绍了，可自行官网祥读，effect部分具备SQL背景可能好理些,,,理解不了也没关系，目前就内置了5种：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Effect&lt;/th>
&lt;th>含义&lt;/th>
&lt;th>样例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>some(where (p.eft == allow))&lt;/td>
&lt;td>allow-override&lt;/td>
&lt;td>&lt;a href="https://casbin.org/docs/zh-CN/supported-models#examples">ACL, RBAC, etc.&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>!some(where (p.eft == deny))&lt;/td>
&lt;td>deny-override&lt;/td>
&lt;td>&lt;a href="https://casbin.org/docs/zh-CN/supported-models#examples">Deny-override&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>some(where (p.eft == allow)) &amp;amp;&amp;amp; !some(where (p.eft == deny))&lt;/td>
&lt;td>allow-and-deny&lt;/td>
&lt;td>&lt;a href="https://casbin.org/docs/zh-CN/supported-models#examples">Allow-and-deny&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>priority(p.eft) || deny&lt;/td>
&lt;td>priority&lt;/td>
&lt;td>&lt;a href="https://casbin.org/docs/zh-CN/supported-models#examples">Priority&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>subjectPriority(p.eft)&lt;/td>
&lt;td>priority base on role&lt;/td>
&lt;td>&lt;a href="https://casbin.org/docs/zh-CN/supported-models#examples">Subject-Priority&lt;/a>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>奉劝各位看官，既然是语法，就不要纠结里面的命名和写法，较真...人家就是这么定义的，知道能都有哪些写法就可以了...，实际使用中往往改动Macter的部分概率大些。&lt;/p>
&lt;/blockquote>
&lt;h2 id="按场景举例">按场景举例&lt;/h2>
&lt;h3 id="acl模型">ACL模型&lt;/h3>
&lt;p>先定义Casbin要加载的PERM Model，我使用在线编辑器定义一个&lt;a href="https://casbin.org/casbin-editor/#6TQQJ8EQF">ACL典型模型&lt;/a>:&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/images/Casbin-2022-01-27-09-48-25.png" alt="">&lt;/p>
&lt;p>解读如下：&lt;/p>
&lt;ul>
&lt;li>左上侧为Casbin启动时要加载的标准ACL Model配置，不需要改动&lt;/li>
&lt;li>右上侧为Policy部分，属于管理员要分配权限时要改动的部分：示例中定义了5条规则，小王和小李对自己的Home目录可以读写，而小李额外可以读取小王的Home目录&lt;/li>
&lt;li>左下角Request表明用户的请求，一般是从用户实际发起的请求中获取信息，组合好格式后，用API发起校验，示例中小李发起读和写小王的操作&lt;/li>
&lt;li>右下角为权限校验结果：示例中小李的写操作被拒绝了&lt;/li>
&lt;/ul>
&lt;h3 id="rbac模型">RBAC模型&lt;/h3>
&lt;p>下图模式的在线&lt;a href="https://casbin.org/casbin-editor/#F8A6D8YHE">编辑地址&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/images/Casbin-2022-01-27-16-31-44.png" alt="">&lt;/p>
&lt;p>Macters里的&lt;code>g(r.sub, p.sub, r.dom)&lt;/code> 将检查用户 r.sub 在域内 r.dom 是否具有角色 p.sub ，这是该匹配器的工作方式。&lt;/p>
&lt;h3 id="abac模型">ABAC模型&lt;/h3>
&lt;p>上图中RBAC中的Matcher如下修改，及实现了ABAC的模型校验。表明用户必须是要访问资源的&lt;code>Owner&lt;/code>才可以操作符合角色权限内的资源。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-Conf" data-lang="Conf">m = r.obj.Owner == r.sub &amp;amp;&amp;amp; (g(r.sub, p.sub, r.dom) &amp;amp;&amp;amp; r.dom == p.dom &amp;amp;&amp;amp; r.obj == p.obj &amp;amp;&amp;amp; r.act == p.act)
&lt;/code>&lt;/pre>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Casbin提供了非常灵活的权限校验模型，还提供了丰富的API，方便更便捷的实现业务场景功能, 后面会针对具体的项目开展更贴地气的解读。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://casbin.org/docs/zh-CN/tutorials">https://casbin.org/docs/zh-CN/tutorials&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=3ntkskjrcwow8&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: 镜像管理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</guid><description>
&lt;p>刚接触docker时，第一个接触到的应该就是镜像了，docker之所以如此火热，个人认为一大部分原因就是这个镜像的提出，极大的促进了DevOps推广和软件复用的能力。&lt;/p>
&lt;p>而openshift对镜像的管理非常强大，直到写这篇blog，我才真正意识到这点，甚至犹豫是不是要放到开发实战篇后再来写&lt;code>镜像管理&lt;/code>。&lt;/p>
&lt;p>简要说下openshift里使用镜像的情况：&lt;/p>
&lt;ul>
&lt;li>首先openshift可以利用任何实现了&lt;code>Docker registry API&lt;/code>的镜像仓，比如，Vmware的Harbor项目，Docker hub以及集成镜像仓（ integrated registry）&lt;/li>
&lt;li>集成镜像仓，openshift内部的，可以动态生成，自动让用户编译的镜像有地方存， 其次它还负责通知openshift镜像的变动，然后openshift会根据策略去决定编译其他依赖镜像还是部署应用&lt;/li>
&lt;li>第三方镜像， 可通过命令&lt;code>oc import-image &amp;lt;stream&amp;gt;&lt;/code>来实时获取镜像tag信息并转换成镜像流，继而触发后续的编译或者部署。&lt;/li>
&lt;li>当然&lt;code>oc new-app&lt;/code>也支持直接从第三方镜像仓或者本地镜像里启动一个应用&lt;/li>
&lt;/ul>
&lt;p>文末有安装集成镜像仓的说明，先介绍image Streams 和 istag的概念和应用场景。&lt;/p>
&lt;h2 id="镜像管理">镜像管理&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>openshift基于docker的image概念又延伸出了Image Streams和Image Stream Tags概念&lt;/p>
&lt;p>默认openshift项目下会有一些镜像流，是供自带模板里用的，所以想加速部署模板的话，可以在改这里，通过istag指向本地镜像仓。&lt;/p>
&lt;pre tabindex="0">&lt;code>oc get is -n openshift
oc get istag -n openshift
&lt;/code>&lt;/pre>&lt;p>image，通俗讲就是对应用运行依赖（库，配置，运行环境）的一个打包。&lt;code>docker pull push&lt;/code>， 就是操作的镜像。
为什么openshift还要抽象出is和istag呢，主要是为了打通集成编译和部署环节（bc和dc），原生API就支持了DevOps理念。后面会细讲bc和dc&lt;/p>
&lt;p>is,开发人员可以理解成git的分支，每个分支都会编译很多临时版本出来，这个就是对应到is～=分支和istag～=版本号。
其实is和istag只是记录了一些映射关系，并不会存放实际镜像数据，比如is里记录了build后要output的镜像仓地址和所有tags，而istag里又记录了具体某个tag与image（可能是存于外部镜像仓，也能是某个is）的关系， 利用此实现了bc/dc和镜像的解耦。&lt;/p>
&lt;p>这里通过部署jenkins服务，来初步了解下具体的含义,&lt;/p>
&lt;ul>
&lt;li>创建ci项目&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>oc new-project ci
# 先拉取必要镜像
docker pull openshift/jenkins-1-centos7
#通过模板部署，下面一条命令就可以创建一个临时的jenkins服务的
#oc new-app jenkins-ephemeral
#跑之前我们先来注意几点
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>更改默认的is&lt;/li>
&lt;/ul>
&lt;p>先来查看默认的is&lt;/p>
&lt;pre tabindex="0">&lt;code>oc get template jenkins-ephemeral -n openshift -o json
...
&amp;quot;triggers&amp;quot;: [
{
&amp;quot;imageChangeParams&amp;quot;: {
&amp;quot;automatic&amp;quot;: true,
&amp;quot;containerNames&amp;quot;: [
&amp;quot;jenkins&amp;quot;
],
&amp;quot;from&amp;quot;: {
&amp;quot;kind&amp;quot;: &amp;quot;ImageStreamTag&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;${JENKINS_IMAGE_STREAM_TAG}&amp;quot;,
&amp;quot;namespace&amp;quot;: &amp;quot;${NAMESPACE}&amp;quot;
},
&amp;quot;lastTriggeredImage&amp;quot;: &amp;quot;&amp;quot;
},
&amp;quot;type&amp;quot;: &amp;quot;ImageChange&amp;quot;
},
{
&amp;quot;type&amp;quot;: &amp;quot;ConfigChange&amp;quot;
}
]
...
{
&amp;quot;name&amp;quot;: &amp;quot;NAMESPACE&amp;quot;,
&amp;quot;displayName&amp;quot;: &amp;quot;Jenkins ImageStream Namespace&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;The OpenShift Namespace where the Jenkins ImageStream resides.&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;openshift&amp;quot;
},
{
&amp;quot;name&amp;quot;: &amp;quot;JENKINS_IMAGE_STREAM_TAG&amp;quot;,
&amp;quot;displayName&amp;quot;: &amp;quot;Jenkins ImageStreamTag&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;Name of the ImageStreamTag to be used for the Jenkins image.&amp;quot;,
&amp;quot;value&amp;quot;: &amp;quot;jenkins:latest&amp;quot;
}
...
&lt;/code>&lt;/pre>&lt;p>可以看到默认模板里部署jenkins时，会从openshfit的namespace里拉取jenkins:latest的镜像, 去openshift项目里找找看，确实存在对应的is&lt;/p>
&lt;pre tabindex="0">&lt;code>➜ ~ oc get is -n openshift | grep jenkins
jenkins 170.16.131.234:5000/openshift/jenkins latest,1 2 days ago
➜ ~ oc get istag -n openshift | grep jenkins:latest
jenkins:latest openshift/jenkins-1-centos7@sha256:ab590529e20470e53c1d4b6b970de5d4fd357d864320735a75c1df0e2fffde07 2 days ago sha256:ab590529e20470e53c1d4b6b970de5d4fd357d864320735a75c1df0e2fffde07
&lt;/code>&lt;/pre>&lt;p>上面的命令的输出，有两个点要阐述下，&lt;/p>
&lt;ul>
&lt;li>is里的&lt;code>170.16.131.234:5000/openshift/jenkins&lt;/code>是个可有可无的地址，一般系统会填写集成镜像仓的地址&lt;/li>
&lt;li>而istag里&lt;code>openshift/jenkins-1-centos7@sha256:ab&lt;/code>则是指明了对应tag的镜像来源，&lt;/li>
&lt;/ul>
&lt;p>这样的话，默认执行&lt;code>oc new-app jenkins-ephemeral&lt;/code>的话，会从docker.io那里拉取镜像 openshift/jenkins-1-centos7@sha256:ab590529e20470e53c1d4b6b970de5d4fd357d864320735a75c1df0e2fffde07&lt;/p>
&lt;p>为了加速部署，我们把刚才pull下来的镜像，push到集成镜像仓里&lt;/p>
&lt;pre tabindex="0">&lt;code>#添加用户
#htpasswd /etc/origin/master/htpasswd xxp
docker tag openshift/jenkins-1-centos7 hub2.300.cn/openshift/jenkins
docker login -u developer -p `oc whoami -t` hub2.300.cn
docker push hub2.300.cn/openshift/jenkins
&lt;/code>&lt;/pre>&lt;p>push完后再来看istag的变化，由以前的&lt;code>openshift/jenkins-1-centos&lt;/code>变为了&lt;code>170.16.131.234:5000/openshift/jenkins&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>➜ ~ oc get istag -n openshift | grep jenkins:latest
jenkins:latest 170.16.131.234:5000/openshift/jenkins@sha256:dc0f434a492d11d6ae13711e77f87303a06a8fc0fb3a97ae327a4b88c33435b6 21 hours ago sha256:dc0f434a492d11d6ae13711e77f87303a06a8fc0fb3a97ae327a4b88c33435b6
&lt;/code>&lt;/pre>&lt;p>这里是push到集成镜像仓后，系统会自动更新对应的is和istag， 为了加速部署，更改istag还可以通过import-image从私有镜像仓（harbor）里来完成&lt;/p>
&lt;p>这样再来部署jenkins应用就快速多了&lt;/p>
&lt;p>还有很多更细致的东西，比如如何周期同步第三方镜像仓等等，有需要的查看&lt;a href="https://docs.openshift.org/latest/dev_guide/managing_images.html#creating-an-image-stream-by-manually-pushing-an-image">官文&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="安装独立镜像仓">安装独立镜像仓&lt;/h2>
&lt;p>可以通过openshift-ansible一次性安装OK，这里使用CLI安装，正好可以串一下openshift里的各种概念的使用场景。&lt;/p>
&lt;h3 id="部署">部署&lt;/h3>
&lt;pre tabindex="0">&lt;code>oc project default
oc adm policy add-scc-to-user privileged system:serviceaccount:default:registry
oc label node 192.168.56.102 registry=true
#使用hostPath存储,要在node上放行权限，默认registry用的1001 userID， 不然后续挂载进去的volume，没有写权限
sudo chown 1001:root /home/registry
#注意要指定使用的镜像版本，默认是拉取最新的， 一定要指明``--volume``参数，不然deploy，不会挂载主机目录，官文这里遗漏了。
oc adm registry --images=&amp;quot;openshift/origin-docker-registry:v1.4.1&amp;quot; --selector=&amp;quot;registry=true&amp;quot; --mount-host=&amp;quot;/home/registry&amp;quot; --service-account=registry --volume='/registry'```
中间莫名出现部署``error``的状态，重新部署了下``oc deploy docker-registry --retry``
### 加密镜像仓
- 先拿到serviceIP
```bash
[root@node0 master]# oc get svc docker-registry
NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE
docker-registry 170.16.132.252 &amp;lt;none&amp;gt; 5000/TCP 1h
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>创建自签名证书,如果已经有了，跳过此步&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>oc adm ca create-server-cert \
--signer-cert=/etc/origin/master/ca.crt \
--signer-key=/etc/origin/master/ca.key \
--signer-serial=/etc/origin/master/ca.serial.txt \
--hostnames='hub.example.com,docker-registry.default.svc.cluster.local,170.16.132.252:5000' \
--cert=/etc/secrets/registry.crt \
--key=/etc/secrets/registry.key
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>创建secret， secret是专门来保存敏感信息的，比如密码，sshkey，token信息等等&lt;/p>
&lt;p>更详细的介绍可以查看&lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/secrets.md">这里&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>oc secrets new registry-secret \
/etc/secrets/registry.crt \
/etc/secrets/registry.key
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>绑定secret到serviceaccount&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>oc secrets link registry registry-secret
oc secrets link default registry-secret
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>更新dc，添加volume，把新创建的secret挂进去&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>oc volume dc/docker-registry --add --type=secret \
--name=docker-registry --secret-name=registry-secret -m /etc/secrets
&lt;/code>&lt;/pre>&lt;p>如果想移除的话，如下&lt;/p>
&lt;pre tabindex="0">&lt;code>oc volume dc/docker-registry --remove --name=docker-registry
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>更新环境变量&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>oc set env dc/docker-registry \
REGISTRY_HTTP_TLS_CERTIFICATE=/etc/secrets/registry.crt \
REGISTRY_HTTP_TLS_KEY=/etc/secrets/registry.key
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>更新健康监测 HTTP-&amp;gt;HTTPS&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>oc patch dc/docker-registry -p '{&amp;quot;spec&amp;quot;: {&amp;quot;template&amp;quot;: {&amp;quot;spec&amp;quot;: {&amp;quot;containers&amp;quot;:[{
&amp;quot;name&amp;quot;:&amp;quot;registry&amp;quot;,
&amp;quot;livenessProbe&amp;quot;: {&amp;quot;httpGet&amp;quot;: {&amp;quot;scheme&amp;quot;:&amp;quot;HTTPS&amp;quot;}}
}]}}}}'
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>oc patch dc/docker-registry -p '{&amp;quot;spec&amp;quot;: {&amp;quot;template&amp;quot;: {&amp;quot;spec&amp;quot;: {&amp;quot;containers&amp;quot;:[{
&amp;quot;name&amp;quot;:&amp;quot;registry&amp;quot;,
&amp;quot;readinessProbe&amp;quot;: {&amp;quot;httpGet&amp;quot;: {&amp;quot;scheme&amp;quot;:&amp;quot;HTTPS&amp;quot;}}
}]}}}}'
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>验证是否OK&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>[root@node0 master]# oc logs dc/docker-registry | grep tls
time=&amp;quot;2017-03-02T16:01:41.113619323Z&amp;quot; level=info msg=&amp;quot;listening on :5000, tls&amp;quot; go.version=go1.7.4 instance.id=594aa09b-4540-4e38-a85a-851261cd1254
&lt;/code>&lt;/pre>&lt;h3 id="添加路由">添加路由&lt;/h3>
&lt;pre tabindex="0">&lt;code>oc create route passthrough registry --service=docker-registry --hostname=hub2.300.cn
&lt;/code>&lt;/pre>&lt;h3 id="登录镜像仓">登录镜像仓&lt;/h3>
&lt;pre tabindex="0">&lt;code>oc policy add-role-to-user admin developer -n default
oc login -u developer
docker login -u developer -p `oc whoami -t` hub2.300.cn
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>push镜像&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>docker push hub2.300.cn/default/busybox
&lt;/code>&lt;/pre>&lt;h3 id="安装镜像仓console">安装镜像仓console&lt;/h3>
&lt;ul>
&lt;li>oc利用官方模板安装&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>oc create -n default -f https://raw.githubusercontent.com/openshift/openshift-ansible/master/roles/openshift_hosted_templates/files/v1.4/origin/registry-console.yaml
oc create route passthrough --service registry-console \
--hostname hub3.300.cn \
-n default
oc new-app -n default --template=registry-console \
-p OPENSHIFT_OAUTH_PROVIDER_URL=&amp;quot;https://192.168.31.100:8443&amp;quot; \
-p REGISTRY_HOST=$(oc get route docker-registry -n default --template='{{ .spec.host }}') \
-p COCKPIT_KUBE_URL=$(oc get route registry-console -n default --template='https://{{ .spec.host }}')
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>登录浏览器打开&lt;code>https://hub3.300.cn/registry&lt;/code>,使用已有的账户登录，比如这里是默认的developer和developer。
&lt;img src="https://xiaoping378.github.io/openshift-registry-console.png" alt="界面">&lt;/li>
&lt;/ul></description></item><item><title>Docs: farbic-区块链的生产集群化</title><link>https://xiaoping378.github.io/docs/5-blockchain/farbic%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E9%9B%86%E7%BE%A4%E5%8C%96-kubernetes%E5%AE%9E%E6%88%98/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/farbic%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E9%9B%86%E7%BE%A4%E5%8C%96-kubernetes%E5%AE%9E%E6%88%98/</guid><description>
&lt;p>默认社区的demo是基于docker-compose给出的，达到了“一键部署”的效果，但生产上考虑多节点的情况，还需要费些手脚，这里考虑用kompose结合k8s来做这件事。&lt;/p>
&lt;h3 id="k8s集群-1-7的初始化">k8s集群 1.7的初始化&lt;/h3>
&lt;p>每个节点都要安装docker的步骤，此处略过不表，这里主要介绍利用kubeadm初始化k8s集群，这里不考虑k8s集群本身的高可用，以前有文章专门介绍过。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">apt-get update &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> apt-get install -y apt-transport-https
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat &lt;span style="color:#b44">&amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list
&lt;/span>&lt;span style="color:#b44">deb http://apt.kubernetes.io/ kubernetes-xenial main
&lt;/span>&lt;span style="color:#b44">EOF&lt;/span>
apt-get update
apt-get install -y kubelet kubeadm
&lt;span style="color:#080;font-style:italic"># 默认会自动安装这些包 ebtables kubeadm kubectl kubelet kubernetes-cni socat&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你本机是centos的话，可以用如下命令安装&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">cat &lt;span style="color:#b44">&amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
&lt;/span>&lt;span style="color:#b44">[kubernetes]
&lt;/span>&lt;span style="color:#b44">name=Kubernetes
&lt;/span>&lt;span style="color:#b44">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
&lt;/span>&lt;span style="color:#b44">enabled=1
&lt;/span>&lt;span style="color:#b44">gpgcheck=1
&lt;/span>&lt;span style="color:#b44">repo_gpgcheck=1
&lt;/span>&lt;span style="color:#b44">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
&lt;/span>&lt;span style="color:#b44"> https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
&lt;/span>&lt;span style="color:#b44">EOF&lt;/span>
setenforce &lt;span style="color:#666">0&lt;/span>
yum install -y kubelet kubeadm
systemctl &lt;span style="color:#a2f">enable&lt;/span> kubelet &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> systemctl start kubelet
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的命令，需要翻墙才能跑通，没条件的可以去&lt;a href="https://github.com/kubernetes/release">release项目&lt;/a>自己编译deb包或者rpm包，如下运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/kubernetes/release.git &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a2f">cd&lt;/span> release
&lt;span style="color:#080;font-style:italic"># debian系如下&lt;/span>
docker build --tag&lt;span style="color:#666">=&lt;/span>debian-packager debian
docker run --volume&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#a2f;font-weight:bold">$(&lt;/span>&lt;span style="color:#a2f">pwd&lt;/span>&lt;span style="color:#a2f;font-weight:bold">)&lt;/span>&lt;span style="color:#b44">/debian:/src&amp;#34;&lt;/span> debian-packager
&lt;span style="color:#080;font-style:italic"># docker run -e &amp;#34;HTTPS_PROXY=127.0.0.1:8118&amp;#34; --net=host --volume=&amp;#34;$(pwd)/debian:/src&amp;#34; debian-packager&lt;/span>
&lt;span style="color:#080;font-style:italic"># 默认debs包在目录debian/bin/stable/xenial下&lt;/span>
&lt;span style="color:#080;font-style:italic"># centos系的如下&lt;/span>
&lt;span style="color:#a2f">cd&lt;/span> rpm
./docker-build.sh
&lt;span style="color:#080;font-style:italic">#默认rpm包在目录output/x86_64/下&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>必要依赖搞到手后，就可以简单的利用kubeadm启动集群了
在master节点上如下执行初始化，此过程会启动 etcd，controller-manager，scheduler，api-server组件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubeadm init --kubernetes-version stable-1.7 --pod-network-cidr&lt;span style="color:#666">=&lt;/span>10.244.0.0/16
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在其他节点上执行join操作
现在必须要加上&lt;code>--node-name&lt;/code>参数，不然报错误，这是个&lt;a href="https://github.com/kubernetes/kubeadm/issues/347">bug&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubeadm join --token 4cc663.c4d99a546c9f3974 192.168.10.78:6443 --node-name node-0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认还需要启动pod network，我默认用的flannel。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel-rbac.yml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外默认master节点是不会被调度容器的，如下可放开限制&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl taint nodes --all node-role.kubernetes.io/master-
&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认我们得到如下的集群状态&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ ~ kubectl get no
NAME STATUS AGE VERSION
air13 Ready 2h v1.7.2
node-0 Ready 17m v1.7.2
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="准备fabric的k8ss所需yaml文件">准备fabric的k8ss所需yaml文件&lt;/h3>
&lt;p>这里需要用到下载我改过的kompose工具，默认官方的对hostpath的处理，需要引入PV，PVC，虽然这样无可厚非，但对与现阶段的我增加了不必要的复杂度，就动手加了个&lt;code>--hostpaths&lt;/code>的选项，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># 下载我改过的工具项目-kompose&lt;/span>
git clone https://github.com/xiaoping378/kompose
&lt;span style="color:#a2f">cd&lt;/span> kompose &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> make
&lt;span style="color:#080;font-style:italic"># 如上会编译出kompose来，自己搞到$PATH里&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里以&lt;a href="https://github.com/hyperledger/fabric-samples.git">fabric-samples项目&lt;/a>里的balance-transfer为例，演示一个完整的CC运行在k8s上。&lt;/p>
&lt;p>下载fabric-samles项目，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/hyperledger/fabric-samples.git
&lt;span style="color:#a2f">cd&lt;/span> fabric-samples/balance-transfer
kompose convert -f artifacts/docker-compose.yaml -d --hostpaths
&lt;span style="color:#080;font-style:italic"># 如上会在当前目录出现批量的deployment和service yaml文件，这里需要针对hostpath的volumes稍作修改&lt;/span>
sed -i &lt;span style="color:#b44">&amp;#39;s/.\/channel/\/root\/balance-transfer\/artifacts\/channel/&amp;#39;&lt;/span> *-deployment.yaml
&lt;span style="color:#080;font-style:italic">#如上改成绝对路径，另外还需要保证各节点都要有channel目录&lt;/span>
rsync -avz balance-transfer root@node-0:~/
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为ca, peer, orderer都需要从本地读取证书相关的信息，所以要把各节点利用&lt;code>nodeSelector&lt;/code>特性绑定到指定的节点上，这一点以后得改掉，利用env来动态生成（待验证）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic">#比如让要在特定节点调度特定容器，需要如下操作&lt;/span>
kubectl label node node0 &lt;span style="color:#b8860b">ca&lt;/span>&lt;span style="color:#666">=&lt;/span>ture
&lt;/code>&lt;/pre>&lt;/div>&lt;p>还要在对应的deployment文件做如下操作&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/nodeSelector.png" alt="nodeSelector">&lt;/p>
&lt;p>-- 未完待续。。。&lt;/p></description></item><item><title>Docs: Windows Terminal终端 入坑指南</title><link>https://xiaoping378.github.io/docs/3-devops/windows-terminal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/windows-terminal/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>为了这个东西，重新安装了系统，目前是在windows LTSC 2021版本下的使用指南。
在IT界Terminal和Console差不多是一个意思，同属于界面层面的，不少人老和Shell搞混了，特此说明下Shell一般是指的Bash、zsh、PowerShell、cmd等。&lt;/p>
&lt;/div>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>为了使用Windows Terminal，在春节期间，重新安装了LTSC 2021版本的系统（之前的LTSC 2019）。&lt;/p>
&lt;blockquote>
&lt;p>它对操作系统内部版本的最低要求为 &lt;code>18362.0&lt;/code>，通过&lt;code>Win+R&lt;/code>输入&lt;code>winver&lt;/code>可以确认本机系统是否支持。&lt;/p>
&lt;/blockquote>
&lt;p>目前有三种办法安装（本人选用的第二种）:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是在应用商店中搜索&lt;code>Windows Terminal&lt;/code>，安装即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;a href="https://github.com/microsoft/terminal/releases">Github release&lt;/a>页面下载安装包，&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#a2f">Add-AppxPackage&lt;/span> Microsoft.WindowsTerminal_&amp;lt;versionNumber&amp;gt;.msixbundle
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>通过命令行&lt;a href="https://github.com/microsoft/winget-cli">winget&lt;/a>、&lt;a href="https://chocolatey.org/">Chocolatey &lt;/a>、&lt;a href="https://scoop.sh/">Scoop &lt;/a>安装，下面以winget为例：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">winget install --id=Microsoft.WindowsTerminal -e
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置">配置&lt;/h2>
&lt;p>现在基本可以图形界面配置了，按照自己的习惯图形操作即可，网上一坨坨的教程，此处不表。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/images/windows-terminal-2022-01-30-12-53-50.png" alt="">&lt;/p>
&lt;p>默认配置保存在了&lt;code>%LOCALAPPDATA%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json&lt;/code>&lt;/p>
&lt;h2 id="技巧">技巧&lt;/h2>
&lt;ol>
&lt;li>快捷键
&lt;ul>
&lt;li>新建终端 -- &lt;code>Ctrl+Shift+t&lt;/code>&lt;/li>
&lt;li>切换终端 -- &lt;code>Alt + Num&lt;/code> , （我这里修改过了）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Quake窗口
&lt;ul>
&lt;li>快捷键是&lt;strong>Win + `&lt;/strong> , 可以快速从屏幕上半区换出终端窗口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="gitbash">GitBash&lt;/h2>
&lt;p>&lt;img src="https://xiaoping378.github.io/images/windows-terminal-2022-01-30-13-32-26.png" alt="">&lt;/p>
&lt;p>本人环境&lt;code>VSCode&lt;/code>和&lt;code>git-bash&lt;/code>都是绿色版本了，免去每次重装系统，都进行各种重复的配置操作，这里介绍下git-bash改造的大致步骤。&lt;/p>
&lt;h3 id="绿色改造">绿色改造&lt;/h3>
&lt;p>在powershell中设置环境变量，git-bash每次启动可以根据此变量，决定加载配置的路径。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#800">[Environment]&lt;/span>::SetEnvironmentVariable(&lt;span style="color:#b44">&amp;#34;HOME&amp;#34;&lt;/span>, &lt;span style="color:#b44">&amp;#34;D:\xxp&amp;#34;&lt;/span>, &lt;span style="color:#b44">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我这里是&lt;code>D:\xxp&lt;/code>目录，这样的话，那些&lt;code>ssh、git、vscode、bash&lt;/code>的自定义配置，都可以免去重装再来一次的痛苦了。&lt;/p>
&lt;p>还可以把日常用到&lt;code>exe&lt;/code>小工具，也放到&lt;code>$HOME/bin&lt;/code>目录下，再加到&lt;code>PATH&lt;/code>环境变量里。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#800">[Environment]&lt;/span>::SetEnvironmentVariable(&lt;span style="color:#b44">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#800">[Environment]&lt;/span>::GetEnvironmentVariable(&lt;span style="color:#b44">&amp;#34;Path&amp;#34;&lt;/span>, &lt;span style="color:#b44">&amp;#34;User&amp;#34;&lt;/span>) + &lt;span style="color:#b44">&amp;#34;;D:\xxp\bin&amp;#34;&lt;/span>,&lt;span style="color:#b44">&amp;#34;User&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="oh-my-zsh主题改造">oh-my-zsh主题改造&lt;/h3>
&lt;p>现在有人直接把zsh装上，然后再安装github上的oh-my-zsh主题，但是启动速度会慢一些，本来bash就比cmd启动慢了，，，&lt;/p>
&lt;p>我是在bash的基础上改造下主题，修改&lt;code>Git\etc\profile.d\git-prompt.sh&lt;/code>文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#a2f;font-weight:bold">if&lt;/span> &lt;span style="color:#a2f">test&lt;/span> -f /etc/profile.d/git-sdk.sh
&lt;span style="color:#a2f;font-weight:bold">then&lt;/span>
&lt;span style="color:#b8860b">TITLEPREFIX&lt;/span>&lt;span style="color:#666">=&lt;/span>SDK-&lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">MSYSTEM&lt;/span>#MINGW&lt;span style="color:#b68;font-weight:bold">}&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">else&lt;/span>
&lt;span style="color:#b8860b">TITLEPREFIX&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b8860b">$MSYSTEM&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">fi&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">if&lt;/span> &lt;span style="color:#a2f">test&lt;/span> -f ~/.config/git/git-prompt.sh
&lt;span style="color:#a2f;font-weight:bold">then&lt;/span>
. ~/.config/git/git-prompt.sh
&lt;span style="color:#a2f;font-weight:bold">else&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#39;\[\033]0;Bash\007\]&amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># 窗口标题&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b44">&amp;#39;\n&amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># 换行&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b44">&amp;#39;\[\033[32;1m\]&amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># 高亮绿色&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b44">&amp;#39;➜ &amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># unicode 字符，右箭头&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b44">&amp;#39;\[\033[33;1m\]&amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># 高亮黄色&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b44">&amp;#39;\W&amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># 当前目录&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">if&lt;/span> &lt;span style="color:#a2f">test&lt;/span> -z &lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$WINELOADERNOEXEC&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">then&lt;/span>
&lt;span style="color:#b8860b">GIT_EXEC_PATH&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#a2f;font-weight:bold">$(&lt;/span>git --exec-path 2&amp;gt;/dev/null&lt;span style="color:#a2f;font-weight:bold">)&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
&lt;span style="color:#b8860b">COMPLETION_PATH&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">GIT_EXEC_PATH&lt;/span>%/libexec/git-core&lt;span style="color:#b68;font-weight:bold">}&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
&lt;span style="color:#b8860b">COMPLETION_PATH&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b68;font-weight:bold">${&lt;/span>&lt;span style="color:#b8860b">COMPLETION_PATH&lt;/span>%/lib/git-core&lt;span style="color:#b68;font-weight:bold">}&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
&lt;span style="color:#b8860b">COMPLETION_PATH&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$COMPLETION_PATH&lt;/span>&lt;span style="color:#b44">/share/git/completion&amp;#34;&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">if&lt;/span> &lt;span style="color:#a2f">test&lt;/span> -f &lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$COMPLETION_PATH&lt;/span>&lt;span style="color:#b44">/git-prompt.sh&amp;#34;&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">then&lt;/span>
. &lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$COMPLETION_PATH&lt;/span>&lt;span style="color:#b44">/git-completion.bash&amp;#34;&lt;/span>
. &lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$COMPLETION_PATH&lt;/span>&lt;span style="color:#b44">/git-prompt.sh&amp;#34;&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b44">&amp;#39;\[\033[31m\]&amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># 红色&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b44">&amp;#39;`__git_ps1`&amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># git 插件&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">fi&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">fi&lt;/span>
&lt;span style="color:#b8860b">PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b44">&amp;#39;\[\033[36m\] &amp;#39;&lt;/span> &lt;span style="color:#080;font-style:italic"># 青色&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">fi&lt;/span>
&lt;span style="color:#b8860b">MSYS2_PS1&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$PS1&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
&lt;span style="color:#080;font-style:italic"># Evaluate all user-specific Bash completion scripts (if any)&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">if&lt;/span> &lt;span style="color:#a2f">test&lt;/span> -z &lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$WINELOADERNOEXEC&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">then&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">for&lt;/span> c in &lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$HOME&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>/.bash_completion.d/*.bash
&lt;span style="color:#a2f;font-weight:bold">do&lt;/span>
&lt;span style="color:#080;font-style:italic"># Handle absence of any scripts (or the folder) gracefully&lt;/span>
&lt;span style="color:#a2f">test&lt;/span> ! -f &lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$c&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span> &lt;span style="color:#666">||&lt;/span>
. &lt;span style="color:#b44">&amp;#34;&lt;/span>&lt;span style="color:#b8860b">$c&lt;/span>&lt;span style="color:#b44">&amp;#34;&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">done&lt;/span>
&lt;span style="color:#a2f;font-weight:bold">fi&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: DEIS 开源PAAS平台实践</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/deis-%E5%BC%80%E6%BA%90paas%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/deis-%E5%BC%80%E6%BA%90paas%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</guid><description>
&lt;p>DEIS（目前已被微软收购）的workflow是开源的Paas平台，基于kubernetes做了一层面向开发者的CLI和接口，做到了让开发者对容器无感知的情况下快速的开发和部署线上应用。&lt;/p>
&lt;blockquote>
&lt;p>workflow是 on top of k8s的，所有组件默认全是跑在pod里的，不像openshift那样对k8s的侵入性很大。&lt;/p>
&lt;/blockquote>
&lt;p>特性如下：&lt;/p>
&lt;ul>
&lt;li>S2I(自动识别源码直接编译成镜像)&lt;/li>
&lt;li>日志聚合&lt;/li>
&lt;li>应用管理（发布，回滚）&lt;/li>
&lt;li>认证&amp;amp;授权机制&lt;/li>
&lt;li>边界路由&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://xiaoping378.github.io/Workflow_Detail.png" alt="Workflow_Detail">&lt;/p>
&lt;p>下面从环境搭建，安装workflow及其基本使用做个梳理。&lt;/p>
&lt;h3 id="初始化k8s集群">初始化k8s集群&lt;/h3>
&lt;p>可以通过&lt;a href="https://github.com/xiaoping378/k8s-deploy">k8s-deploy&lt;/a>项目来离线安装高可用kubernetes集群，我这里是单机演示环境。&lt;/p>
&lt;pre>&lt;code>kubeadm init --kubernetes-version v1.6.2 --pod-network-cidr 12.240.0.0/12
#方便命令自动补全
source &amp;lt;(kubectl completion zsh)
#安装cni网络
cp /etc/kubernetes/admin.conf $HOME/.kube/config
kubectl apply -f kube-flannel-rbac.yml
kubectl apply -f kube-flannel.yml
#使能master可以被调度
kubectl taint node --all node-role.kubernetes.io/master-
#安装ingress-controller, 边界路由作用
kubectl create -f ingress-traefik-rbac.yml
kubectl create -f ingress-traefik-deploy.yml
&lt;/code>&lt;/pre>
&lt;h3 id="初始化helm">初始化helm&lt;/h3>
&lt;p>helm相当于kubernetes里的包管理器，类似yum和apt的作用，只不过它操作的是charts（各种k8s yaml文件的集合，额外还有Chart.yaml -- 包的描述文件）可以理解为基于k8s的应用模板管理类工具， 后面会用它来安装workflow到上面跑起来的k8s集群里。&lt;/p>
&lt;p>从k8s 1.6之后，kubeadm安装的集群，默认会开启RBAC机制，为了让helm可以安装任何应用，我们这里赋予tiller cluster-admin权限&lt;/p>
&lt;pre>&lt;code>kubectl create serviceaccount helm --namespace kube-system
kubectl create clusterrolebinding cluster-admin-helm --clusterrole=cluster-admin --serviceaccount=kube-system:helm
&lt;/code>&lt;/pre>
&lt;p>初始化helm：&lt;/p>
&lt;pre>&lt;code>➜ helm init --service-account helm
$HELM_HOME has been configured at /home/xxp/.helm.
Tiller (the helm server side component) has been installed into your Kubernetes Cluster.
Happy Helming!
➜ helm version
Client: &amp;amp;version.Version{SemVer:&amp;quot;v2.4.1&amp;quot;, GitCommit:&amp;quot;46d9ea82e2c925186e1fc620a8320ce1314cbb02&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
Server: &amp;amp;version.Version{SemVer:&amp;quot;v2.4.1&amp;quot;, GitCommit:&amp;quot;46d9ea82e2c925186e1fc620a8320ce1314cbb02&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
&lt;/code>&lt;/pre>
&lt;p>安装后，默认导入了2个repos，后面安装和搜索应用时，都是从这2个仓里出的，当然也可以自己通过&lt;code>helm repo add&lt;/code>添加本地私有仓&lt;/p>
&lt;pre>&lt;code>➜ helm repo list
NAME URL
stable https://kubernetes-charts.storage.googleapis.com
local http://127.0.0.1:8879/charts
&lt;/code>&lt;/pre>
&lt;p>helm的使用基本流程如下:&lt;/p>
&lt;ul>
&lt;li>helm search: 搜索自己想要安装的应用（chart）&lt;/li>
&lt;li>helm fetch: 下载应用（chart）到本地，可以忽略此步&lt;/li>
&lt;li>helm install: 安装应用&lt;/li>
&lt;li>helm list: 查看已安装的应用情况&lt;/li>
&lt;/ul>
&lt;h3 id="安装workflow">安装workflow&lt;/h3>
&lt;p>添加workflow的repo仓&lt;/p>
&lt;pre>&lt;code>helm repo add deis https://charts.deis.com/workflow
&lt;/code>&lt;/pre>
&lt;p>开始安装workflow，因为RBAC的原因，同样要赋予workflow各组件相应的权限，yml文件在[这里]（https://gist.github.com/xiaoping378/798c39e0b607be4130db655f4873bd24）&lt;/p>
&lt;pre>&lt;code>kubectl apply -f workflow-rbac.yml --namespace deis
helm install deis/workflow --name workflow --namespace deis \
--set global.experimental_native_ingress=true,controller.platform_domain=192.168.31.49.xip.io
&lt;/code>&lt;/pre>
&lt;p>其中会拉取所需镜像，不出意外会有如下结果：&lt;/p>
&lt;pre>&lt;code>➜ kubectl --namespace=deis get pods
NAME READY STATUS RESTARTS AGE
deis-builder-1134410811-11xpp 1/1 Running 0 46m
deis-controller-2000207379-5wr10 1/1 Running 1 46m
deis-database-244447703-v2sh9 1/1 Running 0 46m
deis-logger-2533678197-pzmbs 1/1 Running 2 46m
deis-logger-fluentd-08hms 1/1 Running 0 42m
deis-logger-redis-1307646428-fz1kk 1/1 Running 0 46m
deis-minio-3195500219-tv7wz 1/1 Running 0 46m
deis-monitor-grafana-59098797-mdqh1 1/1 Running 0 46m
deis-monitor-influxdb-168332144-24ngs 1/1 Running 0 46m
deis-monitor-telegraf-vgbr9 1/1 Running 0 41m
deis-nsqd-1042535208-40fkm 1/1 Running 0 46m
deis-registry-2249489191-2jz3p 1/1 Running 2 46m
deis-registry-proxy-qsqc2 1/1 Running 0 46m
deis-router-3258454730-3rfpq 1/1 Running 0 41m
deis-workflow-manager-3582051402-m11zn 1/1 Running 0 46m
&lt;/code>&lt;/pre>
&lt;h3 id="注册管理用户">注册管理用户&lt;/h3>
&lt;p>由于我们是本地ingress-controller, 必须保障deis-builder.$host可以被解析, 自行创建ingress of deis-builder.&lt;/p>
&lt;pre>&lt;code>kubectl apply -f deis-buidler-ingress.yml
&lt;/code>&lt;/pre>
&lt;p>确保traefik有如下状态：&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/traefik-status.png" alt="traefik-status">&lt;/p>
&lt;p>如下操作注册，默认第一个用户为管理员用户，可操作所有其他用户。&lt;/p>
&lt;pre>&lt;code>➜ ~ kubectl get --namespace deis ingress
NAME HOSTS ADDRESS PORTS AGE
builder-api-server-ingress-http deis-builder.192.168.31.49.xip.io 80 18m
controller-api-server-ingress-http deis.192.168.31.49.xip.io 80 1h
➜ ~
➜ ~ deis register deis.192.168.31.49.xip.io
username: admin
password:
password (confirm):
email: xiaoping378@163.com
Registered admin
Logged in as admin
Configuration file written to /home/xxp/.deis/client.json
➜ ~
➜ ~ deis whoami
You are admin at http://deis.192.168.31.49.xip.io
&lt;/code>&lt;/pre>
&lt;h3 id="部署第一个应用">部署第一个应用&lt;/h3></description></item><item><title>Docs: k3s实践-01</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/k3s-%E5%BC%80%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/k3s-%E5%BC%80%E7%AF%87/</guid><description>
&lt;div class="pageinfo pageinfo-primary">
&lt;p>本文主要介绍k3s的安装和核心组件解读。&lt;/p>
&lt;/div>
&lt;p>k3s是all-in-one的轻量k8s发行版，把所有k8s组件打包成一个不到100M的二进制文件了。具备如下显著特点：&lt;/p>
&lt;ul>
&lt;li>打包成单一二进制&lt;/li>
&lt;li>默认集成了sqlite3来替代etcd，也可以指定其他数据库：etcd3、mysql、postgres。&lt;/li>
&lt;li>默认内置Coredns、Metrics Server、Flannel、Traefik ingress、Local-path-provisioner等&lt;/li>
&lt;li>默认启用了TLS加密通信。&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>官方提供了一键安装脚本&lt;a href="https://get.k3s.io">install.sh&lt;/a> ，执行&lt;code>curl -sfL https://get.k3s.io | sh -&lt;/code>可一键安装server端。此命令会从&lt;code>https://update.k3s.io/v1-release/channels/stable&lt;/code>取到最新的稳定版安装，可以通过&lt;code>INSTALL_K3S_VERSION&lt;/code>环境变量指定版本，本文将以1.19为例。&lt;/p>
&lt;p>&lt;strong>启动 k3s server端(master节点).&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl -sfL https://get.k3s.io | &lt;span style="color:#b8860b">INSTALL_K3S_VERSION&lt;/span>&lt;span style="color:#666">=&lt;/span>v1.19.16+k3s1 sh -
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>由于网络原因，可能会失败，自行想办法&lt;a href="https://github.com/k3s-io/k3s/releases/download/v1.19.16+k3s1/k3s">下载&lt;/a>下来，放置 &lt;code>/usr/local/bin/k3s&lt;/code>，附上执行权限&lt;code>chmod a+x /usr/local/bin/k3s&lt;/code>, 然后上面的命令加上&lt;code>INSTALL_K3S_SKIP_DOWNLOAD=true&lt;/code>再执行一遍即可。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>安装里log里会输出一些重要信息: &lt;code>kubectl、crictl、卸载脚本、systemd service&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>不出意外，k3s server会被systemd启动，执行命令查看&lt;code>systemctl status k3s&lt;/code>或者通过软链的kubectl验证是否启动成功：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">➜ kubectl get no
NAME STATUS ROLES AGE VERSION
gitlab-server Ready master 6m43s v1.19.16+k3s1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>(Optional)&lt;/strong> 启动 k3s agent端 (添加worker节点).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl -sfL https://get.k3s.io | &lt;span style="color:#b8860b">K3S_URL&lt;/span>&lt;span style="color:#666">=&lt;/span>https://172.25.11.130:6443 &lt;span style="color:#b8860b">K3S_TOKEN&lt;/span>&lt;span style="color:#666">=&lt;/span>bulabula &lt;span style="color:#b8860b">INSTALL_K3S_VERSION&lt;/span>&lt;span style="color:#666">=&lt;/span>v1.19.16+k3s1 sh -
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>K3S_TOKEN&lt;/code>内容需要从server端的&lt;code>/var/lib/rancher/k3s/server/node-token&lt;/code>文件取出&lt;/li>
&lt;li>&lt;code>K3S_URL&lt;/code>中的IP是master节点的IP。&lt;/li>
&lt;/ul>
&lt;h2 id="集群访问">集群访问&lt;/h2>
&lt;p>默认kubectl通过localhost访问本地集群，所以上文敲kubectl是没问题的，如果要被外部访问或者纳管的话，可以把kubeconfig文件拷走，默认路径是 &lt;code>/etc/rancher/k3s/k3s.yaml&lt;/code>
。记得修改文件内的server字段，改成外部可访问到的IP。&lt;/p>
&lt;h2 id="架构说明">架构说明&lt;/h2>
&lt;p>TODO.&lt;/p></description></item><item><title>Docs: 性能优化指南</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</guid><description>
&lt;p>主要参考的官方&lt;a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/3.5/html-single/scaling_and_performance_guide/">链接&lt;/a>， 本文是基于openshift 3.5说的。&lt;/p>
&lt;h2 id="概览">概览&lt;/h2>
&lt;p>本指南提供了如何提高OpenShift容器平台的集群性能和生产环境下的最佳实践。 主要包括建立，扩展和调优OpenShift集群的推荐做法。&lt;/p>
&lt;p>个人看法，其实性能这个东西是个权衡的过程，根据自身硬件条件和实际需求，选择适合自己的调优手段。&lt;/p>
&lt;h2 id="安装实践">安装实践&lt;/h2>
&lt;h3 id="网络依赖">网络依赖&lt;/h3>
&lt;p>首先安装自然要选择官方的&lt;a href="https://github.com/openshift/openshift-ansible">openshift-ansible项目&lt;/a>， 默认是rpm安装方式，需要依赖网络，比如要去联网下载&lt;code>atomic-openshift-*, iptables, 和 docker&lt;/code>包依赖，&lt;/p>
&lt;p>如果有不能联网的节点，可以参考我之前写的&lt;a href="https://github.com/xiaoping378/openshift-deploy">离线安装openshift&lt;/a>。&lt;/p>
&lt;h3 id="ansible优化">ansible优化&lt;/h3>
&lt;p>官方推荐使用ansible安装，这里说下针对ansible的优化，以提高安装效率，主要参考&lt;a href="https://www.ansible.com/blog/ansible-performance-tuning">ansible官方blog&lt;/a>,&lt;/p>
&lt;p>如果参考上文离线安装的话，不建议跨外网连接rpm仓或者镜像仓，下面是推荐的ansible配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#080;font-style:italic"># cat /etc/ansible/ansible.cfg&lt;/span>
&lt;span style="color:#080;font-style:italic"># config file for ansible -- http://ansible.com/&lt;/span>
&lt;span style="color:#080;font-style:italic"># ==============================================&lt;/span>
&lt;span style="color:#666">[&lt;/span>defaults&lt;span style="color:#666">]&lt;/span>
&lt;span style="color:#b8860b">forks&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">20&lt;/span> &lt;span style="color:#080;font-style:italic"># 20个并发是理想值，太高的话中间会有概率出错&lt;/span>
&lt;span style="color:#b8860b">host_key_checking&lt;/span> &lt;span style="color:#666">=&lt;/span> False
&lt;span style="color:#b8860b">remote_user&lt;/span> &lt;span style="color:#666">=&lt;/span> root
&lt;span style="color:#b8860b">roles_path&lt;/span> &lt;span style="color:#666">=&lt;/span> roles/
&lt;span style="color:#b8860b">gathering&lt;/span> &lt;span style="color:#666">=&lt;/span> smart
&lt;span style="color:#b8860b">fact_caching&lt;/span> &lt;span style="color:#666">=&lt;/span> jsonfile
&lt;span style="color:#b8860b">fact_caching_connection&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#b8860b">$HOME&lt;/span>/ansible/facts
&lt;span style="color:#b8860b">fact_caching_timeout&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">600&lt;/span>
&lt;span style="color:#b8860b">log_path&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#b8860b">$HOME&lt;/span>/ansible.log
&lt;span style="color:#b8860b">nocows&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">1&lt;/span>
&lt;span style="color:#b8860b">callback_whitelist&lt;/span> &lt;span style="color:#666">=&lt;/span> profile_tasks
&lt;span style="color:#666">[&lt;/span>privilege_escalation&lt;span style="color:#666">]&lt;/span>
&lt;span style="color:#b8860b">become&lt;/span> &lt;span style="color:#666">=&lt;/span> False
&lt;span style="color:#666">[&lt;/span>ssh_connection&lt;span style="color:#666">]&lt;/span>
&lt;span style="color:#b8860b">ssh_args&lt;/span> &lt;span style="color:#666">=&lt;/span> -o &lt;span style="color:#b8860b">ControlMaster&lt;/span>&lt;span style="color:#666">=&lt;/span>auto -o &lt;span style="color:#b8860b">ControlPersist&lt;/span>&lt;span style="color:#666">=&lt;/span>600s
&lt;span style="color:#b8860b">control_path&lt;/span> &lt;span style="color:#666">=&lt;/span> %&lt;span style="color:#666">(&lt;/span>directory&lt;span style="color:#666">)&lt;/span>s/%%h-%%r
&lt;span style="color:#b8860b">pipelining&lt;/span> &lt;span style="color:#666">=&lt;/span> True &lt;span style="color:#080;font-style:italic"># 多路复用，减少了控制机和目标间的连接次数，加速了性能。&lt;/span>
&lt;span style="color:#b8860b">timeout&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#666">10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="网络配置">网络配置&lt;/h3>
&lt;p>这里必须要提下，一定要安装前做好网络规划，不然后面改起来很麻烦，&lt;/p>
&lt;p>默认是每个node上最多可跑110个pods，这个要看自身硬件条件，比如说我的环境全是高配物理机，我就改成了，每个节点可以跑1024个pods，这个主要改下面的地方。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#b8860b">openshift_node_kubelet_args&lt;/span>&lt;span style="color:#666">={&lt;/span>&lt;span style="color:#b44">&amp;#39;pods-per-core&amp;#39;&lt;/span>: &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#b44">&amp;#39;0&amp;#39;&lt;/span>&lt;span style="color:#666">]&lt;/span>, &lt;span style="color:#b44">&amp;#39;max-pods&amp;#39;&lt;/span>: &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#b44">&amp;#39;1024&amp;#39;&lt;/span>&lt;span style="color:#666">]&lt;/span>, &lt;span style="color:#b44">&amp;#39;image-gc-high-threshold&amp;#39;&lt;/span>: &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#b44">&amp;#39;90&amp;#39;&lt;/span>&lt;span style="color:#666">]&lt;/span>, &lt;span style="color:#b44">&amp;#39;image-gc-low-threshold&amp;#39;&lt;/span>: &lt;span style="color:#666">[&lt;/span>&lt;span style="color:#b44">&amp;#39;80&amp;#39;&lt;/span>&lt;span style="color:#666">]}&lt;/span>
&lt;span style="color:#b8860b">osm_host_subnet_length&lt;/span>&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#666">10&lt;/span>
&lt;span style="color:#b8860b">osm_cluster_network_cidr&lt;/span>&lt;span style="color:#666">=&lt;/span>12.1.0.0/12
&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于网络的更多优化项，后面有单独介绍。&lt;/p>
&lt;h2 id="主机节点优化">主机节点优化&lt;/h2>
&lt;p>openhshift集群里，除了pod间的网络通信外，最大的开销就是master和etcd间的通信了，openshift的master集成了k8s里的api-server, master主要通过etcd来交互node状态，网络配置，secrets和卷挂载等等信息&lt;/p>
&lt;h3 id="master侧">master侧&lt;/h3>
&lt;p>主要优化点包括：&lt;/p>
&lt;ul>
&lt;li>master和etcd尽量部署在一起.&lt;/li>
&lt;li>高可用集群里，master尽量部署在低延迟的网络里.&lt;/li>
&lt;li>确保**/etc/origin/master/master-config.yaml**里的etcds，第一个是本地的etcd实例.&lt;/li>
&lt;/ul>
&lt;h3 id="node侧">node侧&lt;/h3>
&lt;p>node节点的配置主要在**/etc/origin/node/node-config.yaml**里， 优化点视具体情况定，主要可以优化的点有：&lt;/p>
&lt;ul>
&lt;li>iptables synchronization period,&lt;/li>
&lt;li>MTU值&lt;/li>
&lt;li>代理模式&lt;/li>
&lt;/ul>
&lt;p>配合自文件里还可以配置kubelet的启动参数，主要关注两点&lt;code>pods-per-core 和 max-pods&lt;/code>，这两个决定了node节点的pod数，两者不一致时，&lt;code>取值小的&lt;/code>。如果数值过大（严重超卖）会导致：&lt;/p>
&lt;ul>
&lt;li>增加cpu消耗，主要是docker和openshift自身管理消耗的&lt;/li>
&lt;li>降低pod调度效率&lt;/li>
&lt;li>加大了OOM的风险&lt;/li>
&lt;li>分配pod ip出异常（可能地址池不够了，默认254个ip）&lt;/li>
&lt;li>影响应用的性能&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>有一点要注意，k8s体系的平台，跑一个pod，实际会启动两个容器，一个pause先于业务容器启动，主要负责网络事项，所以跑10个pods，实际上会运行20个容器&lt;/p>
&lt;/blockquote>
&lt;h3 id="etcd节点">etcd节点&lt;/h3>
&lt;p>etcd是一个分布式的key-value存储，所以有条件的话，存储读写性能的提升，上ssd最好了。&lt;/p>
&lt;p>其次是网络的优化，比如和masters部署在一起，或者提供专网连接。&lt;/p>
&lt;blockquote>
&lt;p>etcd实际使用中，最好的提升手段，是关注内存，这个官网有个换算公式的，多少pods推荐多大内存的使用&lt;/p>
&lt;/blockquote>
&lt;h3 id="内核优化">内核优化&lt;/h3>
&lt;p>上面的所有节点，内核层面都需要做些优化，这里推荐使用tuned工具来做，这点属于常规运维优化了，具体可以参考&lt;a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html-single/Performance_Tuning_Guide/index.html#chap-Red_Hat_Enterprise_Linux-Performance_Tuning_Guide-Tuned">这里&lt;/a>来做， 不想明白原理的，可以如下 快速操作，redhat的人已经自动化了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">yum install tuned
systemctl start tune
systemctl &lt;span style="color:#a2f">enable&lt;/span> tuned
tuned-adm profile throughput-performance&lt;span style="color:#666">)&lt;/span>来做
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="资源优化">资源优化&lt;/h2>
&lt;h3 id="超卖现象">超卖现象&lt;/h3>
&lt;p>主要是资源管理这块儿的注意点， 我以前有&lt;a href="../openshift%E5%AE%9E%E8%B7%B5-%E6%9D%83%E9%99%90%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86">blog&lt;/a>专门介绍过，主要值得一提的是，这里有个隐形的QoS级别&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-qos.png" alt="">&lt;/p>
&lt;p>Guaranteed类型的pod是优先级最高的，是有保证的，只会在程序本身“异常”超出limits（一般的应用在pod层设置了limits，就不会超过该限制的，除非是java系的，其需要用环境变量来控制），才会被杀掉，其他类型的配额在集群资源紧张时会被kill掉的。&lt;/p>
&lt;p>这块儿更多的细节也可以参考&lt;a href="https://docs.openshift.org/latest/admin_guide/overcommit.html">官文&lt;/a>&lt;/p>
&lt;h3 id="镜像">镜像&lt;/h3>
&lt;p>这里需要注意的是，可以提前把需要的基础镜像先pull到node节点上，比如&lt;code>origin-pod&lt;/code>镜像等，还有其他自定义的&lt;code>Gold 镜像&lt;/code>，这样可以减少应用部署时间。&lt;/p>
&lt;p>如果是采用镜像方式部署集群的话，也可以采取提前pull镜像的方式，当然有私有镜像仓的，可以忽略。&lt;/p>
&lt;p>主要是现在默认的镜像拉取策略就是&lt;code>IfNotPresent&lt;/code>，才能完成加速部署的效果&lt;/p>
&lt;h3 id="线上debug容器">线上debug容器&lt;/h3>
&lt;p>线上容器环境可能很&lt;code>干净&lt;/code>， 如何调试一个线上正在运行的容器，估计困扰过很多开发人员，这个其实利用docker原生特性，可以很easy的做到&lt;/p>
&lt;p>比如你自己build一个工具包镜像tools，里面装有&lt;code>tcpdump，perf，strace&lt;/code>等等debug工具，如下可以很方便的动态的嵌入到运行的线上容器中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">docker run -t --pid&lt;span style="color:#666">=&lt;/span>container:production &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> --net&lt;span style="color:#666">=&lt;/span>container:production &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> --cap-add sys_admin &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> --cap-add sys_ptrace &lt;span style="color:#b62;font-weight:bold">\
&lt;/span>&lt;span style="color:#b62;font-weight:bold">&lt;/span> tools
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然万能的日志调式，也是OK的。&lt;/p>
&lt;h2 id="存储优化">存储优化&lt;/h2>
&lt;p>这里的存储说的是docker的graph驱动（ Device Mapper, Overlay, 和 Btrfs），首先overlay在启停容器速度方面要优于devicemapper，其还能带来更优良的页面缓存共享，但存在POSIX兼容性问题，比如不支持SELinux。&lt;/p>
&lt;p>官方是推荐使用thin devicemapper的，但需要额外的独立块盘才能搞定。如果系统是7.2的话，使用overlay亦可，关闭selinux的代价就是牺牲部分容器安全。&lt;/p>
&lt;h2 id="路由和网络优化">路由和网络优化&lt;/h2>
&lt;p>openshift里的Router是基于haproxy做的，等价于k8s里的nginx ingress服务，提供集群内的service供外访问能力。&lt;/p>
&lt;p>一般一个4 vCPU/16GB RAM的虚机，可以提供7000-32000 HTTP keep-alive连接请求，这取决于连接是否加密和页面大小，如果是物理机的话，性能会翻倍。&lt;/p>
&lt;p>可通过Router sharding的技术来扩展性能。下图各种配置是统计性能（默认100个routes）&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/haproxy-perf.png" alt="">&lt;/p>
&lt;h3 id="网络优化">网络优化&lt;/h3>
&lt;p>默认openshift提供了一个基于ovs的sdn方案，其中涉及到了vxlan, OpenFlow和iptables，当然这些相关的优化项社区已经有很成熟的优化点和方法了，比如增大MTU，UDP-offload，多路复用等等，&lt;/p>
&lt;p>这里重点说下vxlan， 基于二层网络，vxlan从4096提升到了16百万多个，vxlan就是把原报文封装进UDP报文，以提供所有pods间通信的能力，自然这样会增加cpu解封包的开销，具体网络吞吐取决于cpu的性能，另外还会额外增加延时响应。&lt;/p>
&lt;p>直白的说，现在云主机或物理机的cpu都可以打满千兆网卡，如果是万兆网卡，那vxlan网络的吞吐带宽会卡在CPU上，这是所有overlay网络的现状。&lt;/p>
&lt;p>如果你的主机用用万兆或者40Gbps, 那就要考虑网络的性能优化了：&lt;/p>
&lt;ul>
&lt;li>通过直接路由，负责pod间通信，不过需要手动维护node节点添加删除时的路由变化。&lt;/li>
&lt;li>条件允许的话，可以考虑BGP的calico网络方案&lt;/li>
&lt;li>另外就是购置支持udp-offload的网卡&lt;/li>
&lt;/ul>
&lt;p>值得注意点是，及时使用了udp-offload的网卡，和非overlay网络比，延迟是不会减少的，只是减少了cpu开销，从而提高了带宽吞吐。&lt;/p>
&lt;h3 id="子网大小">子网大小&lt;/h3>
&lt;p>现在openshift-ansible项目默认的安装出来的配置是：&lt;/p>
&lt;ul>
&lt;li>集群里内最多1024个节点&lt;/li>
&lt;li>每个节点最多可以跑510个pods&lt;/li>
&lt;li>支持65,536个service&lt;/li>
&lt;/ul>
&lt;p>比如我要搞一个8192个节点的集群，每个节点允许510个pods运行：&lt;/p>
&lt;pre tabindex="0">&lt;code>[OSE3:vars]
osm_cluster_network_cidr=10.128.0.0/10
&lt;/code>&lt;/pre>&lt;h2 id="监控">监控&lt;/h2>
&lt;p>都知道k8s里的弹性伸缩，依赖于Heapster, 而openshift内置的监控系统又是用的自家的Haw系列，导致监控镜像相当的大&lt;/p>
&lt;p>在opneshift里有两点要提的是&lt;code>METRICS_RESOLUTION&lt;/code>和&lt;code>METRICS_DURATION&lt;/code>变量，前者是默认是30s,指的是监控时间间隔，后者默认是7天，指的是监控数据保留时长（过期就会删掉）。&lt;/p>
&lt;p>&lt;img src="https://xiaoping378.github.io/openshift-monitor%E7%A9%BA%E9%97%B4.png" alt="">&lt;/p>
&lt;p>默认的监控体系(Cassandra/Hawkular/Heapster)可以监控25000个pods。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>其实openshift基于k8s提供了一站式解决方案, 如果公司不具备k8s二次开发能力，openshift足矣。&lt;/p></description></item><item><title>Docs: 网络整理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</guid><description>
&lt;p>介绍利用openshift-ansible项目安装后的生产环境里的网络情况。&lt;/p>
&lt;p>待整理。。。&lt;/p></description></item><item><title>Docs: 监控梳理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%9B%91%E6%8E%A7%E6%A2%B3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%9B%91%E6%8E%A7%E6%A2%B3%E7%90%86/</guid><description>
&lt;p>未完搞 ...&lt;/p></description></item><item><title>Docs: 日志分析</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</guid><description>
&lt;p>未完搞 ...&lt;/p></description></item></channel></rss>