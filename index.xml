<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>现代技能栈</title><link>https://xiaoping378.github.io/</link><description>Recent content on 现代技能栈</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://xiaoping378.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>机器学习的语言之争</title><link>https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/</guid><description>&lt;p&gt;原文：&lt;a href="http://sebastianraschka.com/blog/2015/why-python.html"&gt;Python, Machine Learning, and Language Wars - A Highly Subjective Point of View&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;噢，天呀，那些主观有针对性的，自以为标题党的文章的另一个？是哒！为什么我还要不厌其烦的写下来呢？嗯，这里是来自于我的前教授的最琐碎但又改变生活的洞察和世俗的智慧之一，它已经成为了我的口头禅了：“如果你必须做这个任务超过三次以上，那么只要写一个脚本，然后对其自动化。”&lt;/p&gt;
&lt;p&gt;现在，你或许已经开始琢磨这个博客了。我已经超过半年没写什么东西了！好吧，&lt;a href="https://twitter.com/rasbt"&gt;沉迷在社交网络平台&lt;/a&gt;除外，那不是真的：我写了&lt;a href="https://github.com/rasbt/python-machine-learning-book"&gt;一些东西&lt;/a&gt; —— 准确来说，约400页。最近，对我来说，这真的已经是一次旅程了。而对于经常被问道的问题“为什么你选择Python来进行机器学习？”，我猜，是时候来写_我的脚本_了。&lt;/p&gt;
&lt;p&gt;在下面的段落中，我真的不打算告诉你为什么_你_或者其他人应该使用Python。老实说，我真心讨厌那类问题：“哪个&lt;em&gt;最好？”（这里，用“编程语言、文本编辑器、IDE、操作系统、计算机制造商”替换掉&lt;/em&gt;）。这实在是扯淡。虽然有时它挺有意思的，但是我建议你节省下关于这个问题的时间，用来在下班后跟朋友或者同事偶尔喝喝啤酒或咖啡。&lt;/p&gt;
&lt;h4 id="目录"&gt;目录&lt;a class="td-heading-self-link" href="#%e7%9b%ae%e5%bd%95" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;!-- MarkdownTOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#%e5%af%b9%e4%ba%8e%e4%b8%80%e4%b8%aa%e5%a4%8d%e6%9d%82%e9%97%ae%e9%a2%98%e7%9a%84%e7%ae%80%e7%9f%ad%e5%9b%9e%e7%ad%94"&gt;对于一个复杂问题的简短回答&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#%e6%88%91%e6%9c%80%e5%96%9c%e6%ac%a2%e7%9a%84python%e5%b7%a5%e5%85%b7%e6%98%af%e4%bb%80%e4%b9%88"&gt;我最喜欢的Python工具是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#%e6%88%91%e5%af%b9matlab%e6%98%af%e6%80%8e%e4%b9%88%e7%9c%8b%e7%9a%84"&gt;我对MATLAB是怎么看的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#julia%e7%9c%9f%e6%a3%92%e7%90%86%e8%ae%ba%e4%b8%8a"&gt;Julia真棒……理论上！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#r%e5%ae%9e%e5%9c%a8%e6%b2%a1%e5%95%a5%e9%94%99"&gt;R实在没啥错&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#perl%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88"&gt;Perl发生了什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#%e5%85%b6%e4%bb%96%e8%a7%82%e7%82%b9"&gt;其他观点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#python%e6%98%af%e4%b8%80%e4%b8%aa%e6%ad%a3%e5%9c%a8%e6%ad%bb%e6%8e%89%e7%9a%84%e8%af%ad%e8%a8%80%e5%90%97"&gt;Python是一个正在死掉的语言吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#%e6%80%bb%e7%bb%93"&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#%e5%8f%8d%e9%a6%88%e5%92%8c%e8%a7%82%e7%82%b9"&gt;反馈和观点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#python"&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#perl"&gt;Perl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#r"&gt;R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#matlaboctave"&gt;MATLAB/Octave&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#julia"&gt;Julia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%89-python/#%e5%85%b6%e4%bb%96%e8%af%ad%e8%a8%80-%e6%88%91%e5%bf%98%e8%ae%b0%e6%8f%90%e7%9a%84%e9%82%a3%e4%ba%9b"&gt;其他语言 (我忘记提的那些)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /MarkdownTOC --&gt;
&lt;h2 id="对于一个复杂问题的简短回答"&gt;对于一个复杂问题的简短回答&lt;a class="td-heading-self-link" href="#%e5%af%b9%e4%ba%8e%e4%b8%80%e4%b8%aa%e5%a4%8d%e6%9d%82%e9%97%ae%e9%a2%98%e7%9a%84%e7%ae%80%e7%9f%ad%e5%9b%9e%e7%ad%94" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;或许我应该从一个简短的回答开始。欢迎你停止阅读这段后面的文章，因为它真的解决掉这个问题了。我是一个科学家，我喜欢完成我的工作。我喜欢有一个环境，在那里我可以快速原型，并记下我的模型和想法。我需要解决非常特殊的问题。我分析给定的数据集以得出结论。这对我来说是最重要的：我怎样才能最多产的完成我的工作呢？“多产”这里意味着什么？好吧，我通常只进行一次分析 (不同的想法测试和调试除外); 我不需要重复地24/7地运行一段特定的代码，我并不是在为最终用户开发软件应用或web应用。当我_量化y_ “多产”时，我从字面上评估(1) 把想法以代码的形式写下来所花费的时间，(2) 调试的时间和 (3) 执行的时间之和。对我来说，“最多产”意味着“获得结果需要花费多少时间？” 现在，这么多年来，我发现，Python就是为我而生的。并非总是如此，但很多时候是这样。正如生活中的其他东西一样，Python并不是“银弹”，它并非总是每一个问题的“最佳”解决方案。然而，如果你跨常见和不那么常见的问题任务来比较编程语言的话，它已经非常接近（最佳解决方案）了；Python可能是最通用，最有能力的全才。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://sebastianraschka.com/images/blog/2015/why-python/the_general_problem.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;(来源: &lt;a href="https://xkcd.com/974/"&gt;https://xkcd.com/974/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;请记住：“过早的优化是一切罪恶的根源” (Donald Knuth)。如果你是那种想要从机器学习和数据科学划分中中优化下一个颠覆性高频交易模型的软件工程团队中的一员，那么Python可能不适合你 (但或许它是数据科学团队的语言选择，所以学习如何读懂它仍然有用)。因此，我的一个小小的忠告是，当你选择一门语言时，评估你每天的问题任务和需求。“如果你只有一把锤子，那么一切开始看起来都像一个钉子” – 你聪明得不会掉入这个陷阱！然而，记住，有一个平衡点。在有些场景下，即使螺丝刀可能是“更漂亮的”解决方法，锤子可能还是最好的选择。再次，这归结为生产力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;让我从个人经历中挑个例子来说说。&lt;/strong&gt; 关于一个非常问题相关的假设，我需要开发一堆新颖的算法来“筛选”1千5百万个小的化合物。我完全是一个计算型人，但我和进行非计算性实验（我们称它们为“湿实验室”实验）的生物学家一起合作。目标是缩小它到一个包含100个潜在化合物的列表，这样他们可以在实验室里测试它们。提醒是，他们需要快速获得结果，因为他们仅有有限的实际来做实验。相信我，时间真的是“有限的”：在必须收集结果之前，我们刚让我们的补助金申请受理和研究得到资助 (我们的合作者对某种特定的只知春季产卵的幼虫做实验)。因此，我开始想“我要怎样尽可能快的把结果给他们？” 嗯，我懂C++和FORTRAN，如果我在各个语言中实现那些算法，那么与Python实现相比，执行“筛选”运行也许会更快些。这更多是一种有根据的猜测，我真的不知道实质上是否会更快。但有一件事我可以肯定：如果我开始用Python写代码，那么我可以让它在几天内运行 – 或许让对应的C++版本能够跑起来需要花一周的时间。以后，我会操心一个更有效的实现。在那一刻，重要的是，把那些结果拿给我的合作者 – “过早的优化是一切罪恶的根源。” 边注：相同的思路运用到数据存储解决方案。这里，我只是使用SQLite。CSV没有多大意义，因为我必须重复地注释和检索某些分子。我当然不想每次想要查看一个分子或者操作它的时候，都要全过程扫描或重写一个CSV – 在处理内存容量预留的问题。也许用MySQL会更好，但是出于上面提到的原因，我想快速地完成这项工作，并建立一个额外的SQL服务器……没时间做它了，用SQLite来完成这项工作挺好的。&lt;/p&gt;</description></item><item><title>什么是以太坊</title><link>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%9F%BA%E7%A1%800/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%9F%BA%E7%A1%800/</guid><description>&lt;h3 id="目录"&gt;目录&lt;a class="td-heading-self-link" href="#%e7%9b%ae%e5%bd%95" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;什么是以太坊&lt;/li&gt;
&lt;li&gt;应用场景&lt;/li&gt;
&lt;li&gt;趋势展望&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="内容"&gt;内容&lt;a class="td-heading-self-link" href="#%e5%86%85%e5%ae%b9" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1.什么是以太坊&lt;/p&gt;
&lt;p&gt;以太坊是一个全新开放的区块链平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。&lt;/p&gt;
&lt;p&gt;1.1. 从名字说起&lt;/p&gt;
&lt;p&gt;以太坊 == ethereum，&lt;/p&gt;
&lt;p&gt;Ether，物理学里面有个以太，绝对静止的存在于空间的那种物质，尚未证明是否真实存在，在某领域里，它被称为虚空，空间…是一种能承载万物的东西，是一种目前还难以解释和观察的东西。&lt;/p&gt;
&lt;p&gt;至于这个“坊”字，也不知道是谁先翻译叫起来的，反正现在大家都这么叫。&lt;/p&gt;
&lt;p&gt;1.2 从功能说起&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.ethereum.org/ether"&gt;以太&lt;/a&gt;是区块链网络里很重要的元素 -- 燃料 -- 以太币，为计算付费。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 开发人员发布Dapp
2. 用户和Dapp交互
3. 挖矿得到报酬（维持网络稳定的）
4. 金融交易
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.3 从产出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2014年9月份预售阶段发了6千万以太币，（募集到 31,531 个比特币）&lt;/li&gt;
&lt;li&gt;其中20%用于以太基金的运作，主要是给开发人员发工资。&lt;/li&gt;
&lt;li&gt;挖矿，大概每15秒左右出一个块，作为报酬，出块的人可以得到5个以太&lt;/li&gt;
&lt;li&gt;打包叔块的人会得到2-3个以太&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自从&lt;a href="https://blog.ethereum.org/2017/10/12/byzantium-hf-announcement/"&gt;Byzantium update&lt;/a&gt;升级后，现在挖矿和挖到叔块的人会分别得到3和0.625-2.625个以太。&lt;/p&gt;
&lt;p&gt;1.4 FAQ&lt;/p&gt;
&lt;p&gt;1.4.1 以太比会无限发行么？&lt;/p&gt;
&lt;p&gt;不会， 当时预售的时候规定，每年的发行量是1800万上限（被挖到），计划在17年底，会切换共识算法从POW到&lt;a href="https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/"&gt;Casper&lt;/a&gt;上，之后出块效率更高，需要的挖矿补贴更少, 具体发行多少，现在还未定。&lt;/p&gt;
&lt;p&gt;1.4.2 以太币和比特币的对比？&lt;/p&gt;
&lt;p&gt;如果后者，以太币是不可能实现的，在整个数字生态是互补关系，Ether应被视为“加密燃料”，其目的是为计算付费，而不是用作或被视为货币，资产，份额或其他任何东西。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.ethereum.org/images/bitcoin-and-ethereum-sitting-on-a-tree@2x.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;技术层面的对比&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/BTC-ETH.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;1.2 账户&lt;/p&gt;
&lt;p&gt;以太坊有两种类型的账户：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部账户（由私钥控制的）&lt;/li&gt;
&lt;li&gt;合约账户（由合约代码控制）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另种账户都可以发起交易，后者被动发送。&lt;/p&gt;
&lt;p&gt;外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。&lt;/p&gt;
&lt;p&gt;UTXOs的好处有：
更加私密（用户要是每笔交易都换一个地址，那么就很难找到其中两个地址的相关性）；潜在的可扩展性。&lt;/p&gt;
&lt;p&gt;账户的好处：
节省大量空间（每笔交易只有一个输入、一个输出、一个签名）；更大的可替代性；简单（编码简单，不需要更为复杂脚本）；&lt;/p&gt;
&lt;p&gt;1.3 以太坊虚拟机EVM&lt;/p&gt;</description></item><item><title>AI大模型应用开发-扫盲篇</title><link>https://xiaoping378.github.io/docs/7-ai/%E6%89%AB%E7%9B%B2%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/7-ai/%E6%89%AB%E7%9B%B2%E7%AF%87/</guid><description>&lt;!-- # AI大模型应用开发-扫盲篇 --&gt;
&lt;p&gt;当下从工程技术角度来看，AI大模型可以分为十个领域：前沿大模型、基准评估、提示思维链、检索增强生成、智能体、代码生成、视觉、声音、图像/视频扩散、微调。
本文旨在扫盲大模型应用开发基础概念，并介绍大模型应用开发的常见模式。&lt;/p&gt;
&lt;h2 id="一-怎样得到一个大模型"&gt;一、怎样得到一个大模型？&lt;a class="td-heading-self-link" href="#%e4%b8%80-%e6%80%8e%e6%a0%b7%e5%be%97%e5%88%b0%e4%b8%80%e4%b8%aa%e5%a4%a7%e6%a8%a1%e5%9e%8b" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有卡没卡两种玩法，如果只面向应用开发，结合上信息安全的背景，则推荐使用社区开源模型或集成企业内部模型(下节介绍)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="1-囤卡自己训练-全流程定制"&gt;1. 囤卡自己训练（全流程定制）&lt;a class="td-heading-self-link" href="#1-%e5%9b%a4%e5%8d%a1%e8%87%aa%e5%b7%b1%e8%ae%ad%e7%bb%83-%e5%85%a8%e6%b5%81%e7%a8%8b%e5%ae%9a%e5%88%b6" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;核心概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AI(artificial intelligence)&lt;/strong&gt;: 由来已久的概念，本文特指的生成式人工智能（gen AI），将机器学习和深度学习的神经网络提升到了一个新的水平。它可以创建新的内容和想法（例如图像和视频）, 也可以使用已知知识来解决新问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LLM (Large Language Model)&lt;/strong&gt;: 大型语言模型，是基于大量数据进行预训练得到的超大型深度学习模型，可自主学习（统计归纳），会理解（Token向量化）人类基本的语法、语言和知识。一般用参数的多少来衡量大模型能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPT (Generative Pre-trained Transformer)&lt;/strong&gt;: 生成式预训练 Transformer 模型，是一系列使用 Transformer 架构的神经网络模型，能够回答产出（关联预测）类似人类的文本和内容（图像、音乐等），并以对话方式回答问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transformer 模型&lt;/strong&gt;: GPT的核心，是一种神经网络架构，它使用了自注意力机制（self-attention）来处理序列数据，并使用了多头自注意力（multi-head self-attention）来提高模型的性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pre-trained (预训练)&lt;/strong&gt;: 在无标注通用数据（如Common Crawl）上训练出基础模型，从已知找规律（优化损失函数）学习语言规律和世界知识，预测产出未知。需从头构建模型，通常需要超万亿token的庞大数据集和数万张高性能GPU（如H100/A100）组成的算力集群。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fine-tuning (微调)&lt;/strong&gt;: 在预训练模型基础上，用于特定领域数据（如金融客服、辅助编码）调整参数，使模型更适应垂直场景的推理。通常仅需调整少量参数（如使用LoRA技术调整0.1%-1%的参数），显存需求可降低至预训练的10%-20%。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型压缩&lt;/strong&gt;: 模型压缩技术，如量化、剪枝、知识蒸馏等，可以减少模型的参数数量，从而降低显存需求。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;知识蒸馏&lt;/strong&gt;: 将大型复杂模型（教师模型）在有限损失的情况下知识转移到更小型、高效模型（学生模型）中, 这样做的好处包括降低计算成本、减少推理时间，同时保持高性能，适合资源受限环境的部署。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型量化&lt;/strong&gt;: 模型量化是指将模型参数从浮点数转换为整数或低精度数据类型，以减少存储和计算开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- - **模型稀疏**: 也叫剪枝，模型稀疏是指通过删除或减少模型中一些低权重或参数来减少模型的大小和计算量。 --&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;蒸馏提取精华，量化降低细节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实施难点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;硬件门槛&lt;/strong&gt;: OpenAI的GPT-4预训练成本约7800万美元，下一代模型的训练成本可能突破10亿美元，甚至向100亿美元迈进。国内有厂商利用算法优化，达到GPT-4同等性能表现的情况下，使大模型训练成本大幅降低，但也需要近600万美元的成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据要求&lt;/strong&gt;: 需清洗TB级高质量文本，避免噪声干扰。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术复杂度&lt;/strong&gt;: 涉及分布式训练、梯度优化等工程难题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;br&gt;
当下大模型训练成本呈现“头部攀升、尾部下降”的极化现象。技术创新（算法优化、工程协同、开源生态）和国产算力替代为降本提供可能，此模式推荐巨头企业或科研机构用于前沿模型研发（如训练行业专属大模型）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="2-下载社区开放模型-主流选择"&gt;2. 下载社区开放模型（主流选择）&lt;a class="td-heading-self-link" href="#2-%e4%b8%8b%e8%bd%bd%e7%a4%be%e5%8c%ba%e5%bc%80%e6%94%be%e6%a8%a1%e5%9e%8b-%e4%b8%bb%e6%b5%81%e9%80%89%e6%8b%a9" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上一种方法，需要自己训练、微调得到一个LLM模型，现在介绍直接下载使用开放的大模型。&lt;/p&gt;</description></item><item><title>openrpa介绍</title><link>https://xiaoping378.github.io/docs/6-rpa/openrpa-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/6-rpa/openrpa-01/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;openrpa的架构介绍&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="概述"&gt;概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;openrpa项目，提供了&lt;strong&gt;OON&lt;/strong&gt;技术栈（OpenRPA、Openflow、Node-RED）来实现的RPA功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OpenRPA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该组件可以认为是机器人的IDE设计器部分，基于&lt;a href="https://docs.microsoft.com/en-us/dotnet/framework/windows-workflow-foundation/"&gt;MWF&lt;/a&gt;框架实现的，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以图形化拖拽的方式实现基本功能&lt;code&gt;Activity&lt;/code&gt;，如点击邮箱、打开浏览器网址、输入文字、录屏录音、各类监听探测器等等&lt;/li&gt;
&lt;li&gt;多个&lt;code&gt;Activity&lt;/code&gt;可以组合成一个序列，来实现工作流&lt;code&gt;workflow&lt;/code&gt;，串行执行一系列动作&lt;/li&gt;
&lt;li&gt;也可以通过配置作为agent（机器人）运行，负责执行设计好的工作流&lt;/li&gt;
&lt;li&gt;默认远程连接到云端控制端（openflow），可上传同步本地的工作流和接受控制端的调度管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/openrpa-01-2022-02-14-13-54-44.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Openflow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OON技术栈的后台核心部分，可以关编排管理所有的活动，主要具备一下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理，调用和配置机器人和工作流&lt;/li&gt;
&lt;li&gt;管理用户和权限(组)&lt;/li&gt;
&lt;li&gt;创建Web表单，供和真实用户交互，实现工作流的输入，审批和确认等操作。&lt;/li&gt;
&lt;li&gt;管理后端MongoDB存储&lt;/li&gt;
&lt;li&gt;存储工作流、表单等数据信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/openrpa-01-2022-02-15-09-23-27.png" alt="openflow with Monitoring"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Node-RED&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="faq"&gt;FAQ&lt;a class="td-heading-self-link" href="#faq" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;三大组件汇总具有&lt;code&gt;流&lt;/code&gt;的概念，openrpa中叫&lt;code&gt;workflow&lt;/code&gt;，node-red中叫&lt;code&gt;flow&lt;/code&gt;, openflow组件名称自身就带了flow的字样，界面上也有&lt;/p&gt;</description></item><item><title>百宝箱脚本</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/%E7%99%BE%E5%AE%9D%E7%AE%B1%E8%84%9A%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/%E7%99%BE%E5%AE%9D%E7%AE%B1%E8%84%9A%E6%9C%AC/</guid><description>&lt;ul&gt;
&lt;li&gt;备份所有docker镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir -p images &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style="color:#a2f"&gt;cd&lt;/span&gt; images
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;for&lt;/span&gt; image in &lt;span style="color:#b44"&gt;`&lt;/span&gt;docker images | grep -v REPOSITORY | awk &lt;span style="color:#b44"&gt;&amp;#39;{print $1&amp;#34;:&amp;#34;$2}&amp;#39;&lt;/span&gt;&lt;span style="color:#b44"&gt;`&lt;/span&gt;; &lt;span style="color:#a2f;font-weight:bold"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a2f"&gt;echo&lt;/span&gt; &lt;span style="color:#b44"&gt;&amp;#34;saving the image of &lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;image&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; docker save &lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;image&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt; &amp;gt; &lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;image&lt;/span&gt;////-&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt;.tar
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a2f"&gt;echo&lt;/span&gt; -e &lt;span style="color:#b44"&gt;&amp;#34;finished saving the image of \033[32m &lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;image&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt;&lt;span style="color:#b44"&gt; \033[0m&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;批量加载本地tar镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;for&lt;/span&gt; image in &lt;span style="color:#b44"&gt;`&lt;/span&gt;ls *.tar&lt;span style="color:#b44"&gt;`&lt;/span&gt;; &lt;span style="color:#a2f;font-weight:bold"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a2f"&gt;echo&lt;/span&gt; &lt;span style="color:#b44"&gt;&amp;#34;loading the image of &lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;image&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; docker load &amp;lt; &lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;image&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a2f"&gt;echo&lt;/span&gt; -e &lt;span style="color:#b44"&gt;&amp;#34;finished loading the image of \033[32m &lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;image&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt;&lt;span style="color:#b44"&gt; \033[0m&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;批量杀死僵尸进程&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ps -A -o stat,ppid,pid,cmd | grep -e &lt;span style="color:#b44"&gt;&amp;#39;^[Zz]&amp;#39;&lt;/span&gt; | awk &lt;span style="color:#b44"&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt; | xargs &lt;span style="color:#a2f"&gt;kill&lt;/span&gt; -9
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>构建生产环境级的docker Swarm集群-1</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-swarm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-swarm/</guid><description>&lt;p&gt;此文档适用于低于1.12版本的docker，之后swarm已内置于docker-engine里。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬件需求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至少5台PC服务器, 分别如下作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;manager0&lt;/li&gt;
&lt;li&gt;manager1&lt;/li&gt;
&lt;li&gt;consul0&lt;/li&gt;
&lt;li&gt;node0&lt;/li&gt;
&lt;li&gt;node1&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;每台PC上安装docker-engine&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一台一台的ssh上去执行，或者使用ansible批量部署工具。&lt;/p&gt;
&lt;p&gt;安装docker-engine&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;curl -sSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动之，并使之监听2375端口&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;sudo docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;亦可修改配置，使之永久生效&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;mkdir /etc/systemd/system/docker.service.d
cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/systemd/system/docker.service.d/docker.conf
[Service]
 ExecStart=
 ExecStart=/usr/bin/docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --dns 180.76.76.76 --insecure-registry registry.cecf.com -g /home/Docker/docker
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;ol start="3"&gt;
&lt;li&gt;启动discovery后台&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在consul0上启动consul服务，manager用其来认证node连接并存储node状态， 理应建立discovery的高可用，这里简化之&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;docker run -d -p 8500:8500 --name=consul progrium/consul -server -bootstrap
&lt;/code&gt;&lt;/pre&gt;&lt;ol start="4"&gt;
&lt;li&gt;创建Swarm集群&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在manager0上创建the primary manager， 自行替换manager0_ip和consul0_ip的真实IP地址。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;docker run -d -p 4000:4000 swarm manage -H :4000 --replication --advertise &amp;lt;manager0_ip&amp;gt;:4000 consul://&amp;lt;consul0_ip&amp;gt;:8500
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在manager1上启动replica manger&lt;/p&gt;</description></item><item><title>快速安装</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85/</guid><description>&lt;p&gt;不知道为什么openshift在国内热度这么低，那些要做自己容器云的公司，不知道有openshift项目的存在么？完全满足我的需求。&lt;/p&gt;
&lt;p&gt;docker负责应用的隔离打包，k8s提供集群管理和容器的编排服务，而openshfit则负责整个应用的生命周期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码管理，CI&amp;amp;CD能力&lt;/li&gt;
&lt;li&gt;多租户管理, 支持LDAP和Oauth&lt;/li&gt;
&lt;li&gt;集成监控日志于web console&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先说下自接触到openshift项目就遇到的一个困惑，就是openshift origin/enterprise /online/dedicated/ocp之间的关系： &lt;code&gt;orgin相当于Fedora， 其他的相当于RHEL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来谈下我用自己的笔记本实践的过程与感受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本人日常基于ubuntu16.04办公，所以用oc直接上, oc相当于kubectl&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/openshift/origin/releases"&gt;这里&lt;/a&gt;直接下载oc客户端，或者自行编译, 编译结果在_output目录下&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;git clone --depth=1 https://github.com/openshift/origin.git
cd origin &amp;amp;&amp;amp; make
mv _output/local/bin/linux/amd64/oc /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动openshift, 默认开启监控并初始安装自最新版本，当前是v1.5.0-alpha.2&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc cluster up --metrics=true --version=latest --insecure-skip-tls-verify=true --public-hostname=air13
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;过程中会拉取所需镜像, 我这里显示比较多，之前已经做了些实验&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;➜ ~ docker images | grep openshift | awk &amp;#39;{print $1}&amp;#39;
openshift/node
openshift/origin-sti-builder
openshift/origin-docker-builder
openshift/origin-deployer
openshift/origin-gitserver
openshift/origin-docker-registry
openshift/origin-haproxy-router
openshift/origin
openshift/hello-openshift
openshift/openvswitch
openshift/origin-pod
openshift/origin-metrics-cassandra
openshift/origin-metrics-hawkular-metrics
openshift/origin-metrics-heapster
openshift/origin-metrics-deployer
openshift/mysql-55-centos7
openshift/origin-logging-curator
openshift/origin-logging-fluentd
openshift/origin-logging-deployment
openshift/origin-logging-elasticsearch
openshift/origin-logging-kibana
openshift/origin-logging-auth-proxy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动后，会打印如下信息&lt;/p&gt;</description></item><item><title>内网机穿透开发</title><link>https://xiaoping378.github.io/docs/2-infra/network/frp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/2-infra/network/frp/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;充分利用外网开隧道代理到本地服务，演示或者内网开发的利器，自己具备公网服务器的可以使用frp，不具备的可以使用ngrok。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="frp介绍"&gt;FRP介绍&lt;a class="td-heading-self-link" href="#frp%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;frp 是国人开源的一种快速反向代理，可将 NAT 或防火墙后面的本地服务器暴露到互联网上。目前，它支持暴露 TCP 和 UDP，以及 HTTP 和 HTTPS 协议，也可以通过域名将请求转发到内部服务。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/frp-2022-03-06-20-21-49.png" alt=""&gt;&lt;/p&gt;
&lt;h2 id="安装"&gt;安装&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;二进制下载&lt;a href="https://github.com/fatedier/frp/releases"&gt;地址&lt;/a&gt;, 解压后内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ frp_0.39.1_linux_amd64 tree
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frpc
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frpc_full.ini
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frpc.ini
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frps
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frps_full.ini
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frps.ini
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── LICENSE
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── systemd
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ├── frpc.service
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ├── frpc@.service
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ├── frps.service
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; └── frps@.service
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;1&lt;/span&gt; directory, &lt;span style="color:#666"&gt;11&lt;/span&gt; files
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可将其中的 frpc 拷贝到内网服务所在的机器上，将 frps 拷贝到具有公网 IP 的机器上，放置在任意目录。&lt;/p&gt;
&lt;p&gt;后续使用思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写配置文件，先通过 ./frps -c ./frps.ini 启动服务端，&lt;/li&gt;
&lt;li&gt;再通过 ./frpc -c ./frpc.ini 启动客户端。&lt;/li&gt;
&lt;li&gt;如果需要在后台长期运行，可使用压缩包内写好的的systemd服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="代理ssh"&gt;代理ssh&lt;a class="td-heading-self-link" href="#%e4%bb%a3%e7%90%86ssh" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本人日常开发使用vsocde，众所周知，其&lt;a href="https://code.visualstudio.com/docs/remote/ssh"&gt;remote SSH开发&lt;/a&gt;的特性非常惊艳，可以提供本地开发的体验，背后需要通过ssh连接到远端服务器，高配云主机价格不菲，公司电脑长期荒废中，，，，遂有了此想法，只购买一个低配的云主机用来代理到内网的公司电脑（已安装linux）上，然后利用vscode实现内网穿透开发。&lt;/p&gt;</description></item><item><title>源码部署K8S</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2k8s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2k8s/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;此文应该不能运行成功了，，，陈年老文，有待验证。&lt;/p&gt;

&lt;/div&gt;

&lt;h4 id="一-先介绍最省事的部署方法-直接从官网下release版本安装"&gt;一. 先介绍最省事的部署方法，直接从官网下release版本安装:&lt;a class="td-heading-self-link" href="#%e4%b8%80-%e5%85%88%e4%bb%8b%e7%bb%8d%e6%9c%80%e7%9c%81%e4%ba%8b%e7%9a%84%e9%83%a8%e7%bd%b2%e6%96%b9%e6%b3%95-%e7%9b%b4%e6%8e%a5%e4%bb%8e%e5%ae%98%e7%bd%91%e4%b8%8brelease%e7%89%88%e6%9c%ac%e5%ae%89%e8%a3%85" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;git clone 代码步骤省略 ...&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载各依赖的release版本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过修改配置文件 &lt;strong&gt;cluster/centos/config-build.sh&lt;/strong&gt;， 可自定义（k8s, docker, flannel, etcd）各自的下载地址和版本， 不同的版本的依赖可能会需要小改下脚本（版本变更有些打包路径发生了变化，兼容性问题）&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;cd cluster/centos &amp;amp;&amp;amp; ./build.sh all
&lt;/code&gt;&lt;/pre&gt;&lt;ol start="2"&gt;
&lt;li&gt;安装并启动k8s集群环境&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过修改配置文件 &lt;strong&gt;cluster/centos/config-default.sh&lt;/strong&gt;，定义你环境里的设备的IP和其他参数，推荐运行脚本前先通过ssh-copy-id做好免密钥认证；&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;export KUBERNETES_PROVIDER=centos &amp;amp;&amp;amp; cluster/kube-up.sh
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="二-源码级编译安装"&gt;二. 源码级编译安装&lt;a class="td-heading-self-link" href="#%e4%ba%8c-%e6%ba%90%e7%a0%81%e7%ba%a7%e7%bc%96%e8%af%91%e5%ae%89%e8%a3%85" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;本步骤基于上一大步来说,
先来看下载各依赖的release后，cluster/centos下目录发生了什么变化&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/k8s-binaries-tree.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;多了一个binaries的目录，里面是各master和minion上各依赖的二进制文件， 所以我们只要源码编译的结果，替换到这里来， 然后继续上一大步的第2小步即可。&lt;/p&gt;
&lt;p&gt;这里说下，本地编译k8s的话，需要设置安装godep，然后命令本地化。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;export PATH=$PATH:$GOPATH/bin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后只需要去源码根目录下执行， 编译结果在_output目录下&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;make
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;替换到相应的binaries目录下，重新运行kube-up.sh即可。&lt;/p&gt;</description></item><item><title>站点搭建方法</title><link>https://xiaoping378.github.io/docs/1-site/1-create_site/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/1-site/1-create_site/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;主要涉及到hugo和docsy主题的使用。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="hugo工具介绍"&gt;hugo工具介绍&lt;a class="td-heading-self-link" href="#hugo%e5%b7%a5%e5%85%b7%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;hugo是spf13的开源作品，目前任职于google，对他最早的印象是使用他的vim-spf13配置，后来又接触到他的cobra、plfag、viper... 为golang的生态完善做了很大贡献，致敬!&lt;/p&gt;
&lt;p&gt;书归正传，hugo是基于golang开发的世界上最快的网站构建框架，本文介绍如何基于它构建技术类文档库，也可作为内部wiki或开源书籍使用。之所以没选择gitbook，发现CLI版本已于2018年停止维护了。&lt;/p&gt;
&lt;h2 id="准备环境"&gt;准备环境&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%87%e7%8e%af%e5%a2%83" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;安装依赖工具（以下版本为当前202512最新稳定版本）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装git, 下载&lt;a href="https://github.com/git-for-windows/git/releases/download/v2.52.0.windows.1/Git-2.52.0-64-bit.exe"&gt;地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装hugo_extended&lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.152.2/hugo_extended_withdeploy_0.152.2_windows-amd64.zip"&gt;Windows环境&lt;/a&gt;的版本。&lt;/li&gt;
&lt;li&gt;安装Go工具，下载&lt;a href="https://go.dev/dl/go1.24.10.windows-amd64.msi"&gt;地址&lt;/a&gt;, hugo初始化需要go环境&lt;/li&gt;
&lt;li&gt;安装nodejs 22+，下载&lt;a href="https://nodejs.org/dist/v24.11.1/node-v24.11.1-win-x64.zip"&gt;地址&lt;/a&gt;，推荐使用fnm管理node多版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;具体安装过程不表，下篇会介绍如何利用github pages全自动托管静态文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="主题选择"&gt;主题选择&lt;a class="td-heading-self-link" href="#%e4%b8%bb%e9%a2%98%e9%80%89%e6%8b%a9" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;选用&lt;a href="https://www.docsy.dev/xx/docs/get-started/"&gt;Docsy主题&lt;/a&gt;，出自google的开源主题，很多流行项目使用此主题作为官方站点，如k8s、kubeflow、grpc、etcd、Selenium等，详见此。主要功能包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持树形目录&lt;/li&gt;
&lt;li&gt;国际化&lt;/li&gt;
&lt;li&gt;搜索功能&lt;/li&gt;
&lt;li&gt;移动端自适应适配&lt;/li&gt;
&lt;li&gt;标签分类&lt;/li&gt;
&lt;li&gt;全站打印&lt;/li&gt;
&lt;li&gt;文档版本化&lt;/li&gt;
&lt;li&gt;用户反馈等&lt;/li&gt;
&lt;li&gt;uml\mermaid渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;官方提供了快速脚手架，具体操作如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git clone --depth &lt;span style="color:#666"&gt;1&lt;/span&gt; --branch v0.13.0 https://github.com/google/docsy-example.git my-new-site
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;cd&lt;/span&gt; my-new-site
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;npm install --registry https://registry.npmmirror.com
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;hugo server
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;本地启动，默认可通过&lt;code&gt;localhost:1313&lt;/code&gt;访问，官方提供了在线的&lt;a href="https://example.docsy.dev/"&gt;预览地址&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;hugo server
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;/p&gt;
&lt;h2 id="目录结构说明"&gt;目录结构说明&lt;a class="td-heading-self-link" href="#%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84%e8%af%b4%e6%98%8e" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;默认脚手架目录结构如下，只关注&lt;code&gt;hugo.yaml&lt;/code&gt;文件和&lt;code&gt;content&lt;/code&gt;目录，就可以满足日常使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ my-new-site git:&lt;span style="color:#666"&gt;(&lt;/span&gt;v0.13.0&lt;span style="color:#666"&gt;)&lt;/span&gt; ll
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;total 195K
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;drwxr-xr-x &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;0&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 assets &lt;span style="color:#080;font-style:italic"&gt;# 静态资源目录，如CSS、JavaScript等&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;448&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 config.yaml &lt;span style="color:#080;font-style:italic"&gt;# 站点的hugo高版本兼容文件，可删除&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;drwxr-xr-x &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;0&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 content &lt;span style="color:#080;font-style:italic"&gt;# 网站内容目录，包含Markdown格式的文章和页面，以后重点创作的目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; 1.1K 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 CONTRIBUTING.md
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;172&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 docker-compose.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;100&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 Dockerfile
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;173&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 docsy.work
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;0&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 docsy.work.sum
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;89&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 go.mod
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;513&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 go.sum
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; 7.7K 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 hugo.yaml &lt;span style="color:#080;font-style:italic"&gt;#Hugo的主要配置文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; 7.5K 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 hugo-disabled.toml
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;drwxr-xr-x &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;0&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 layouts
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; 12K 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 LICENSE
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;302&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 netlify.toml &lt;span style="color:#080;font-style:italic"&gt;# Netlify部署平台配置文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;drwxr-xr-x &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;0&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:37 node_modules
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; 2.7K 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 package.json
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; 99K 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:37 package-lock.json
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;drwxr-xr-x &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;0&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:37 public
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;-rw-r--r-- &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; 7.3K 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:34 README.md
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;drwxr-xr-x &lt;span style="color:#666"&gt;1&lt;/span&gt; xxp &lt;span style="color:#666"&gt;197609&lt;/span&gt; &lt;span style="color:#666"&gt;0&lt;/span&gt; 11月 &lt;span style="color:#666"&gt;27&lt;/span&gt; 20:35 resources &lt;span style="color:#080;font-style:italic"&gt;# 动态编译的产物&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="重点说明"&gt;重点说明&lt;a class="td-heading-self-link" href="#%e9%87%8d%e7%82%b9%e8%af%b4%e6%98%8e" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改主题的页面布局&lt;/p&gt;</description></item><item><title>搭建以太坊私链网络</title><link>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5/</guid><description>&lt;p&gt;大量过时文章充斥于网络，本文基于官方go-tehereum 1.6.7版本整理而出，在geth1.6之后引入了一个&lt;strong&gt;puppeth&lt;/strong&gt;工具，它就是用来初始一个私链创世块配置的。&lt;/p&gt;
&lt;h3 id="准备工具环境"&gt;准备工具环境&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%87%e5%b7%a5%e5%85%b7%e7%8e%af%e5%a2%83" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;下载&lt;code&gt;go-ethereum代码&lt;/code&gt;（go的开发环境准备，不在此文范围）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 下载源码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;go get github.com/ethereum/go-ethereum
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;cd&lt;/span&gt; &lt;span style="color:#b8860b"&gt;$GOPATH&lt;/span&gt;/src/github.com/ethereum/go-ethereum
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 编译1.6.7版本的代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git checkout -b v1.6.7 v1.6.7
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;make all
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 安装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo ln -s &lt;span style="color:#b8860b"&gt;$PWD&lt;/span&gt;/build/bin/* /usr/local/bin/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 检查是否安装OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;geth version
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Geth
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Version: 1.6.7-stable
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Git Commit: ab5646c532292b51e319f290afccf6a44f874372
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Architecture: amd64
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Protocol Versions: &lt;span style="color:#666"&gt;[&lt;/span&gt;&lt;span style="color:#666"&gt;63&lt;/span&gt; 62&lt;span style="color:#666"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Network Id: &lt;span style="color:#666"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Go Version: go1.8.3
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Operating System: linux
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b8860b"&gt;GOPATH&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;/home/xxp/go
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b8860b"&gt;GOROOT&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;/home/xxp/Software/go
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="生成私链创世块的配置"&gt;生成私链创世块的配置&lt;a class="td-heading-self-link" href="#%e7%94%9f%e6%88%90%e7%a7%81%e9%93%be%e5%88%9b%e4%b8%96%e5%9d%97%e7%9a%84%e9%85%8d%e7%bd%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建账户&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 创建testnet目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ mkdir testnet &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style="color:#a2f"&gt;cd&lt;/span&gt; testnet
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 创建3个普通账户，密码自定&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ geth --datadir node0 account new
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 把密码记录到文件里，后面会频繁输入&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ &lt;span style="color:#a2f"&gt;echo&lt;/span&gt; node0 &amp;gt; node0/password
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ geth --datadir node1 account new
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ &lt;span style="color:#a2f"&gt;echo&lt;/span&gt; node1 &amp;gt; node1/password
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ geth --datadir node2 account new
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ &lt;span style="color:#a2f"&gt;echo&lt;/span&gt; node2 &amp;gt; node2/password
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上打印的一串16进制的字符串就代表账户的userID（理解成网络中的IP地址），后面puppeth需要用到。&lt;/p&gt;</description></item><item><title>监控之我见</title><link>https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/</guid><description>&lt;!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e6%a6%82%e8%bf%b0"&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%9b%91%e6%8e%a7%e7%9b%ae%e6%a0%87"&gt;监控目标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%9b%91%e6%8e%a7%e6%96%b9%e6%b3%95"&gt;监控方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%9b%91%e6%8e%a7%e6%a0%b8%e5%bf%83"&gt;监控核心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%9b%91%e6%8e%a7%e6%b5%81%e7%a8%8b"&gt;监控流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%9b%91%e6%8e%a7%e6%8c%87%e6%a0%87"&gt;监控指标&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%a1%ac%e4%bb%b6%e7%9b%91%e6%8e%a7"&gt;硬件监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%b3%bb%e7%bb%9f%e7%9b%91%e6%8e%a7"&gt;系统监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e5%ba%94%e7%94%a8%e7%9b%91%e6%8e%a7"&gt;应用监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%bd%91%e7%bb%9c%e7%9b%91%e6%8e%a7"&gt;网络监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e6%b5%81%e9%87%8f%e5%88%86%e6%9e%90"&gt;流量分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e6%97%a5%e5%bf%97%e7%9b%91%e6%8e%a7"&gt;日志监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e5%ae%89%e5%85%a8%e7%9b%91%e6%8e%a7"&gt;安全监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#api%e7%9b%91%e6%8e%a7"&gt;API监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e6%80%a7%e8%83%bd%e7%9b%91%e6%8e%a7"&gt;性能监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e4%b8%9a%e5%8a%a1%e7%9b%91%e6%8e%a7"&gt;业务监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e7%9b%91%e6%8e%a7%e6%8a%a5%e8%ad%a6"&gt;监控报警&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e6%8a%a5%e8%ad%a6%e5%a4%84%e7%90%86"&gt;报警处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiaoping378.github.io/docs/3-devops/2-%E7%9B%91%E6%8E%A7%E4%B9%8B%E6%88%91%E8%A7%81/#%e6%80%bb%e7%bb%93"&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;
&lt;h2 id="概述"&gt;概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;监控是整个运维乃至整个产品生命周期中非常重要的一环，可以事前及时预警发现故障，事后提供详实的数据用于追查定位问题。&lt;/p&gt;
&lt;p&gt;目前业界存在各种开源监控产品，如Zabbix，ELK体系，Prometheus等等，各有自身的适用场景，所以选择基于一款开源的的监控系统会是事半功倍的事情。&lt;/p&gt;
&lt;h2 id="监控目标"&gt;监控目标&lt;a class="td-heading-self-link" href="#%e7%9b%91%e6%8e%a7%e7%9b%ae%e6%a0%87" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;站在公司各业务角度考虑，整理如下四点目标：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E7%9B%AE%E6%A0%87.jpeg" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对系统不间断实时监控&lt;/strong&gt;: 实际上是对系统不间断的实时监控(这就是监控)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时反馈系统当前状态&lt;/strong&gt;: 我们监控某个硬件、某个系统，某个进程服务,都是需要能实时看到当前系统的状态，是正常、异常、或者故障&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证服务可靠性安全性&lt;/strong&gt;：我们监控的目的就是要保证系统、服务、业务正常运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证业务持续稳定运行&lt;/strong&gt;：如果我们的监控做得很完善，即使出现故障，能第一时间接收到故障报警，在第一时间处理解决，从而保证业务持续性的稳定运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="监控方法"&gt;监控方法&lt;a class="td-heading-self-link" href="#%e7%9b%91%e6%8e%a7%e6%96%b9%e6%b3%95" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;既然我们了解到了监控的重要性、以及监控的目的，那么下面我们需要了解下监控有哪些方法。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95.jpeg" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;了解监控对象&lt;/strong&gt;：我们要监控的对象你是否了解呢？比如 CPU 到底是如何工作的？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能基准指标&lt;/strong&gt;：我们要监控这个东西的什么属性？比如 CPU 的使用率、负载、用户态、内核态、上下文切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报警阈值定义&lt;/strong&gt;：怎么样才算是故障，要报警呢？比如 CPU 的负载到底多少算高，用户态、内核态分别跑多少算高？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障处理流程&lt;/strong&gt;：收到了故障报警，我们怎么处理呢？有什么更高效的处理流程吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="监控核心"&gt;监控核心&lt;a class="td-heading-self-link" href="#%e7%9b%91%e6%8e%a7%e6%a0%b8%e5%bf%83" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我们了解了监控的方法、监控对象、性能指标、报警阈值定义、以及故障处理流程几步骤，当然我们更需要知道监控的核心是什么？&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/%E7%9B%91%E6%8E%A7%E6%A0%B8%E5%BF%83.png" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发现问题&lt;/strong&gt;：当系统发生故障报警，我们会收到故障报警的信息 ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定位问题&lt;/strong&gt;：故障邮件一般都会写某某主机故障、具体故障的内容，我们需要对报警内容进行分析，比如一台服务器连不上：我们就需要考虑是网络问题、还是负载太高导致长时间无法连接，又或者某开发触发了防火墙禁止的相关策略等等，我们就需要去分析故障具体原因；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决问题&lt;/strong&gt;：当然我们了解到故障的原因后，就需要通过故障解决的优先级去解决该故障；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总结问题&lt;/strong&gt;：当我们解决完重大故障后，需要对故障原因以及防范进行总结归纳，避免以后重复出现；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="监控流程"&gt;监控流程&lt;a class="td-heading-self-link" href="#%e7%9b%91%e6%8e%a7%e6%b5%81%e7%a8%8b" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;基于 Zabbix 来构建整个监控体系生态圈&lt;/p&gt;</description></item><item><title>docker网络</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/docker-network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/docker-network/</guid><description>&lt;p&gt;自去年就开始推动公司业务使用docker了， 至今也一年多了，但对docker网络的认知一直一知半解。。。&lt;/p&gt;
&lt;p&gt;主要是太忙，加上线上业务也没出过关于网络吞吐性能方面的问题，就没太大动力去搞明白， 现在闲下来了，搞之！&lt;/p&gt;
&lt;h3 id="环境声明"&gt;环境声明&lt;a class="td-heading-self-link" href="#%e7%8e%af%e5%a2%83%e5%a3%b0%e6%98%8e" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以下内容只针对OS: Ubuntu16.04 docker: 1.10.3的环境， 写本文时docker最新的release版本是1.11.2，还有什么CoreOS，Unikernel 之类的（表示都没玩过）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;docker更新迭代速度太快了，公司业务只用到基本功能，所以没动力跟进它的更新了
各种新时代下的产物频出啊， CoreOS为linux的发行版， 没需求，好遗憾.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="docker的网络模式"&gt;docker的网络模式&lt;a class="td-heading-self-link" href="#docker%e7%9a%84%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一开始安装完docker， 它就会默认创建3个网络， 使用__docker network ls__查看&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ blog git:&lt;span style="color:#666"&gt;(&lt;/span&gt;master&lt;span style="color:#666"&gt;)&lt;/span&gt; docker network ls
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;NETWORK ID NAME DRIVER
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;46416a43fbc6 bridge bridge 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;45398901e9f0 none null 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;9440a8140e68 host host
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当启动一个容器时， 默认使用bridge模式， 可以通过 --net 指定其它模式。&lt;/p&gt;
&lt;p&gt;下面先简要说明下各自的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bridge 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器间之所以能通信，就靠宿主机上的docker0了， docker0就是bridge模式下默认创建的虚拟设备名称&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ blog git:&lt;span style="color:#666"&gt;(&lt;/span&gt;master&lt;span style="color:#666"&gt;)&lt;/span&gt; ✗ ifconfig docker0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;docker0 Link encap:Ethernet HWaddr 02:42:49:56:7c:3b 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; inet addr:172.17.0.1 Bcast:0.0.0.0 Mask:255.255.0.0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; inet6 addr: fe80::42:49ff:fe56:7c3b/64 Scope:Link
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; RX packets:78103 errors:0 dropped:0 overruns:0 frame:0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; TX packets:47578 errors:0 dropped:0 overruns:0 carrier:0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; collisions:0 txqueuelen:0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; RX bytes:17485434 &lt;span style="color:#666"&gt;(&lt;/span&gt;17.4 MB&lt;span style="color:#666"&gt;)&lt;/span&gt; TX bytes:82163889 &lt;span style="color:#666"&gt;(&lt;/span&gt;82.1 MB&lt;span style="color:#666"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ifocnfig可以看到很多信息， mac地址，IP等这些也可以通过参数指定成别的。&lt;/p&gt;</description></item><item><title>构建生产环境级的docker Swarm集群-2</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-swarm2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-swarm2/</guid><description>&lt;p&gt;此文档适用于不低于1.12版本的docker，因为swarm已内置于docker-engine里。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬件需求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里以5台PC服务器为例, 分别如下作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;manager0&lt;/li&gt;
&lt;li&gt;manager1&lt;/li&gt;
&lt;li&gt;node0&lt;/li&gt;
&lt;li&gt;node1&lt;/li&gt;
&lt;li&gt;node2&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;每台PC上安装docker-engine&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一台一台的ssh上去执行，或者使用ansible批量部署工具。&lt;/p&gt;
&lt;p&gt;安装docker-engine&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;curl -sSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动之，并使之监听2375端口&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;sudo docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;亦可修改配置，使之永久生效&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;mkdir /etc/systemd/system/docker.service.d
cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/systemd/system/docker.service.d/docker.conf
[Service]
 ExecStart=
 ExecStart=/usr/bin/docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --dns 180.76.76.76 --insecure-registry registry.cecf.com -g /home/Docker/docker
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果开启了防火墙，需要开启如下端口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TCP port 2377&lt;/strong&gt; for cluster management communications&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP&lt;/strong&gt; and &lt;strong&gt;UDP port 7946&lt;/strong&gt; for communication among nodes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP&lt;/strong&gt; and &lt;strong&gt;UDP port 4789&lt;/strong&gt; for overlay network traffic&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;创建swarm&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;docker swarm init --advertise-addr &amp;lt;MANAGER-IP&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我的实例里如下：&lt;/p&gt;</description></item><item><title>离线安装kubernetes</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/kuberbetes-1.5-%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/kuberbetes-1.5-%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;虽然距离当前主流版本已经差之千里，但其中的思想仍记得借鉴。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;经常遇到全新初始安装k8s集群的问题，所以想着搞成离线模式，本着最小依赖原则，提高安装速度&lt;/p&gt;
&lt;p&gt;基于Centos7-1511-minimal, 非此版本脚本应该会运行出错，自行修改吧&lt;/p&gt;
&lt;p&gt;本离线安装所有的依赖都打包放到了&lt;a href="https://pan.baidu.com/s/1i5jusip"&gt;百度网盘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了便于维护，已建立独立项目&lt;a href="https://github.com/xiaoping378/k8s-deploy"&gt;k8s-deploy&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="第一步"&gt;第一步&lt;a class="td-heading-self-link" href="#%e7%ac%ac%e4%b8%80%e6%ad%a5" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;基本思路是，在k8s-deploy目录下，临时启个http server， node节点上会从此拉取所依赖镜像和rpms&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;windows上可以用hfs临时启个http server， 自行百度如何使用&lt;/p&gt;
&lt;h2 id="master侧"&gt;master侧&lt;a class="td-heading-self-link" href="#master%e4%be%a7" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;运行以下命令，初始化master&lt;/p&gt;
&lt;p&gt;192.168.56.1:8000 是我的http-server, 注意要将k8s-deploy.sh 里的HTTP-SERVER变量也改下&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;curl -L http://192.168.56.1:8000/k8s-deploy.sh | bash -s master
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="minion侧"&gt;minion侧&lt;a class="td-heading-self-link" href="#minion%e4%be%a7" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;视自己的情况而定&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;curl -L http://192.168.56.1:8000/k8s-deploy.sh | bash -s join --token=6669b1.81f129bc847154f9 192.168.56.100
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="总结"&gt;总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;整个脚本实现比较简单， 坑都在脚本里解决了。脚本文件在&lt;a href="https://gist.github.com/xiaoping378/3a129aa6c81eaecae199a50236ad8bf7"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就一个master-up和node-up， 基本一个函数只做一件事，很清晰，可以自己查看具体过程。&lt;/p&gt;
&lt;p&gt;1.5 与 1.3给我感觉最大的变化是网络部分， 1.5启用了cni网络插件
不需要像以前一样非要把flannel和docker绑在一起了（先启flannel才能启docker）。&lt;/p&gt;
&lt;p&gt;具体可以看这里
&lt;a href="https://github.com/containernetworking/cni/blob/master/Documentation/flannel.md"&gt;https://github.com/containernetworking/cni/blob/master/Documentation/flannel.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;master侧如果是单核的话，会因资源不足， dns安装失败。&lt;/p&gt;</description></item><item><title>权限资源管理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%9D%83%E9%99%90%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%9D%83%E9%99%90%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</guid><description>&lt;p&gt;重点介绍 project，limitRange，resourceQuta和 user, group, rule，role，policy，policybinding的关系,
我刚接触时，这几个概念老搞不太清楚，这里梳理下&lt;/p&gt;
&lt;h2 id="资源管理说明"&gt;资源管理说明&lt;a class="td-heading-self-link" href="#%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e8%af%b4%e6%98%8e" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以对计算资源的大小和对象类型的数量来进行配额限制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ResourceQuota&lt;/code&gt;是面向project（namespace的基础上加了些注解）层面的，只有集群管理员可以基于namespace设置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;limtRange&lt;/code&gt;是面向pod和container级别的，openshift额外还可以限制 image， imageStream和pvc，
也是只有集群管理员才可以基于project设置，而开发人员只能基于pod（container）设置cpu和内存的requests/limits。&lt;/p&gt;
&lt;h3 id="resourcequota"&gt;ResourceQuota&lt;a class="td-heading-self-link" href="#resourcequota" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;看看具体可以管理哪些资源，期待网络相关的也加进来.简单来讲，可以基于project来限制可消耗的内存大小和可创建的pods数量&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// The following identify resource constants for Kubernetes object types&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;const&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;(&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Pods, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourcePods&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Services, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceServices&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;services&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ReplicationControllers, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceReplicationControllers&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;replicationcontrollers&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceQuotas, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceQuotas&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;resourcequotas&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceSecrets, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceSecrets&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;secrets&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceConfigMaps, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceConfigMaps&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;configmaps&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourcePersistentVolumeClaims, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourcePersistentVolumeClaims&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;persistentvolumeclaims&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceServicesNodePorts, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceServicesNodePorts&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;services.nodeports&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceServicesLoadBalancers, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceServicesLoadBalancers&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;services.loadbalancers&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// CPU request, in cores. (500m = .5 cores)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceRequestsCPU&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;requests.cpu&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Memory request, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceRequestsMemory&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;requests.memory&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Storage request, in bytes&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceRequestsStorage&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;requests.storage&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// CPU limit, in cores. (500m = .5 cores)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceLimitsCPU&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;limits.cpu&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Memory limit, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceLimitsMemory&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;limits.memory&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;)&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;openshift额外支持的images相关的限制策略&lt;/p&gt;</description></item><item><title>网络TCP/IP协议栈</title><link>https://xiaoping378.github.io/docs/2-infra/network/tcpip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/2-infra/network/tcpip/</guid><description>&lt;p&gt;.TODO&lt;/p&gt;</description></item><item><title>自动托管markdown</title><link>https://xiaoping378.github.io/docs/1-site/2-actions_pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/1-site/2-actions_pages/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;利用github actions和pages实现自动更新托管内容，本站点已实现commit md后，&lt;del&gt;自动更新&lt;a href="https://xiaoping378.gitee.io/"&gt;码云page&lt;/a&gt;和&lt;/del&gt;&lt;a href="https://xiaoping378.github.io/"&gt;Github page&lt;/a&gt;页面。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="本站点仓库名字的由来"&gt;本站点仓库名字的由来&lt;a class="td-heading-self-link" href="#%e6%9c%ac%e7%ab%99%e7%82%b9%e4%bb%93%e5%ba%93%e5%90%8d%e5%ad%97%e7%9a%84%e7%94%b1%e6%9d%a5" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本源码仓之所以起如此长的名字，完全是因为github pages的工作机制决定的，不然会带个小尾巴：&lt;/p&gt;
&lt;p&gt;如果叫 &lt;em&gt;blog&lt;/em&gt;, github的托管页面的访问地址会是 &lt;em&gt;xiaoping378.github.io/blog&lt;/em&gt;，这也没什么，但会和hugo的&lt;a href="https://xiaoping378.github.io/docs/1-site/add_content/#%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"&gt;static机制&lt;/a&gt;出现冲突。&lt;/p&gt;
&lt;p&gt;当然可以自行购买域名，并指向该pages地址，，，后来忘了续费，搞丢了我的域名。&lt;/p&gt;
&lt;h2 id="什么是pages"&gt;什么是pages&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%afpages" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;GitHub Pages 是 GitHub 提供的一项免费静态网站托管服务。简单来说，它能将你的代码仓库直接变成一个可访问的网站，无需自己购买服务器、配置环境，甚至连域名都可以使用 GitHub 提供的免费子域名。&lt;/p&gt;
&lt;h2 id="快速入门三步走"&gt;快速入门三步走&lt;a class="td-heading-self-link" href="#%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%e4%b8%89%e6%ad%a5%e8%b5%b0" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一步：创建仓库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;个人/组织网站：创建名为 你的GitHub用户名.github.io 的仓库（例如：xiaoping378.github.io）&lt;/li&gt;
&lt;li&gt;项目网站：在任何项目仓库中启用 Pages 功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步：添加内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接上传 HTML、CSS、JS 文件&lt;/li&gt;
&lt;li&gt;或使用静态网站生成器（如 Hugo、Jekyll、VuePress 等）生成静态文件&lt;/li&gt;
&lt;li&gt;配置 GitHub Pages 源（通常为 main 分支的 /root 或 /docs 文件夹）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三步：访问你的网站&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;个人站点：https://你的GitHub用户名.github.io&lt;/li&gt;
&lt;li&gt;项目站点：https://你的GitHub用户名.github.io/项目名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与静态网站生成器的完美结合. 正如我们上一篇提到的 Hugo + Docsy 方案，GitHub Pages 与静态网站生成器是绝佳搭档。你只需：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地使用 Hugo 预览编写内容&lt;/li&gt;
&lt;li&gt;配置 GitHub Actions 自动构建&lt;/li&gt;
&lt;li&gt;推送到 GitHub 后，Actions 会自动将生成的静态文件部署到 Pages&lt;/li&gt;
&lt;li&gt;几十秒后，更新就会上线！
这种方式让你专注于内容创作，而不用操心服务器维护和部署流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="自动化工作流"&gt;自动化工作流&lt;a class="td-heading-self-link" href="#%e8%87%aa%e5%8a%a8%e5%8c%96%e5%b7%a5%e4%bd%9c%e6%b5%81" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上节是介绍了pages的快速入门，下面介绍自动化工作流，利用github actions实现自动更新托管内容。&lt;/p&gt;</description></item><item><title>以太坊的truffle box开发实战</title><link>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-truffle-box%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A-truffle-box%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</guid><description>&lt;p&gt;整个过程主要演示chrome扩展 METAMASK， OpenZepplin库和truffle框架的使用。&lt;/p&gt;
&lt;h3 id="搭建私连网络"&gt;搭建私连网络&lt;a class="td-heading-self-link" href="#%e6%90%ad%e5%bb%ba%e7%a7%81%e8%bf%9e%e7%bd%91%e7%bb%9c" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;主要参考之前的&lt;a href="../%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5"&gt;以太坊-私有链搭建初步实践&lt;/a&gt;， 这里只用单节点的网络。&lt;/p&gt;
&lt;p&gt;还是先准备账户：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir node0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 会在node0/keystore目录里生成一个keyfile json文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;geth --datadir node0 account new
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;#利用puppeth生成genesis.json的过程不表，参考上边的链接&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;geth --datadir node0 init genesis.json
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 把刚才的账号的密码写入node0/password文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 启动私链，顺便开启console&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;echo&lt;/span&gt; node0 &amp;gt; node0/password
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;geth --datadir node0 --port &lt;span style="color:#666"&gt;30000&lt;/span&gt; --nodiscover --unlock &lt;span style="color:#b44"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; --password ./node0/password --mine --rpc --rpccorsdomain &lt;span style="color:#b44"&gt;&amp;#34;*&amp;#34;&lt;/span&gt; --rpcapi &lt;span style="color:#b44"&gt;&amp;#34;eth,net,web3,admin,personal&amp;#34;&lt;/span&gt; console
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们把这个账号的json文件导入到chorme插件metamask里，便于后面调试和演示&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/ethereum-new-account.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;ubuntu系统上的chrome插件会有窗口消失的bug，在URL栏里打开&lt;code&gt;chrome-extension://nkbihfbeogaeaoehlefnkodbefgpgknn/popup.html&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="truflle初始化项目"&gt;truflle初始化项目&lt;a class="td-heading-self-link" href="#truflle%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%b9%e7%9b%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;需要下载truffle命令号&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;npm install -g truffle
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir token &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style="color:#a2f"&gt;cd&lt;/span&gt; token
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 利用trulle下载token代笔示例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;truffle unbox tutorialtoken
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;npm intall zeppelin-solidity
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上必要的依赖框架和库已经下载到了本地， 接下来就创建自己的代币合约&lt;/p&gt;</description></item><item><title>Github开源项目的正确贡献姿势</title><link>https://xiaoping378.github.io/docs/3-devops/3-github-dev/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/3-github-dev/</guid><description>&lt;p&gt;常见的开源项目贡献指导里都是差不多的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 要先fork
* 然后change something
* 再然后fetch，rebase
* push origin， 最后发起pull request
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体到不同的项目，可能会要求更多的细节步骤,但大体如上。&lt;/p&gt;
&lt;p&gt;这些都没错，但实际操作起来，和习惯不符。因为我一般是先clone一个项目，然后使用中发现有问题，会尝试去修改，fix OK的话，才会想着去贡献代码
可事情到了这一步，再按照一开始的方式操作，会平白无辜耗费很多时间，还涉及到已经修改完代码如何同步过去的问题。
以下是我个人总结的一套方法，屡试不爽乎。&lt;/p&gt;
&lt;p&gt;这里我以k8s项目的贡献经历来举例，以备不时之需。git这个东西，不常用，会忘记的，即使你已经理解原理了。。。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先clone K8s的项目代码。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;git clone https://github.com/kubernetes/kubernetes.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后自行编译 &lt;strong&gt;make&lt;/strong&gt;, 使用中发现一些问题&lt;/p&gt;
&lt;p&gt;就会去github的issue里找找看。。。竟然没人提这个问题，问问同事或同行，人家表示没碰到过你的问题，
好吧，自己尝试去修改... 不断编译 ... 测试... 最终OK了，我要贡献代码！！！
完啦，没有按照最佳习惯来，改动前忘记新建分支了。。。（这个习惯很重要，可以省掉很多麻烦）
只能如此操作了，可以来个大挪移到新建分支上&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;git stash
git checkout -b fix_something
git stash apply
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时去github上fork下原项目，拿到fork后的项目地址，再来个偷天换日。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;git remote rename origin upstream
git remote add origin git@github.com:xiaoping378/kubernetes.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再然后就可以按一开始介绍的，fetch, rebase, push origin, 发起PR了。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;git fetch upstream
git rebase upstream/master
# 有冲突就git mergetool
git push origin fix_something 
# 然后去github页面发起pull request即可。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意事项
值的注意的是，以后在master分支上&lt;strong&gt;git pull&lt;/strong&gt;，就是从upstream/master那里拉取的，和一般情况不一样的地方。
这样会少了烦人的merge msg（-ff可以解决）， 还可以用简单的pull来同步上游代码。
更可以意淫自己是原项目的核心开发人员了。。。
以后本地同步fork的项目到上游的最新状态，这样操作：&lt;/p&gt;</description></item><item><title>k8s的各组件和特性扫盲</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/k8s%E5%90%84%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%A4%E7%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/k8s%E5%90%84%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%A4%E7%9F%A5/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;了解一个工具的特性可以从它的参数入手&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="api-server"&gt;api-server&lt;a class="td-heading-self-link" href="#api-server" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在k8s内发挥的网关和api&lt;/p&gt;
&lt;p&gt;CSR特性&lt;/p&gt;
&lt;h2 id="网络"&gt;网络&lt;a class="td-heading-self-link" href="#%e7%bd%91%e7%bb%9c" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="flannel"&gt;flannel&lt;a class="td-heading-self-link" href="#flannel" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;flannel的设计就是为集群中所有节点能重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，
并让属于不同节点上的容器能够直接通过内网IP通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际上就是给每个节点的docker重新设置容器上可分配的IP段， &lt;code&gt;--bip&lt;/code&gt;的妙用。
这恰好迎合了k8s的设计，即一个pod（container）在集群中拥有唯一、可路由到的IP，带来的好处就是减少跨主机容器间通信要port mapping的复杂性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flannle需要运行一个叫flanned的agent，其用etcd来存储网络配置、已经分配的子网、和辅助信息（主机IP),如下&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;root@master1 ~&lt;span style="color:#666"&gt;]&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;# etcdctl ls /coreos.com/network&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;/coreos.com/network/config
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;/coreos.com/network/subnets
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;root@master1 ~&lt;span style="color:#666"&gt;]&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;root@master1 ~&lt;span style="color:#666"&gt;]&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;# etcdctl get /coreos.com/network/config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;{&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;Network&amp;#34;&lt;/span&gt;:&lt;span style="color:#b44"&gt;&amp;#34;172.16.0.0/16&amp;#34;&lt;/span&gt;&lt;span style="color:#666"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;root@master1 ~&lt;span style="color:#666"&gt;]&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;root@master1 ~&lt;span style="color:#666"&gt;]&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;# etcdctl ls /coreos.com/network/subnets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;/coreos.com/network/subnets/172.16.29.0-24
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;/coreos.com/network/subnets/172.16.40.0-24
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;/coreos.com/network/subnets/172.16.60.0-24
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;root@master1 ~&lt;span style="color:#666"&gt;]&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;root@master1 ~&lt;span style="color:#666"&gt;]&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;# etcdctl get /coreos.com/network/subnets/172.16.29.0-24&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;{&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;PublicIP&amp;#34;&lt;/span&gt;:&lt;span style="color:#b44"&gt;&amp;#34;192.168.1.129&amp;#34;&lt;/span&gt;&lt;span style="color:#666"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;flannel0 还负责解封装报文,或者创建路由。
flannel有多种方式可以完成报文的转发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;li&gt;vxlan&lt;/li&gt;
&lt;li&gt;host-gw&lt;/li&gt;
&lt;li&gt;aws-vpc&lt;/li&gt;
&lt;li&gt;gce&lt;/li&gt;
&lt;li&gt;alloc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是经典的UDP封装方式数据流图
&lt;img src="https://xiaoping378.github.io/flannel-packet-01.png" alt="UDP"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>编写文章技巧</title><link>https://xiaoping378.github.io/docs/1-site/3-add_content/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/1-site/3-add_content/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;本章节主要描述日常编写文章的注意事项和docsy主题内的使用技巧。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="编写markdown"&gt;编写markdown&lt;a class="td-heading-self-link" href="#%e7%bc%96%e5%86%99markdown" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="图片路径问题"&gt;图片路径问题&lt;a class="td-heading-self-link" href="#%e5%9b%be%e7%89%87%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;习惯md文件中的图片路径写成&lt;code&gt;![](/images/file.png)&lt;/code&gt; ，但hugo中图片实际要存放到&lt;code&gt;/static/images/&lt;/code&gt;路径下，hugo会自动渲染到站点的根路径&lt;code&gt;/&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;这样的话，无法在编辑器中预览md了，有两种玩法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用一个临时目录，把图片和md文件放到同一目录，编写完毕后，再把图片和md文件放置上述合适的目录位置上。&lt;/li&gt;
&lt;li&gt;日常一直启用&lt;code&gt;hugo server&lt;/code&gt;编写文章，放弃编辑器中预览md（后面还会有别的坑....）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐后者，额外配合扩展插件，本人日常使用VSCode编写md，和代码开发同款，这里推荐安装&lt;code&gt;mushan.vscode-paste-image&lt;/code&gt;扩展，再额外如下配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;pasteImage.namePrefix&amp;#34;&lt;/span&gt;&lt;span style=""&gt;:&lt;/span&gt; &lt;span style="color:#b44"&gt;&amp;#34;${currentFileNameWithoutExt}-&amp;#34;&lt;/span&gt;&lt;span style=""&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;pasteImage.path&amp;#34;&lt;/span&gt;&lt;span style=""&gt;:&lt;/span&gt; &lt;span style="color:#b44"&gt;&amp;#34;${projectRoot}/static/images/&amp;#34;&lt;/span&gt;&lt;span style=""&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;pasteImage.basePath&amp;#34;&lt;/span&gt;&lt;span style=""&gt;:&lt;/span&gt; &lt;span style="color:#b44"&gt;&amp;#34;${projectRoot}&amp;#34;&lt;/span&gt;&lt;span style=""&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;pasteImage.insertPattern&amp;#34;&lt;/span&gt;&lt;span style=""&gt;:&lt;/span&gt; &lt;span style="color:#b44"&gt;&amp;#34;${imageSyntaxPrefix}/images/${imageFileName}${imageSyntaxSuffix}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;日常编写文章，&lt;code&gt;Alt+A&lt;/code&gt;截图，&lt;code&gt;Ctrl+Alt+A&lt;/code&gt;粘贴到md文件，和在hugo中预览，完美...&lt;/p&gt;
&lt;h3 id="seo优化关注点"&gt;SEO优化关注点&lt;a class="td-heading-self-link" href="#seo%e4%bc%98%e5%8c%96%e5%85%b3%e6%b3%a8%e7%82%b9" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;日常文章编写，如下部分要精准描述，Google搜索引擎推荐使用&lt;code&gt;description&lt;/code&gt;的meta标签告诉它页面内容的，Docsy主题会自动把红框部分填充到&lt;code&gt;layouts/partials/head.html&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/add_content-2022-01-25-09-38-48.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;hugo解析编译后，html页面会如下呈现：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/add_content-2022-01-25-09-37-12.png" alt=""&gt;&lt;/p&gt;
&lt;h3 id="文档日常编写注意事项"&gt;&lt;code&gt;文档&lt;/code&gt;日常编写注意事项&lt;a class="td-heading-self-link" href="#%e6%96%87%e6%a1%a3%e6%97%a5%e5%b8%b8%e7%bc%96%e5%86%99%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="md文件中相互引用内容的路径要记得对应到站点html的路径上"&gt;md文件中相互引用内容的路径要记得对应到站点html的路径上&lt;a class="td-heading-self-link" href="#md%e6%96%87%e4%bb%b6%e4%b8%ad%e7%9b%b8%e4%ba%92%e5%bc%95%e7%94%a8%e5%86%85%e5%ae%b9%e7%9a%84%e8%b7%af%e5%be%84%e8%a6%81%e8%ae%b0%e5%be%97%e5%af%b9%e5%ba%94%e5%88%b0%e7%ab%99%e7%82%b9html%e7%9a%84%e8%b7%af%e5%be%84%e4%b8%8a" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;比如此处引用&lt;code&gt;自动托管markdown&lt;/code&gt;文章，按照md习惯写,虽然编辑器上可以正常打开，但hugo渲染后的页面是404的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[引用](./actions_pages.md)&lt;/code&gt; 需要改成 &lt;code&gt;[引用](../actions_pages)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[引用](/content/docs/1-site/actions_pages.md)&lt;/code&gt; 需要改成 &lt;code&gt;[引用](/docs/1-site/actions_pages)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不定时更新注意事项。日常编写，建议本机启用&lt;code&gt;hugo server&lt;/code&gt;实时预览，&lt;/p&gt;
&lt;h4 id="文章weight的使用"&gt;文章weight的使用&lt;a class="td-heading-self-link" href="#%e6%96%87%e7%ab%a0weight%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;文章开头的&lt;code&gt;weight&lt;/code&gt;部分决定了目录中的排序，推荐新开的系列文章，从两位数开始递增，比如&lt;code&gt;30&lt;/code&gt;, 以后老系列有更新的时候，免去批量修改调整排序的麻烦。&lt;/p&gt;
&lt;h3 id="blog编写注意事项"&gt;&lt;code&gt;blog&lt;/code&gt;编写注意事项&lt;a class="td-heading-self-link" href="#blog%e7%bc%96%e5%86%99%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;blog&lt;/code&gt;的目录结构，&lt;code&gt;blog&lt;/code&gt;目录下，每篇博客推荐在一个独立目录下，都是以&lt;code&gt;index.md&lt;/code&gt;为入口文件&lt;/li&gt;
&lt;li&gt;也可以以单md文件呈现，但不支持嵌入图片&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>从docker迁移到containerd</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/containerd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/containerd/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;记录个人从docker迁移到containerd的事项&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="介绍"&gt;介绍&lt;a class="td-heading-self-link" href="#%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/containerd/containerd"&gt;https://github.com/containerd/containerd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;TODO.&lt;/p&gt;
&lt;h2 id="安装containerd"&gt;安装containerd&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85containerd" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;下载必要组件：https://github.com/containerd/nerdctl/releases，&lt;/p&gt;</description></item><item><title>构建生产环境级的docker Swarm集群-3</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-sarm3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/swarm/docker-sarm3/</guid><description>&lt;p&gt;如前文所述，默认已经搭建好环境，基于docker1.12版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;root@manager0 ~&lt;span style="color:#666"&gt;]&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;# docker node ls&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;0bbmd3r7aphs374qaea4zcieo node2 Ready Active
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;3qmxzyauc0bz4kjqvld9uogz5 manager1 Ready Active Reachable
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;5ewbdtvaopj4ltwqx0a4i65nt * manager0 Ready Drain Leader
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;5oxxpgk69fnwe5w210kovrqi9 node1 Ready Active
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;7s1ilay2wkjgt09bp2z0743m7 node0 Ready Active
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;创建第一个服务，以redis为例
swarm里容器间通信需要使用overlay模式，所以需要提前建立一个&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;docker network create -d overlay --subnet 10.254.0.0/16 --gateway 10.254.0.1 mynet1
docker service create --name redis --network mynet1 redis
&lt;/code&gt;&lt;/pre&gt;&lt;ol start="2"&gt;
&lt;li&gt;在manager上查看服务部署情况&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;[root@manager0 ~]# docker service ps redis
ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR
9avksjfqr2gxm413dfrezrmgr redis.1 redis node1 Running Running 17 seconds ago
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实例里，同样可以去node1上用&lt;code&gt;docker ps&lt;/code&gt;查看&lt;/p&gt;</description></item><item><title>混合云网络SDN</title><link>https://xiaoping378.github.io/docs/2-infra/network/%E6%B7%B7%E5%90%88%E4%BA%91sdn%E9%80%89%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/2-infra/network/%E6%B7%B7%E5%90%88%E4%BA%91sdn%E9%80%89%E5%9E%8B/</guid><description>&lt;ul&gt;
&lt;li&gt;TODO.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="为什么需要sdn"&gt;为什么需要SDN&lt;a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81sdn" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网络可编程&lt;/li&gt;
&lt;li&gt;VPC（Virtual Private Cloud）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="现有sdn方案"&gt;现有SDN方案&lt;a class="td-heading-self-link" href="#%e7%8e%b0%e6%9c%89sdn%e6%96%b9%e6%a1%88" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;硬件方案（软件定义，硬件实现）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主流网络设备厂商有各自实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件方案（NFV）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VMWare NSX, Juniper OpenContrail, OpenStack DVR...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="业务需求"&gt;业务需求&lt;a class="td-heading-self-link" href="#%e4%b8%9a%e5%8a%a1%e9%9c%80%e6%b1%82" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户网络隔离 - 多租户&lt;/li&gt;
&lt;li&gt;保证中等流量规模的高性能低延迟&lt;/li&gt;
&lt;li&gt;适应复杂异构的基础架构（混合云-- kubernetes，虚机，裸机）&lt;/li&gt;
&lt;li&gt;端点迁移，IP不变&lt;/li&gt;
&lt;li&gt;负载均衡（L2/L3）&lt;/li&gt;
&lt;li&gt;端到端流量精细ACL&lt;/li&gt;
&lt;li&gt;可API控制&lt;/li&gt;
&lt;li&gt;运维监控（包，字节流）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="方案选型"&gt;方案选型&lt;a class="td-heading-self-link" href="#%e6%96%b9%e6%a1%88%e9%80%89%e5%9e%8b" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;成本&lt;/li&gt;
&lt;li&gt;设备依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="开源方案"&gt;开源方案&lt;a class="td-heading-self-link" href="#%e5%bc%80%e6%ba%90%e6%96%b9%e6%a1%88" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;各开源SDN方案对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;flannel vxlan:
不具备网络隔离功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenShift SDN:&lt;/p&gt;
&lt;p&gt;基于vxlan利用ovs-multienant可实现基于项目的网络隔离，和flannel vxlan相比，其使用的ovs-subnet插件，数据流场景大体一致，容器向外网发包也使用的NAT。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Calico:&lt;/p&gt;
&lt;p&gt;支持混合云，安全加密，
纯3层的路由实现保证了性能和低延迟
支持了网络隔离和ACL
但存在目前只支持TCP、UDP、ICMP、ICMPv6协议，四层协议不支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenStack Neutron&lt;/p&gt;
&lt;p&gt;支持网络隔离
性能和低延迟 -- 需要优化
支持多租户
基于ML2支持混合云方案 -- kubernetes的支持需要第三方的kubestack项目
虚机迁移，IP可不变，容器迁移，IP不变 -- 需要开发
支持负载均衡LBaaS
支持精细级的ACL
API ?
可运维监控基本数据&lt;/p&gt;</description></item><item><title>项目开发实战</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</guid><description>&lt;p&gt;下面的所有操作，都可以通过cli，web console，RestFul API实现，默认使用cli说明&lt;/p&gt;
&lt;h3 id="创建项目"&gt;创建项目&lt;a class="td-heading-self-link" href="#%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里是接着oc cluster up后，来说的， 默认&lt;code&gt;oc whoami&lt;/code&gt;是 developer,拥有admin的Role角色，俗称项目经理（管理员）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除默认创建的项目，并创建一个实际中的项目&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;oc delete project myproject
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;oc new-project eshop --display-name&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;电商项目&amp;#34;&lt;/span&gt; --description&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;一个神奇的网站&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在项目管理员可以创建任意多个项目，从前面的源码可以看到目前是没法针对项目管理员去限制可创建项目上限的。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;查看项目状态&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;#oc status
In project 电商项目 (eshop) on server https://192.168.31.49:8443

You have no services, deployment configs, or build configs.
Run &amp;#39;oc new-app&amp;#39; to create an application.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空空如也，有提示语句提示可通过&lt;code&gt;oc new-app&lt;/code&gt;去创建具体应用的&lt;/p&gt;
&lt;h3 id="创建应用"&gt;创建应用&lt;a class="td-heading-self-link" href="#%e5%88%9b%e5%bb%ba%e5%ba%94%e7%94%a8" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前面也说过，openshift的核心就是围绕应用的整个生命周期来的，所以从new-app说起&lt;/p&gt;
&lt;p&gt;new-app的入口是&lt;code&gt;NewCmdNewApplication()&lt;/code&gt;, 大部分实现是 &lt;code&gt;func (c *AppConfig) Run() (*AppResult, error)&lt;/code&gt; 感兴趣的可以根据源码来理解openshift的devops理念。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建应用的方式
现在可以通过3种方式（源码， docker镜像， 模板）来创建一个应用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# oc new-app -h
#此处省略。。。
Usage:
 oc new-app (IMAGE | IMAGESTREAM | TEMPLATE | PATH | URL ...) [options]
#此处省略。。。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有很多灵活简便的方式来创建应用，甚至可以直接&lt;code&gt;oc new-app mysql&lt;/code&gt;来创建一个mysql服务&lt;/p&gt;</description></item><item><title>fomo3d-上线部署要点</title><link>https://xiaoping378.github.io/docs/5-blockchain/fomo3d-%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2%E8%A6%81%E7%82%B9/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/fomo3d-%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2%E8%A6%81%E7%82%B9/</guid><description>&lt;p&gt;fomo3d游戏一出，国内疯狂clone上线，这里谈下我上线的思路和部署方法（纯手动的^_^，落伍了）&lt;/p&gt;
&lt;p&gt;通过&lt;a href="https://etherscan.io/address/0xa62142888aba8370742be823c1782d17a0389da1#code"&gt;原版合约地址&lt;/a&gt;，可以一层一层的拔下所有涉及到的合约代码。&lt;/p&gt;
&lt;p&gt;目前据我统计共有8个合约，其中有两个闭源合约：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;F3DexternalSettingsInterface&lt;/li&gt;
&lt;li&gt;JIincInterfaceForForwarder&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;闭源合约不可怕，看明白什么功能，自己hack掉是不影响游戏本身的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;提前预警，合约的内容细节还是要自己研究的，没时间写太细，
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实这个游戏本身只需要2个合约就可以跑起来，且没实质影响，只是单纯改变了部分利益分配方式。&lt;/p&gt;
&lt;p&gt;下面说明，我尽可能少改动原版的情况下，部署上线合约，移除p3d修改后的原版合约代码&lt;a href="https://github.com/ChungkueiBlock/fomo3d/tree/master/sols"&gt;在这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="部署前的准备"&gt;部署前的准备&lt;a class="td-heading-self-link" href="#%e9%83%a8%e7%bd%b2%e5%89%8d%e7%9a%84%e5%87%86%e5%a4%87" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我一般使用&lt;a href="https://remix.ethereum.org/#optimize=true&amp;amp;version=soljson-v0.4.24"&gt;在线remix&lt;/a&gt;工具部署合约在自己的私链上调试，私链建议如下启动（一键解万忧的方式，推荐创世块采用&lt;a href="https://github.com/ChungkueiBlock/tools/tree/master/privateEth"&gt;POA共识&lt;/a&gt;-不消耗CPU），这样可以使用remix的debug功能&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;geth \
 --datadir ./node0\
 --ws\
 --wsaddr 0.0.0.0\
 --wsapi &amp;#34;eth,net,web3,admin,personal,txpool,miner,clique,debug&amp;#34;\
 --wsport 8546\
 --wsorigins &amp;#34;*&amp;#34;\
 --rpc\
 --rpcapi &amp;#34;eth,net,web3,admin,personal,txpool,miner,clique,debug&amp;#34;\
 --rpccorsdomain &amp;#34;*&amp;#34;\
 --rpcaddr 0.0.0.0\
 --rpcport 8545\
 --rpcvhosts &amp;#34;*&amp;#34;\
 --mine\
 --etherbase 0xdbeb69c655b666b3e17b8061df7ea4cc2399df11\
 --unlock 0xdbeb69c655b666b3e17b8061df7ea4cc2399df11\
 --password ./password\
 --nodiscover\
 --maxpeers &amp;#39;50&amp;#39;\
 --networkid 378\
 --targetgaslimit 471238800\
 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="部署合约"&gt;部署合约&lt;a class="td-heading-self-link" href="#%e9%83%a8%e7%bd%b2%e5%90%88%e7%ba%a6" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;按先后顺序如下部署&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/ChungkueiBlock/sols/blob/master/fomo3d/Hourglass.sol"&gt;p3d合约&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;真心不推荐部署带有p3d合约的游戏，这样项目方就可以吃掉本来要流到这里25%左右的流水资金了&lt;/p&gt;
&lt;p&gt;我对p3d的合约内容还没有很深的研究，只知道它&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一个自带“交易所”、发行总量为0的Token，&lt;/li&gt;
&lt;li&gt;通过Eth买入会自动增发，卖出会销毁&lt;/li&gt;
&lt;li&gt;买入和卖出都会扣掉10%的费用给仍持有Token的人&lt;/li&gt;
&lt;li&gt;每买一次都会使Token升值&lt;/li&gt;
&lt;li&gt;每卖一次会使Token降价&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个合约不需要改动，贴源码，编译后部署截图如下，点击红色记录下来部署后的合约地址&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/p3d%E9%83%A8%E7%BD%B2.jpg" alt="p3d"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署divies合约&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个合约专门往p3d持有者发分红的。&lt;/p&gt;
&lt;p&gt;把刚才记录的p3d合约地址，替换到&lt;code&gt;HourglassInterface&lt;/code&gt;后面的地址。如上贴源码，编译后部署&lt;code&gt;Divies&lt;/code&gt;合约，&lt;/p&gt;
&lt;p&gt;记录下divies的地址，并替换fomo3dlong.sol里的&lt;code&gt;DiviesInterface&lt;/code&gt;地址&lt;/p&gt;</description></item><item><title>该主题的Markdown特色语法</title><link>https://xiaoping378.github.io/docs/1-site/4-tutorial2/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/1-site/4-tutorial2/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;这是一个占位页面。请用您自己的内容替换它。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;文本可以是 &lt;strong&gt;粗体&lt;/strong&gt;、&lt;em&gt;斜体&lt;/em&gt; 或 &lt;del&gt;删除线&lt;/del&gt;。&lt;a href="https://gohugo.io"&gt;链接&lt;/a&gt; 应该是蓝色的，没有下划线（除非鼠标悬停在其上）。&lt;/p&gt;
&lt;p&gt;段落之间应该有空白。Vape migas chillwave sriracha poutine try-hard distillery。Tattooed shabby chic small batch, pabst art party heirloom letterpress air plant pop-up。Sustainable chia skateboard art party banjo cardigan normcore affogato vexillologist quinoa meggings man bun master cleanse shoreditch readymade。Yuccie prism four dollar toast tbh cardigan iPhone, tumblr listicle live-edge VHS。Pug lyft normcore hot chicken biodiesel, actually keffiyeh thundercats photo booth pour-over twee fam food truck microdosing banh mi。Vice activated charcoal raclette unicorn live-edge post-ironic。Heirloom vexillologist coloring book, beard deep v letterpress echo park humblebrag tilde。&lt;/p&gt;</description></item><item><title>Golang开发-glog日志库</title><link>https://xiaoping378.github.io/docs/3-devops/4-golang%E5%BC%80%E5%8F%91-%E6%97%A5%E5%BF%97%E7%AF%87/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/4-golang%E5%BC%80%E5%8F%91-%E6%97%A5%E5%BF%97%E7%AF%87/</guid><description>&lt;p&gt;基于Golang 1.7.5版本&lt;/p&gt;
&lt;p&gt;软件项目里的日志输出是很重要的环节，可以用于日后BI分析，或者线上调试（万能调试大法printf）等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于当年刚入软件行业时，自己的printf(&amp;quot;11111\n&amp;quot;)的做法，记忆犹新呀，调试完再删掉自己胡乱加的打印语句，偶尔还有漏删的情况，就commit，push上去了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;golang语言里有个&lt;code&gt;golang/glog&lt;/code&gt;包，是类似google内部&lt;a href="https://github.com/google/glog"&gt;glog&lt;/a&gt;的开源实现，其可以做到无侵入式调试程序，主要是通过启动时命令行传参来控制打印级别。&lt;/p&gt;
&lt;p&gt;有以下特性，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有四个级别的打印 Info, Warning, Error, Fatal，级别越来越高，分别都支持格式化输出Infof, Warningf, Errorf, Fatalf&lt;/li&gt;
&lt;li&gt;支持 -v传参，指定打印级别&lt;/li&gt;
&lt;li&gt;支持 -vmodule=file=2， 指定特殊文件开启打印，避免日志输出过多。&lt;/li&gt;
&lt;li&gt;支持 -log_dir=&amp;quot;&amp;quot;, 指定日志输出目录， 默认会按级别输出/tmp目录下， 高级别的会记录到低级别里日志文件里&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面举个简单的例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080"&gt;//file name: glog.go&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;package&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;main&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;import&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;(&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;flag&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;github.com/golang/glog&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;)&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;func&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#00a000"&gt;main&lt;/span&gt;()&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;flag.&lt;span style="color:#00a000"&gt;Parse&lt;/span&gt;()&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080"&gt;//flag.Set(&amp;#34;logtostderr&amp;#34;, &amp;#34;true&amp;#34;)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;defer&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;glog.&lt;span style="color:#00a000"&gt;Flush&lt;/span&gt;()&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;glog.&lt;span style="color:#00a000"&gt;Info&lt;/span&gt;(&lt;span style="color:#b44"&gt;&amp;#34;这里是Info级别的日志&amp;#34;&lt;/span&gt;)&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;glog.&lt;span style="color:#00a000"&gt;Warning&lt;/span&gt;(&lt;span style="color:#b44"&gt;&amp;#34;这里是Warning级别的日志&amp;#34;&lt;/span&gt;)&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;glog.&lt;span style="color:#00a000"&gt;Errorf&lt;/span&gt;(&lt;span style="color:#b44"&gt;&amp;#34;这里是Error级别的日志: %s&amp;#34;&lt;/span&gt;,&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;error&amp;#34;&lt;/span&gt;)&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;glog.&lt;span style="color:#00a000"&gt;V&lt;/span&gt;(&lt;span style="color:#666"&gt;3&lt;/span&gt;).&lt;span style="color:#00a000"&gt;Infoln&lt;/span&gt;(&lt;span style="color:#b44"&gt;&amp;#34;级别3的日志&amp;#34;&lt;/span&gt;)&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码如上运行，你需要执行&lt;code&gt;go get github.com/golang/glog&lt;/code&gt;下载依赖包， 然后运行&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;➜ go run glog.go -v 3
E0408 09:35:38.703186 8663 glog.go:15] This is a Error log error
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Error级别的会输出到标准输出，并记录到文件，&lt;/p&gt;</description></item><item><title>DevOps实战-0</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0/</guid><description>&lt;p&gt;主要涉及到&lt;code&gt;一键发布&lt;/code&gt;，&lt;code&gt;快速回滚&lt;/code&gt;，&lt;code&gt;弹性伸缩&lt;/code&gt;，&lt;code&gt;蓝绿部署&lt;/code&gt;方面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动openshift&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;oc cluster up --version=v1.5.0-rc.0 --metrics --use-existing-config=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认负责监控的pods占用资源太大了，可以这样限制下，或者cluster up时不加 &lt;code&gt;--metrics&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;oc login -u system:admin
oc env rc hawkular-cassandra-1 MAX_HEAP_SIZE=1024M -n openshift-infra

#重建下,变量才会生效
oc scale rc hawkular-cassandra-1 --replicas 0 -n openshift-infra
oc scale rc hawkular-cassandra-1 --replicas 1 -n openshift-infra
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立本地Git仓&lt;/p&gt;
&lt;p&gt;默认官方给出的例子基本都需要和Github结合，实在不好本地实战演示，所以本地要来一个&lt;code&gt;gogs&lt;/code&gt;代码仓。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;oc login -u devloper
oc new-project ci

#先拉取所依赖镜像
docker pull openshiftdemos/gogs:0.9.97
docker pull centos/postgresql-94-centos7

#创建gogs服务，并禁用webhook时的TLS校验，不然无法触发build
oc new-app -f https://raw.githubusercontent.com/xiaoping378/gogs-openshift-docker/master/openshift/gogs-persistent-template.yaml -p SKIP_TLS_VERIFY=true -p HOSTNAME=gogs-ci.192.168.31.49.xip.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的HOSTNAME，注意要换成自己宿主机的IPv4地址，默认创建的其他服务的路由都是这个形式的，&lt;/p&gt;
&lt;p&gt;有个有意思的地方，为什么默认路由会是这种 &lt;code&gt;name+IP+xip.io&lt;/code&gt; 形式呢，奥秘在 &lt;a href="http://xip.io"&gt;http://xip.io&lt;/a&gt; 的公共服务上。
这其实是个特殊的域DNS server，比如我们查询域名&lt;code&gt;gogs-ci.192.168.31.49.xip.io&lt;/code&gt;时 ，会返回192.168.31.49的地址回来，
而这个地址恰好是我们Router的地址，这样子Router会根据route的配置负责负载到对应的POD上。自己试验下就知道怎么回事了。&lt;/p&gt;</description></item><item><title>Helm模板介绍</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/kubernetes-helm%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/kubernetes-helm%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</guid><description>&lt;h3 id="概要"&gt;概要&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%a6%81" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Helm是一个管理kubernetes集群内应用的工具，提供了一系列管理应用的快捷方式，例如 inspect， install， upgrade， delete等，经验可以沿用以前apt，yum，homebrew的,区别就是helm管理的是kubernetes集群内的应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一个概念必须得提，就是&lt;code&gt;chart&lt;/code&gt;， 它代表的就是被helm管理的应用包，里面具体就是放一些预先配置的Kubernetes资源(pod, rc, deployment, service, ingress)，一个包描述文件(&lt;code&gt;Chart.yaml&lt;/code&gt;), 还可以通过指定依赖来组织成更复杂的应用，支持go template语法，可参数化模板，让使用者定制化安装
charts可以存放在本地，也可以放在远端，这点理解成yum仓很合适。。。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有个&lt;a href="https://kubeapps.com"&gt;应用市场&lt;/a&gt; ，里面罗列了各种应用charts。由开源项目&lt;a href="https://github.com/helm/monocular"&gt;monocular&lt;/a&gt;支撑&lt;/p&gt;
&lt;p&gt;下面主要介绍helm的基本使用流程和具体场景的实践。&lt;/p&gt;
&lt;h3 id="初始化k8s集群v1-6-2"&gt;初始化k8s集群v1.6.2&lt;a class="td-heading-self-link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96k8s%e9%9b%86%e7%be%a4v1-6-2" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先来准备k8s环境，可以通过&lt;a href="https://github.com/xiaoping378/k8s-deploy"&gt;k8s-deploy&lt;/a&gt;项目来离线安装高可用kubernetes集群，我这里是单机演示环境。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubeadm init --kubernetes-version v1.6.2 --pod-network-cidr 12.240.0.0/12
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;#方便命令自动补全&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;source&lt;/span&gt; &amp;lt;&lt;span style="color:#666"&gt;(&lt;/span&gt;kubectl completion zsh&lt;span style="color:#666"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;#安装cni网络&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cp /etc/kubernetes/admin.conf &lt;span style="color:#b8860b"&gt;$HOME&lt;/span&gt;/.kube/config
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl apply -f kube-flannel-rbac.yml
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl apply -f kube-flannel.yml
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;#使能master可以被调度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl taint node --all node-role.kubernetes.io/master-
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;#安装ingress-controller, 边界路由作用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl create -f ingress-traefik-rbac.yml
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl create -f ingress-traefik-deploy.yml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样一个比较完整的k8s环境就具备了，另外监控和日志不在此文的讨论范围内。&lt;/p&gt;
&lt;h3 id="初始化helm环境"&gt;初始化Helm环境&lt;a class="td-heading-self-link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96helm%e7%8e%af%e5%a2%83" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;由于刚才创建的k8s集群默认启用RBAC机制，个人认为这个特性是k8s真正走向成熟的一大标志，废话不表，为了helm可以安装任何应用，我们先给他最高权限。&lt;/p&gt;</description></item><item><title>fomo3d-钱都去哪儿了</title><link>https://xiaoping378.github.io/docs/5-blockchain/fomo3d-%E9%92%B1%E9%83%BD%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/fomo3d-%E9%92%B1%E9%83%BD%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86/</guid><description>&lt;p&gt;fomo3d里有战队系统、邀请分佣机制、持key分红、空投系统、持p3d分红等玩法, 相信通过之前各类媒体的解读都有所了解。&lt;/p&gt;
&lt;p&gt;下面通过分析合约代码，以讲解ETH数据流向的方式串下所有流程，让大家明明白白的知道自己的ETH都去了哪里。&lt;/p&gt;
&lt;p&gt;以10ETH充币到fomod3d合约举例，分三种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;早期用户（游戏刚启动时的激进者）&lt;/li&gt;
&lt;li&gt;中期用户（为了赚分红、返佣的用户）&lt;/li&gt;
&lt;li&gt;晚期用户（为了赢48%大奖的人）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="早期"&gt;早期&lt;a class="td-heading-self-link" href="#%e6%97%a9%e6%9c%9f" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当合约被激活后，开发者做了一个很“仇富”的举动，每个地址在合约收到100ETH之前，只能购买1ETH的keys，防止被资本大鳄收割本轮后面入场的玩家。这里有个小hack的点，就是提前多准备些小号，多个地址去投，也可以做到比别人便宜多的价格买到keys。&lt;/p&gt;
&lt;p&gt;这个阶段以买入10ETH举例，你只会买到等同于1ETH价值的keys，其余9个ETH会直接进入你的收益里，
演示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/ethLimiter2.png" alt="ethLimiter2"&gt;&lt;/p&gt;
&lt;p&gt;下面是实现此功能的代码&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/ethLimiter.png" alt="ethLimiter"&gt;&lt;/p&gt;
&lt;p&gt;代码里的规则(不限阶段)梳理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提款功能可以无限次提，不影响本轮接下来的分红收益，你的收益来自于你持有keys的分红。&lt;/li&gt;
&lt;li&gt;最低可以支付1e-09个Ether，当购买的Key数量大于或者等于1个时，倒计时会加30秒。&lt;/li&gt;
&lt;li&gt;当支付的eth不小于0.1时，会送一次“彩票”，买key支付的金额越大，中奖的奖金也越大，最大可中“彩票池”里额度的75%，直译过来这个功能叫空投。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="中期"&gt;中期&lt;a class="td-heading-self-link" href="#%e4%b8%ad%e6%9c%9f" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所有阶段的用户如果是直接打开的官网，充币买keys时会触发合约的这个接口，&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/buyXaddr.png" alt="buyXaddr"&gt;&lt;/p&gt;
&lt;p&gt;其中_affcode是值邀请人的地址，_team是指用户所有购买key所选的战队，默认的2是指蛇队。&lt;/p&gt;
&lt;p&gt;如果是从别人的邀请进入的官网，要看邀请人给你发的是哪个链接，有三种形式的链接：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/affiliate.png" alt="affiliate"&gt;,&lt;/p&gt;
&lt;p&gt;从上到下，分别会走&lt;code&gt;buyXaddr&lt;/code&gt;、&lt;code&gt;buyXid&lt;/code&gt;、&lt;code&gt;buyXname&lt;/code&gt;的接口，比如我给人发了&lt;a href="http://exitscam.me/xxp"&gt;exitscam.me/xxp&lt;/a&gt;的邀请链接，被邀的人买keys时会触发如下接口：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/affiliate2.png" alt="affiliate2"&gt;&lt;/p&gt;
&lt;p&gt;这其中我个人会收到他买key总额度的10%佣金，这里还有个隐藏的点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果用户是直接从官网进入买key的，那同样会有10%佣金的产生，只不过是流向p3d的持有者。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="晚期"&gt;晚期&lt;a class="td-heading-self-link" href="#%e6%99%9a%e6%9c%9f" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当有人买key时，都会选择一个战队，默认会被勾选蛇队的，当买到keys数量不小于1个时，会使所选战队成为本轮的潜在获胜队。&lt;/p&gt;
&lt;p&gt;说了这么多废话，回归正体，你的10ETH到底去了哪里？？？&lt;/p&gt;
&lt;p&gt;如果支付10ETH时，选的是蛇队，你10个ETH里的5.6个会被持keys的人均分，1个看情况是给p3d的人还是给邀请你的人，还有1个必定会分给持有p3d的人，另外2个会进入大池子，其中0.2个会分给社区贡献人，0.1个会给TeamJust的另一个游戏合约，还有0.1个会流到“彩票池”里。&lt;/p&gt;
&lt;p&gt;这里面根据你选的战队不通，分配比例不一样，具体看下的代码，执行这些ETH分配的是走&lt;code&gt;distributeExternal&lt;/code&gt;，&lt;code&gt;distributeInternal&lt;/code&gt; 出去的。&lt;/p&gt;
&lt;p&gt;后面的PotSpit是本轮游戏结束后，如何分配大池子里的金额。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Team allocation structures
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 0 = whales
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 1 = bears
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 2 = sneks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 3 = bulls
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Team allocation percentages
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// (F3D, P3D) + (Pot , Referrals, Community)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Referrals / Community rewards are mathematically designed to come from the winner&amp;#39;s share of the pot.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;fees_[&lt;span style="color:#666"&gt;0&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; F3Ddatasets.TeamFee(&lt;span style="color:#666"&gt;30&lt;/span&gt;,&lt;span style="color:#666"&gt;6&lt;/span&gt;); &lt;span style="color:#080;font-style:italic"&gt;//50% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;fees_[&lt;span style="color:#666"&gt;1&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; F3Ddatasets.TeamFee(&lt;span style="color:#666"&gt;43&lt;/span&gt;,&lt;span style="color:#666"&gt;0&lt;/span&gt;); &lt;span style="color:#080;font-style:italic"&gt;//43% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;fees_[&lt;span style="color:#666"&gt;2&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; F3Ddatasets.TeamFee(&lt;span style="color:#666"&gt;56&lt;/span&gt;,&lt;span style="color:#666"&gt;10&lt;/span&gt;); &lt;span style="color:#080;font-style:italic"&gt;//20% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;fees_[&lt;span style="color:#666"&gt;3&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; F3Ddatasets.TeamFee(&lt;span style="color:#666"&gt;43&lt;/span&gt;,&lt;span style="color:#666"&gt;8&lt;/span&gt;); &lt;span style="color:#080;font-style:italic"&gt;//35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// how to split up the final pot based on which team was picked
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// (F3D, P3D)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;potSplit_[&lt;span style="color:#666"&gt;0&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; F3Ddatasets.PotSplit(&lt;span style="color:#666"&gt;15&lt;/span&gt;,&lt;span style="color:#666"&gt;10&lt;/span&gt;); &lt;span style="color:#080;font-style:italic"&gt;//48% to winner, 25% to next round, 2% to com
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;potSplit_[&lt;span style="color:#666"&gt;1&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; F3Ddatasets.PotSplit(&lt;span style="color:#666"&gt;25&lt;/span&gt;,&lt;span style="color:#666"&gt;0&lt;/span&gt;); &lt;span style="color:#080;font-style:italic"&gt;//48% to winner, 25% to next round, 2% to com
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;potSplit_[&lt;span style="color:#666"&gt;2&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; F3Ddatasets.PotSplit(&lt;span style="color:#666"&gt;20&lt;/span&gt;,&lt;span style="color:#666"&gt;20&lt;/span&gt;); &lt;span style="color:#080;font-style:italic"&gt;//48% to winner, 10% to next round, 2% to com
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;&lt;/span&gt;potSplit_[&lt;span style="color:#666"&gt;3&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; F3Ddatasets.PotSplit(&lt;span style="color:#666"&gt;30&lt;/span&gt;,&lt;span style="color:#666"&gt;10&lt;/span&gt;); &lt;span style="color:#080;font-style:italic"&gt;//48% to winner, 10% to next round, 2% to com
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还有很多细节要分享，碍于时间有限，不过我会持续更新这里的&lt;/p&gt;</description></item><item><title>VSCode-开发已有的java项目</title><link>https://xiaoping378.github.io/docs/3-devops/5-java-in-vscode/</link><pubDate>Wed, 04 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/5-java-in-vscode/</guid><description>&lt;p&gt;个人经验记录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;install deps&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/vscode-java.png" alt=""&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;clean workspace&lt;/p&gt;
&lt;p&gt;代开设置 Ctrl+Shift+P, 输入 &lt;code&gt;clean java workspace&lt;/code&gt; and restart&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;support lombok&lt;/p&gt;
&lt;p&gt;java代码出了名的冗长，lombok可以优雅解决此类问题，如果项目依赖了lombok， vsocde打开java项目就会显示各种&lt;code&gt;cannot be resloved&lt;/code&gt;错误,&lt;/p&gt;
&lt;p&gt;下面是我个人的配置,其中&lt;code&gt;java.jdt.ls.vmargs&lt;/code&gt;的配置（看个人项目maven依赖和安装路径了），会消除错误，并可以支持跳转：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;window.menuBarVisibility&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;toggle&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;window.zoomLevel&amp;#34;&lt;/span&gt;: &lt;span style="color:#666"&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;explorer.confirmDelete&amp;#34;&lt;/span&gt;: &lt;span style="color:#a2f;font-weight:bold"&gt;false&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;workbench.colorTheme&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;Solarized Dark&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;files.associations&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;default&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;toml&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;editor.fontLigatures&amp;#34;&lt;/span&gt;: &lt;span style="color:#a2f;font-weight:bold"&gt;true&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;java.configuration.checkProjectSettingsExclusions&amp;#34;&lt;/span&gt;: &lt;span style="color:#a2f;font-weight:bold"&gt;false&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;go.autocompleteUnimportedPackages&amp;#34;&lt;/span&gt;: &lt;span style="color:#a2f;font-weight:bold"&gt;true&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#008000;font-weight:bold"&gt;&amp;#34;java.jdt.ls.vmargs&amp;#34;&lt;/span&gt;:&lt;span style="color:#b44"&gt;&amp;#34;-javaagent:/home/xxp/.m2/repository/./org/projectlombok/lombok/1.16.20/lombok-1.16.20.jar -Xbootclasspath/a:/home/xxp/.m2/repository/./org/projectlombok/lombok/1.16.20/lombok-1.16.20.jar&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考链接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/redhat-developer/vscode-java/wiki/Lombok-support"&gt;https://github.com/redhat-developer/vscode-java/wiki/Lombok-support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.visualstudio.com/docs/languages/java"&gt;https://code.visualstudio.com/docs/languages/java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/redhat-developer/vscode-java/wiki/Troubleshooting"&gt;https://github.com/redhat-developer/vscode-java/wiki/Troubleshooting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>DevOps实战-1</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-1/</guid><description>&lt;p&gt;本文主要介绍基于openshift如何完成&lt;code&gt;开发-&amp;gt;测试-&amp;gt;线上&lt;/code&gt;场景的变更，这是一个典型的应用生产流程，来看看openshift是如何利用容器优雅的完成整个过程的吧&lt;/p&gt;
&lt;p&gt;下文基于上篇&lt;a href="../openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0"&gt;DevOps实战-0&lt;/a&gt; 的&lt;code&gt;nodejs-ex&lt;/code&gt;项目来说, 假设到这里，你本地已经有了nodejs-ex项目&lt;/p&gt;
&lt;h3 id="准备3个project"&gt;准备3个project&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%873%e4%b8%aaproject" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;用这3个project来模拟开发，测试，线上环境&lt;/p&gt;
&lt;p&gt;现实中一般各个场景的服务器都是物理隔离的，这里可以利用&lt;code&gt;--node-selector&lt;/code&gt;，来指定项目可以跑在哪些节点上。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc login -u sysetm:admin

#晚上在笔记本上写此blog，没合适的环境，单机模拟多台 -- start
oc label node 192.168.31.49 web-prod=true web-dev=true web-test=true
#晚上在笔记本上写此blog，没合适的环境，单机模拟多台 -- end

#1.创建web-dev项目
#2.授权developer为开发组项目管理员
#3.授权测试和运维人员可以从开发组拉取镜像
oc adm new-project web-dev --node-selector=&amp;#39;web-dev=true&amp;#39;
oc policy add-role-to-user admin developer
oc policy add-role-to-group system:image-puller system:serviceaccounts:web-test -n web-dev
oc policy add-role-to-group system:image-puller system:serviceaccounts:web-prod -n web-dev

oc adm new-project web-test --node-selector=&amp;#39;web-test=true&amp;#39;
oc policy add-role-to-user admin tester

oc adm new-project web-prod --node-selector=&amp;#39;web-prod=true&amp;#39;
oc policy add-role-to-user admin ops
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你可能会注意到，这里用的&lt;code&gt;new-project&lt;/code&gt; 前面还加了adm， 其实&lt;code&gt;oc adm&lt;/code&gt;等效于&lt;code&gt;oadm&lt;/code&gt;， 一般管理集群相关的用这个命令，这里是因为需要读取节点的标签（label）信息。&lt;/p&gt;</description></item><item><title>k8s的监控方案</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/kuerbernetes%E7%9A%84%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/kuerbernetes%E7%9A%84%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/</guid><description>&lt;h2 id="方案选型"&gt;方案选型&lt;a class="td-heading-self-link" href="#%e6%96%b9%e6%a1%88%e9%80%89%e5%9e%8b" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如果已存在完善的监控系统的话，推荐使用k8s原生的&lt;strong&gt;heapster&lt;/strong&gt;，比较轻量，容易集成。&lt;/p&gt;
&lt;p&gt;我选择的是&lt;strong&gt;prometheus&lt;/strong&gt;, 它是比较完善的云平台级监控方案，继k8s之后同样已被列入&lt;a href="https://cncf.io/projects"&gt;云计算基金会&lt;/a&gt;项目, 除了具备heapster的能力之外，还支持监控广泛的应用(mysql, JMX, HAProxy等)和灵活的告警的能力，并具备多IDC federation的能力，兼容多种开源监控系统（StatsD, Ganglia, collectd, nagios等）。&lt;/p&gt;
&lt;p&gt;本文主要参考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/kubernetes/heapster/issues/645"&gt;prometheus和heapster开发者之间的对话&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CoreOS的blog&lt;a href="https://coreos.com/blog/monitoring-kubernetes-with-prometheus.html"&gt;Monitoring Kubernetes with Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别介绍下两种方案&lt;/p&gt;
&lt;h3 id="heapster"&gt;heapster&lt;a class="td-heading-self-link" href="#heapster" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;heapster的介绍:&lt;/p&gt;
&lt;p&gt;通过向kubelet拉取stats的方式， 可提供15分钟内的缓存供k8s的dashboard用，也支持第三方存储，如influxdb等，还具备REST API(经我实验，这个API还不完善 &lt;a href="https://github.com/kubernetes/heapster/issues/1155"&gt;缺少diskIO API&lt;/a&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;heapster的监控范围&lt;/p&gt;
&lt;p&gt;可监控的内容包括集群内的Container, Pod, Node 和 Namespace的性能或配置信息，
目前container级别还不支持网络和硬盘信息，具体性能项如下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Metric Name&lt;/th&gt;
 &lt;th&gt;Description&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;cpu/limit&lt;/td&gt;
 &lt;td&gt;CPU hard limit in millicores.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;cpu/node_capacity&lt;/td&gt;
 &lt;td&gt;Cpu capacity of a node.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;cpu/node_allocatable&lt;/td&gt;
 &lt;td&gt;Cpu allocatable of a node.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;cpu/node_reservation&lt;/td&gt;
 &lt;td&gt;Share of cpu that is reserved on the node allocatable.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;cpu/node_utilization&lt;/td&gt;
 &lt;td&gt;CPU utilization as a share of node allocatable.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;cpu/request&lt;/td&gt;
 &lt;td&gt;CPU request (the guaranteed amount of resources) in millicores.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;cpu/usage&lt;/td&gt;
 &lt;td&gt;Cumulative CPU usage on all cores.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;cpu/usage_rate&lt;/td&gt;
 &lt;td&gt;CPU usage on all cores in millicores.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;filesystem/usage&lt;/td&gt;
 &lt;td&gt;Total number of bytes consumed on a filesystem.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;filesystem/limit&lt;/td&gt;
 &lt;td&gt;The total size of filesystem in bytes.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;filesystem/available&lt;/td&gt;
 &lt;td&gt;The number of available bytes remaining in a the filesystem&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/limit&lt;/td&gt;
 &lt;td&gt;Memory hard limit in bytes.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/major_page_faults&lt;/td&gt;
 &lt;td&gt;Number of major page faults.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/major_page_faults_rate&lt;/td&gt;
 &lt;td&gt;Number of major page faults per second.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/node_capacity&lt;/td&gt;
 &lt;td&gt;Memory capacity of a node.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/node_allocatable&lt;/td&gt;
 &lt;td&gt;Memory allocatable of a node.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/node_reservation&lt;/td&gt;
 &lt;td&gt;Share of memory that is reserved on the node allocatable.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/node_utilization&lt;/td&gt;
 &lt;td&gt;Memory utilization as a share of memory allocatable.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/page_faults&lt;/td&gt;
 &lt;td&gt;Number of page faults.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/page_faults_rate&lt;/td&gt;
 &lt;td&gt;Number of page faults per second.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/request&lt;/td&gt;
 &lt;td&gt;Memory request (the guaranteed amount of resources) in bytes.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/usage&lt;/td&gt;
 &lt;td&gt;Total memory usage.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;memory/working_set&lt;/td&gt;
 &lt;td&gt;Total working set usage. Working set is the memory being used and not easily dropped by the kernel.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;network/rx&lt;/td&gt;
 &lt;td&gt;Cumulative number of bytes received over the network.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;network/rx_errors&lt;/td&gt;
 &lt;td&gt;Cumulative number of errors while receiving over the network.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;network/rx_errors_rate&lt;/td&gt;
 &lt;td&gt;Number of errors while receiving over the network per second.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;network/rx_rate&lt;/td&gt;
 &lt;td&gt;Number of bytes received over the network per second.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;network/tx&lt;/td&gt;
 &lt;td&gt;Cumulative number of bytes sent over the network&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;network/tx_errors&lt;/td&gt;
 &lt;td&gt;Cumulative number of errors while sending over the network&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;network/tx_errors_rate&lt;/td&gt;
 &lt;td&gt;Number of errors while sending over the network&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;network/tx_rate&lt;/td&gt;
 &lt;td&gt;Number of bytes sent over the network per second.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;uptime&lt;/td&gt;
 &lt;td&gt;Number of milliseconds since the container was started.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="prometheus"&gt;Prometheus&lt;a class="td-heading-self-link" href="#prometheus" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Prometheus集成了数据采集，存储，异常告警多项功能，是一款一体化的完整方案。 它针对大规模的集群环境设计了拉取式的数据采集方式、多维度数据存储格式以及服务发现等创新功能。&lt;/p&gt;</description></item><item><title>KVM和Libvirt的实践整理</title><link>https://xiaoping378.github.io/docs/4-cloud/kvm-virsh%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/kvm-virsh%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/</guid><description>&lt;h2 id="介绍"&gt;介绍&lt;a class="td-heading-self-link" href="#%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;此前一直用Virtualbox操作虚机的东西，对于个人搭建环境还是显的有些笨重，不能实现Iac的目标，故尝试了Vagrant和Libvirt，综合考虑我选择libvirt继续深入下去，也是希望以后有机会可以深入搞下openstack的nova组件。&lt;/p&gt;
&lt;h2 id="安装必要依赖"&gt;安装必要依赖&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85%e5%bf%85%e8%a6%81%e4%be%9d%e8%b5%96" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo apt install bridge-utils qemu-kvm virtinst -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;qemu-kvm: 这个负责hypervisor层和仿真器（可以模拟x86, arm体系）.&lt;/li&gt;
&lt;li&gt;virtinst: 安装和管理虚机的命令行工具&lt;/li&gt;
&lt;li&gt;bridge-utils： 创建和管理bridge网络&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装完输入&lt;code&gt;kvm-ok&lt;/code&gt;查看是否安装OK，另外还&lt;code&gt;需要重启&lt;/code&gt;以使kvm和libvirt daemon启动。&lt;/p&gt;
&lt;h2 id="配置网络"&gt;配置网络&lt;a class="td-heading-self-link" href="#%e9%85%8d%e7%bd%ae%e7%bd%91%e7%bb%9c" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;未完。。。&lt;/p&gt;</description></item><item><title>解读cosmos-sdk系列(1)</title><link>https://xiaoping378.github.io/docs/5-blockchain/cosmos_sdk_1/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/cosmos_sdk_1/</guid><description>&lt;p&gt;通过本系列，可以了解tendermint共识和cosmos-sdk架构的设计思想，并学习到如何通过Cosmos-SDK来快速开发自己的区块链应用。&lt;/p&gt;
&lt;p&gt;cosmos团队把区块链分成了三层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络层 - p2p负责广播交易&lt;/li&gt;
&lt;li&gt;共识层 - 对哪些交易打包进块形成共识&lt;/li&gt;
&lt;li&gt;应用层 - 执行交易，负责交易结果落盘（状态一致）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的应用层可能会有误解，并非是Dapp层，对于SDK底层的Tendermint来说，除p2p网络和打包块共识外，其他都算是应用部分，
拿实现比特币公链的例子来讲，应用部分就是维护账户的UTXO数据库，如果对比以太的话，keystore账户和EVM虚机部分就是应用范畴，所以SDK内置了账户、质押、治理、权限等应用模块，可以帮助我们简单地实现底层链的开发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以把这几层简单理解成各节点通过同步交易集（块）日志，实现数据（状态）一致性。数据库的主从模式不也是同步binlog日志，各自执行（replay，回放）日志后，实现数据（状态）最终落盘，区块节点本身同步块的时候，默认就是去下载交易日志，把执行结果按照逻辑链的形式写入本地leveldb的，然后才能对外提供各类RPC服务。&lt;/p&gt;
&lt;h2 id="tendermint共识"&gt;tendermint共识&lt;a class="td-heading-self-link" href="#tendermint%e5%85%b1%e8%af%86" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为后续更好的利用cosmos-sdk，要先了解下Tendermint。&lt;/p&gt;
&lt;p&gt;Tendermint Core 提供了网络和共识层功能，而应用层要通过ABCI协议和Core互通消息msg，简单讲tendermint负责起一个replication engine进程，而应用层要运行一个state macheine进程，进程间通过ABCI消息来通信。&lt;/p&gt;
&lt;p&gt;ABCI协议的消息体用protobuf定义在&lt;a href="https://github.com/tendermint/tendermint/blob/master/abci/types/types.proto"&gt;这里&lt;/a&gt;，app侧可以响应的request如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-golang" data-lang="golang"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;message&lt;span style="color:#bbb"&gt; &lt;/span&gt;Request&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;oneof&lt;span style="color:#bbb"&gt; &lt;/span&gt;value&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestEcho&lt;span style="color:#bbb"&gt; &lt;/span&gt;echo&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;2&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestFlush&lt;span style="color:#bbb"&gt; &lt;/span&gt;flush&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;3&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestInfo&lt;span style="color:#bbb"&gt; &lt;/span&gt;info&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;4&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestSetOption&lt;span style="color:#bbb"&gt; &lt;/span&gt;set_option&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;5&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestInitChain&lt;span style="color:#bbb"&gt; &lt;/span&gt;init_chain&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;6&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestQuery&lt;span style="color:#bbb"&gt; &lt;/span&gt;query&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;7&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestBeginBlock&lt;span style="color:#bbb"&gt; &lt;/span&gt;begin_block&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;8&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestCheckTx&lt;span style="color:#bbb"&gt; &lt;/span&gt;check_tx&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;9&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestDeliverTx&lt;span style="color:#bbb"&gt; &lt;/span&gt;deliver_tx&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;19&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestEndBlock&lt;span style="color:#bbb"&gt; &lt;/span&gt;end_block&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;11&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;RequestCommit&lt;span style="color:#bbb"&gt; &lt;/span&gt;commit&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;12&lt;/span&gt;;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ABCI的设计主要有以下几个特点：&lt;/p&gt;</description></item><item><title> 编译和目录结构介绍</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E6%BA%90%E7%A0%81-%E7%BC%96%E8%AF%91%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E6%BA%90%E7%A0%81-%E7%BC%96%E8%AF%91%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid><description>&lt;p&gt;介绍openshift的源码编译和目录结构组织，为了方便代码调试和了解大型Golang项目的构建方式&lt;/p&gt;
&lt;h3 id="编译"&gt;编译&lt;a class="td-heading-self-link" href="#%e7%bc%96%e8%af%91" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;无论是openshift还是Kubernetes等大型Golang项目都用到了&lt;code&gt;Makefile&lt;/code&gt;, 所以有必要从此开始说起，这里只说项目里用到的makefile特性，想了解更多的可以参考&lt;a href="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf"&gt;跟我一起写Makefile&lt;/a&gt;&lt;/p&gt;
&lt;h4 id="makefile介绍"&gt;Makefile介绍&lt;a class="td-heading-self-link" href="#makefile%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、
模块分别放在若干个目录中，makefile 定义了一系列的规则来指定，哪些文件需要先编译，
哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为
makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。 makefile 带来的好
处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，
极大的提高了软件开发的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Makefile里的规则，就在做两件事，一个是指明依赖关系，另一个是生成目标的方法&lt;/p&gt;
&lt;p&gt;Golang项目里用到的Makefile规则比较简单，基本就是定义一个目标的生成方法，下面的示例是Openshift项目里makefile中定义的第一个目标。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#00a000"&gt;all build&lt;/span&gt;&lt;span style="color:#666"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	hack/build-go.sh &lt;span style="color:#a2f;font-weight:bold"&gt;$(&lt;/span&gt;WHAT&lt;span style="color:#a2f;font-weight:bold"&gt;)&lt;/span&gt; &lt;span style="color:#a2f;font-weight:bold"&gt;$(&lt;/span&gt;GOFLAGS&lt;span style="color:#a2f;font-weight:bold"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#00a000"&gt;.PHONY&lt;/span&gt;&lt;span style="color:#666"&gt;:&lt;/span&gt; all build
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;all build&lt;/code&gt;，是定义的目标，看到这个就知道可以在源码的根目录上执行&lt;code&gt;make all build&lt;/code&gt;来编译了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二行说明生成目标的方法，就是去hack目录下执行build-go.sh脚本，这里还支持传入一些参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三行 &lt;code&gt;.PHONY&lt;/code&gt;，起到一个标识的作用，没什么实际意义，是用来告诉make命令，这里是个伪目标，也可以说成是默认目标，所以在openshift的根目录上直接执行&lt;code&gt;make&lt;/code&gt;, 等效于&lt;code&gt;make all build&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还可以自己决定是否编译出镜像或者rpm包（make release, make build-rpms）&lt;/p&gt;
&lt;h4 id="编译openshift"&gt;编译openshift&lt;a class="td-heading-self-link" href="#%e7%bc%96%e8%af%91openshift" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;上边介绍了，直接敲&lt;code&gt;make&lt;/code&gt;就可以自动编译出所有平台（linux, mac, windows）的二进制，编译前介绍两个hack方法，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在hack/build-go.sh的第二行加上&lt;code&gt;set -x&lt;/code&gt;， 这样的话，shell脚本在运行时，里面的所有变量和执行路径会全部打印出来，一目了然，不用自己一行一行的加echo debug了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如下修改hack/build-cross.sh，不然会编译出多平台的二进制，花的时间略长啊。。。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# by default, build for these platforms
platforms=(
 linux/amd64
 # darwin/amd64
 # windows/amd64
 # linux/386
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简易说下执行make后，都发生了什么，只会捡关键点说。&lt;/p&gt;</description></item><item><title>MongoDB之初见</title><link>https://xiaoping378.github.io/docs/3-devops/6-mogodb-0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/6-mogodb-0/</guid><description>&lt;ol&gt;
&lt;li&gt;手动启动&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 下载二进制&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.9.tgz
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;tar -zxvf mongodb-linux-x86_64-3.4.9.tgz
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ln -s &lt;span style="color:#b8860b"&gt;$PWD&lt;/span&gt;/mongodb-linux-x86_64-3.4.9/bin/* /home/xxp/Software/bin
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 创建数据存储目录	&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir mongodb
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo chown -R &lt;span style="color:#b8860b"&gt;$USER&lt;/span&gt; ./mongodb
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mongod -dbpath&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#b8860b"&gt;$PWD&lt;/span&gt;/mongodb
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认监听27017， 根据情况选择关闭warning。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;推荐调试方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认可以使用&lt;code&gt;mongo&lt;/code&gt;进入shell交互模式，
亦可使用图形管理界面，推荐&lt;code&gt;robo3T&lt;/code&gt;, 目前1.1.1版本在ubuntu桌面上有crash问题，需要如下操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;curl -O https://download.robomongo.org/1.1.1/linux/robo3t-1.1.1-linux-x86_64-c93c6b0.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;tar zxvf robo3t-1.1.1-linux-x86_64-c93c6b0.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir ~/robo-backup
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mv robo3t-1.1.1-linux-x86_64-c93c6b0/lib/libstdc++* ~/robo-backup/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;robo3t-1.1.1-linux-x86_64-c93c6b0/bin/robo3t
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src="https://xiaoping378.github.io/robo3t.png" alt=""&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;shell里敲mongo进入交互界面，&lt;/p&gt;
&lt;p&gt;手续推荐查看&lt;a href="http://www.mongoing.com/docs/reference/sql-comparison.html"&gt;mongodb中文文档&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Vagrant实践整理</title><link>https://xiaoping378.github.io/docs/4-cloud/vagrant%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/vagrant%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p&gt;很早就听说vagrant的大名，是个创建和管理虚机环境的工具，但一直没有机会实践下，近日我的VirtuablBox让我搞砸了，决定试用下，便于快速搭建各种环境。&lt;/p&gt;
&lt;h2 id="安装vagrant"&gt;安装vagrant&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85vagrant" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;图省事儿的话，直接&lt;code&gt;sudo apt install vagrant&lt;/code&gt;就可以安装，不过版本有点儿低，是1.8.1。&lt;/p&gt;
&lt;p&gt;通过官方&lt;a href="https://www.vagrantup.com/downloads.html"&gt;下载地址&lt;/a&gt;, 可直接下载最新的安装包。我这里安装的是1.9.4&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ ~ vagrant -v
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Vagrant 1.9.4
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="常用命令"&gt;常用命令&lt;a class="td-heading-self-link" href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一个打包好的操作系统在Vagrant中称为Box，即Box是一个打包好的操作系统环境，网上有很多打包好的环境，官方也有下载各种Boxes的&lt;a href="https://atlas.hashicorp.com/boxes/search"&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般使用流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vagrant box add 添加box的操作&lt;/li&gt;
&lt;li&gt;vagrant init 初始化box的操作&lt;/li&gt;
&lt;li&gt;vagrant up 启动虚拟机的操作&lt;/li&gt;
&lt;li&gt;vagrant ssh 登录虚拟机的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;额外还有些常用的命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vagrant box list 显示当前已经添加的box列表&lt;/li&gt;
&lt;li&gt;vagrant box remove 删除相应的box&lt;/li&gt;
&lt;li&gt;vagrant halt -f 冷关机（切断电源）&lt;/li&gt;
&lt;li&gt;vagrant suspend 挂起当前的虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="实践"&gt;实践&lt;a class="td-heading-self-link" href="#%e5%ae%9e%e8%b7%b5" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目前vagrant 1.9.4支持适配VirtualBox, VMware，Hyper-V, 和 Docker，本文使用的是VirtualBox。&lt;/p&gt;
&lt;p&gt;需要你本机已经&lt;a href="https://www.virtualbox.org/wiki/Downloads"&gt;安装virtuablbox&lt;/a&gt;环境&lt;/p&gt;
&lt;p&gt;一般只要如下初始化，就会有个最新的centos-7虚机环境&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ vagrant init centos/7
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;A &lt;span style="color:#b44"&gt;`&lt;/span&gt;Vagrantfile&lt;span style="color:#b44"&gt;`&lt;/span&gt; has been placed in this directory. You are now
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ready to &lt;span style="color:#b44"&gt;`&lt;/span&gt;vagrant up&lt;span style="color:#b44"&gt;`&lt;/span&gt; your first virtual environment! Please &lt;span style="color:#a2f"&gt;read&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;the comments in the Vagrantfile as well as documentation on
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;`&lt;/span&gt;vagrantup.com&lt;span style="color:#b44"&gt;`&lt;/span&gt; &lt;span style="color:#a2f;font-weight:bold"&gt;for&lt;/span&gt; more information on using Vagrant.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ ls
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Vagrantfile
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ vagrant up --provider virtualbox
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Bringing machine &lt;span style="color:#b44"&gt;&amp;#39;default&amp;#39;&lt;/span&gt; up with &lt;span style="color:#b44"&gt;&amp;#39;virtualbox&amp;#39;&lt;/span&gt; provider...
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;==&lt;/span&gt;&amp;gt; default: Box &lt;span style="color:#b44"&gt;&amp;#39;centos/7&amp;#39;&lt;/span&gt; could not be found. Attempting to find and install...
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; default: Box Provider: virtualbox
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; default: Box Version: &amp;gt;&lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#b8860b"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;==&lt;/span&gt;&amp;gt; default: Loading metadata &lt;span style="color:#a2f;font-weight:bold"&gt;for&lt;/span&gt; box &lt;span style="color:#b44"&gt;&amp;#39;centos/7&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; default: URL: https://atlas.hashicorp.com/centos/7
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;==&lt;/span&gt;&amp;gt; default: Adding box &lt;span style="color:#b44"&gt;&amp;#39;centos/7&amp;#39;&lt;/span&gt; &lt;span style="color:#666"&gt;(&lt;/span&gt;v1704.01&lt;span style="color:#666"&gt;)&lt;/span&gt; &lt;span style="color:#a2f;font-weight:bold"&gt;for&lt;/span&gt; provider: virtualbox
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; default: Downloading: https://atlas.hashicorp.com/centos/boxes/7/versions/1704.01/providers/virtualbox.box
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; default: Progress: 2% &lt;span style="color:#666"&gt;(&lt;/span&gt;Rate: 94086/s, Estimated &lt;span style="color:#a2f"&gt;time&lt;/span&gt; remaining: 1:52:14&lt;span style="color:#666"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但如上需要依赖外网, 国内环境一般会下载失败，我这里介绍一种通过本地iso创建Box的方法，然后通过本地Box启动虚机环境。&lt;/p&gt;</description></item><item><title>配置harbor默认https访问</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/harbor_https/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/harbor_https/</guid><description>&lt;p&gt;因为使用自签证书（reg.300.cn），所以需要把中间过程生成的ca.crt拷贝到需要pull/push的node上 (懒的翻译了，很详细的文档，已验证OK)&lt;/p&gt;
&lt;p&gt;Because Harbor does not ship with any certificates, it uses HTTP by default to serve registry requests. This makes it relatively simple to configure. However, it is highly recommended that security be enabled for any production environment. Harbor has an Nginx instance as a reverse proxy for all services, you can configure Nginx to enable https.&lt;/p&gt;
&lt;p&gt;##Getting a certificate&lt;/p&gt;
&lt;p&gt;Assuming that your registry's &lt;strong&gt;hostname&lt;/strong&gt; is &lt;strong&gt;reg.yourdomain.com&lt;/strong&gt;, and that its DNS record points to the host where you are running Harbor. You first should get a certificate from a CA. The certificate usually contains a .crt file and a .key file, for example, &lt;strong&gt;yourdomain.com.crt&lt;/strong&gt; and &lt;strong&gt;yourdomain.com.key&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>farbic-搭建高并发交易网络</title><link>https://xiaoping378.github.io/docs/5-blockchain/farbic-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/farbic-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA/</guid><description>&lt;p&gt;针对每秒数千笔交易的场景，默认的CCVC（并发控制版本检查）会导致交易失败率的上升，其实不需要对基础网络本身做特殊设置，从合约代码入手可以解决，参考官方例子&lt;a href="https://github.com/hyperledger/fabric-samples"&gt;farbic-samples&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="下载项目"&gt;下载项目&lt;a class="td-heading-self-link" href="#%e4%b8%8b%e8%bd%bd%e9%a1%b9%e7%9b%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;基于目前最新的v1.0.3版本来说&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git clone https://github.com/hyperledger/fabric-samples.git
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;cd&lt;/span&gt; fabric-samples/first-network
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;未完...&lt;/p&gt;</description></item><item><title>Openldap之拨云见日</title><link>https://xiaoping378.github.io/docs/3-devops/7-openldap%E4%B9%8B%E6%8B%A8%E4%BA%91%E5%8E%BB%E6%97%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/7-openldap%E4%B9%8B%E6%8B%A8%E4%BA%91%E5%8E%BB%E6%97%A5/</guid><description>&lt;p&gt;很早就听说LDAP/AD之流的企业级概念，认为是做统一用户认证的，具体怎么使用对接，一直有点儿糊涂，今天决定搞明白这些，并深入实践下openldap。&lt;/p&gt;
&lt;p&gt;未完...TODO&lt;/p&gt;</description></item><item><title>多负载均衡方案</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-router%E5%92%8Chaproxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-router%E5%92%8Chaproxy/</guid><description>&lt;p&gt;haproxy在openshift里默认有两种用处，一个种负责master的高可用，一种是负责外部对内服务的访问（ingress controller）&lt;/p&gt;
&lt;p&gt;平台部署情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3台master，etcd&lt;/li&gt;
&lt;li&gt;1台node&lt;/li&gt;
&lt;li&gt;1台lb（haproxy）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="haproxy负载均衡master的高可用"&gt;haproxy负载均衡master的高可用&lt;a class="td-heading-self-link" href="#haproxy%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1master%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;lb负责master间的负载均衡，其实负载没那么大，更多得是用来避免单点故障&lt;/p&gt;
&lt;h3 id="debug介绍"&gt;Debug介绍&lt;a class="td-heading-self-link" href="#debug%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认安装haproxy1.5.18版本，开启debug方法&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# 默认systemd对haproxy做了封装，会以-Ds后台形式启动，debug信息是看不到的
systemctl stop harproxy

# vi /etc/haproxy/haproxy.cfg
 log 127.0.0.1 local3 debug

# 手动启动haproxy
haproxy -f /etc/haproxy/haproxy.cfg -p /run/haproxy.pid -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不知道是不是哪里还需要设置，打印出来的日志，信息并不是不太多&lt;/p&gt;
&lt;p&gt;另外浏览&lt;code&gt;https://lbIP:9000&lt;/code&gt;, 可以看到统计信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="配置介绍"&gt;配置介绍&lt;a class="td-heading-self-link" href="#%e9%85%8d%e7%bd%ae%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;a href="https://github.com/xiaoping378/openshift-deploy"&gt;openshift-ansible&lt;/a&gt;部署后，harpxy的配置如下&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;[root@node4 ~]# cat /etc/haproxy/haproxy.cfg
# Global settings
#---------------------------------------------------------------------
global
 chroot /var/lib/haproxy
 pidfile /var/run/haproxy.pid
 maxconn 20000
 user haproxy
 group haproxy
 daemon
 log /dev/log local0 info #定义debug级别

 # turn on stats unix socket
 stats socket /var/lib/haproxy/stats

#---------------------------------------------------------------------
# common defaults that all the &amp;#39;listen&amp;#39; and &amp;#39;backend&amp;#39; sections will
# use if not designated in their block
#---------------------------------------------------------------------
defaults #默认配置，后面同KEY的设置会覆盖此处
 mode http #工作在七层代理，客户端请求在转发至后端服务器之前将会被深度分板，所有不与RFC格式兼容的请求都会被拒绝，一些七层的过滤处理手段，可以使用。
 log global #默认启用gloabl的日志设置
 option httplog #默认日志类别为http日志格式
 option dontlognull #不记录健康检查日志信息（端口扫描，空信息）
# option http-server-close
 option forwardfor except 127.0.0.0/8 #如果上游服务器上的应用程序想记录客户端的真实IP地址，haproxy会把客户端的IP信息发送给上游服务器，在HTTP请求中添加”X-Forwarded-For”字段,但当是haproxy自身的健康检测机制去访问上游服务器时是不应该把这样的访问日志记录到日志中的，所以用except来排除127.0.0.0，即haproxy自身
 option redispatch #代理的服务器挂掉后，强制定向到其他健康的服务器，避免cookie信息过时，仍可正常访问
 retries 3 #3次连接失败就认为后端服务器不可用
 timeout http-request 10s #默认客户端发送http请求的超时时间， 防DDOS攻击手段
 timeout queue 1m #当后台服务器maxconn满了后，haproxy会把client发送来的请求放进一个队列中，一旦事件超过timeout queue，还没被处理，haproxy会自动返回503错误。
 timeout connect 10s #haproxy与后端服务器连接超时时间，如果在同一个局域网可设置较小的时间
 timeout client 300s #默认客户端与haproxy连接后，数据传输完毕，不再有数据传输，即非活动连接的超时时间
 timeout server 300s #定义haproxy与后台服务器非活动连接的超时时间
 timeout http-keep-alive 10s #默认新的http请求建立连接的超时时间，时间较短时可以尽快释放出资源，节约资源。和http-request配合使用
 timeout check 10s #健康检测的时间的最大超时时间
 maxconn 20000 #最大连接数

listen stats :9000
 mode http
 stats enable
 stats uri /

frontend atomic-openshift-api
 bind *:8443
 default_backend atomic-openshift-api
 mode tcp #在此模式下，客户端和服务器端之前将建立一个全双工的连接，不会对七层（http）报文做任何检查
 option tcplog

backend atomic-openshift-api
 balance source #是基于请求源IP的算法，此算法对请求的源IP时行hash运算，然后将结果除以后端服务器的权重总和，来判断转发至哪台后端服务器，这种方法可保证同一客户端IP的请求始终转发到固定定的后端服务器。
 mode tcp
 server master0 192.168.56.100:8443 check
 server master1 192.168.56.101:8443 check
 server master2 192.168.56.102:8443 check
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="http://cbonte.github.io/haproxy-dconv/1.5/configuration.html"&gt;官方文档&lt;/a&gt;介绍的非常详细，感兴趣的可以继续深入研究&lt;/p&gt;</description></item><item><title>fabric-示例集群化操作</title><link>https://xiaoping378.github.io/docs/5-blockchain/frabic-%E7%A4%BA%E4%BE%8B%E9%9B%86%E7%BE%A4%E5%8C%96%E6%93%8D%E4%BD%9C/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/frabic-%E7%A4%BA%E4%BE%8B%E9%9B%86%E7%BE%A4%E5%8C%96%E6%93%8D%E4%BD%9C/</guid><description>&lt;p&gt;fabric给出的cc样例都是跑在docker-compose上，这里介绍利用已有的docker-compose.yaml如何集群化运行。&lt;/p&gt;
&lt;h3 id="准备样例cc"&gt;准备样例CC&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%87%e6%a0%b7%e4%be%8bcc" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以官方&lt;code&gt;fabric-samples&lt;/code&gt;项目里的balance-transfer为例，准备拆分运行在4个虚机里。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git clone https://github.com/hyperledger/fabric-samples.git
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;cd&lt;/span&gt; fabric-samples/balance-transfer
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;本CC的示例，主要由3个部分组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 CAs&lt;/li&gt;
&lt;li&gt;1 SOLO orderer&lt;/li&gt;
&lt;li&gt;4 peers (2 peers per Org)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中&lt;code&gt;artifacts&lt;/code&gt;目录里放置了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由 &lt;strong&gt;cryptogen&lt;/strong&gt; 工具生成的证书信息，后面运行时需要挂载到各自的peer节点里&lt;/li&gt;
&lt;li&gt;由 &lt;strong&gt;configtxgen&lt;/strong&gt; 工具生成的初始块 &lt;code&gt;genesis.block&lt;/code&gt; 和 channel配置信息&lt;code&gt;mychannell.tx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="准备集群"&gt;准备集群&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%87%e9%9b%86%e7%be%a4" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;根据上面的情况，下面准备四个虚机来集群化操作, 虚机规划信息如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;air13, 192.168.10.78, 运行ca1，ca2, 这是我的本机&lt;/li&gt;
&lt;li&gt;node0, 192.168.10.110, 运行orderer&lt;/li&gt;
&lt;li&gt;node1, 192.168.10.114, 运行org1的peer0、peer1&lt;/li&gt;
&lt;li&gt;node2, 192.168.10.115, 运行org2的peer0、peer1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个虚机都预先安装docker和docker-compose&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;artifacts/docker-compose.yaml&lt;/code&gt;文件，在每个service下添加如下信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#008000;font-weight:bold"&gt;extra_hosts&lt;/span&gt;:&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;- &lt;span style="color:#b44"&gt;&amp;#34;ca.org1.example.com:192.168.10.78&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;- &lt;span style="color:#b44"&gt;&amp;#34;ca.org2.example.com:192.168.10.78&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;- &lt;span style="color:#b44"&gt;&amp;#34;orderer.example.com:192.168.10.110&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;- &lt;span style="color:#b44"&gt;&amp;#34;peer0.org1.example.com:192.168.10.114&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;- &lt;span style="color:#b44"&gt;&amp;#34;peer1.org1.example.com:192.168.10.114&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;- &lt;span style="color:#b44"&gt;&amp;#34;peer0.org2.example.com:192.168.10.115&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;- &lt;span style="color:#b44"&gt;&amp;#34;peer1.org2.example.com:192.168.10.115&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此举的作用是在每个容器的&lt;code&gt;/etc/hosts&lt;/code&gt;文件里，添加上面的映射，最终docker-compose.yaml文件放置&lt;a href="https://gist.github.com/xiaoping378/8ba8e796552e27277073e56cfd7b281a"&gt;gist&lt;/a&gt;上了.&lt;/p&gt;
&lt;p&gt;最后一步，因为此CC样例运行时，需要挂载本地目录里一些提前生成好的证书，我们还需要把这么需要挂载的东西，同步到每个虚机里，如下操作：&lt;/p&gt;</description></item><item><title>Casbin的权限管理解读</title><link>https://xiaoping378.github.io/docs/3-devops/8-casbin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/8-casbin/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;项目一般都要包含权限管理功能，或集成IAM，或自身实现。本文介绍一个强大、高效的开源访问控制框架--Casbin。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="基本介绍"&gt;基本介绍&lt;a class="td-heading-self-link" href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Casbin的由来，是出自开源作者&lt;code&gt;罗杨&lt;/code&gt;的一篇论文&lt;a href="https://arxiv.org/abs/1903.09756"&gt;《PML：一种基于Interpreter的Web服务访问控制策略语言》&lt;/a&gt;，该论文的主要摘要如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了保护云资源的安全,防止数据泄露和非授权访问,必须对云平台的资源访问实施访问控制.然而,目前主流云平台通常采用自己的安全策略语言和访问控制机制,从而造成两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（1）云用户若要使用多个云平台,则需要学习不同的策略语言,分别编写安全策略;&lt;/li&gt;
&lt;li&gt;（2）云服务提供商需要自行设计符合自己平台的安全策略语言及访问控制机制,开发成本较高.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对此,提出一种基于元模型的访问控制策略描述语言PML及其实施机制PML-EM. PML支持表达BLP、RBAC、ABAC等访问控制模型.
PML-EM实现了3个性质:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;策略语言无关性&lt;/li&gt;
&lt;li&gt;访问控制模型无关性&lt;/li&gt;
&lt;li&gt;程序设计语言无关性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从而降低了用户编写策略的成本与云服务提供商开发访问控制机制的成本. 在OpenStack云平台上实现了PML-EM机制.实验结果表明,PML策略支持从其他策略进行自动转换,
在表达云中多租户场景时具有优势.性能方面,与OpenStack原有策略相比,PML策略的评估开销为4.8%.PML-EM机制的侵入性较小,与云平台原有代码相比增加约0.42%.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前Casbin的权限策略管理支持主流的&lt;strong&gt;ACL、RBAC、ABAC&lt;/strong&gt;、RESTful等模型，实现的编程语言主要有Go、java、Nodejs、PHP、Python、.Net、C++、Rust等。目前Go和Java的实现最为全面。&lt;/p&gt;
&lt;p&gt;先介绍下主流的访问控制模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ACL（access control list）&lt;/em&gt;：是一种与访问对象关联的权限列表，在基础设施领域应用非常广泛：
&lt;ul&gt;
&lt;li&gt;文件系统：用户（组）对文件或进程等的访问权限控制&lt;/li&gt;
&lt;li&gt;网络：常见的有防火墙（安全组、路由器、交换机）内的对目的IP和端口的规则控制&lt;/li&gt;
&lt;li&gt;SQL：库、表的权限管理&lt;/li&gt;
&lt;li&gt;&lt;a href="../openldap%E4%B9%8B%E6%8B%A8%E4%BA%91%E5%8E%BB%E6%97%A5"&gt;LDAP&lt;/a&gt;：层级结构的实体权限管理：网络域权限管理...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RBAC（role-based access control）&lt;/em&gt;：基于角色的权限控制，围绕角色和权限定义的策略中立的访问控制机制，和组ACL等价，具体表现为在用户和权限之间加了一层角色，先建立具有某种权限的角色，然后用角色和用户绑定，目前多用于管控类业务系统的权限管理，还支持支持角色权限继承。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ABAC（Attribute-based access control）&lt;/em&gt;：基于属性的权限控制，属性可以是用户侧（所属组织、访问IP、访问时间）或资源侧（帖子的评论开关、留言再编辑）的，因为用户或资源的属性是动态的，不像前面两个(需要预先定义好策略，略显死板,,,）被称为是“下一代”的权限模型，可以实现更多元化的策略策略，比如
&lt;ul&gt;
&lt;li&gt;限制用户在什么固定时间段才可以编辑自己的帖子&lt;/li&gt;
&lt;li&gt;用户只能修改自己项目下的某些资源等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和Casbin结合，使用的基本示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/Casbin-%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio.png" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1-2为管理人员下发权限策略&lt;/li&gt;
&lt;li&gt;3-6为用户日常操作资源的简易流程，实际应用场景一般如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-plantuml" data-lang="plantuml"&gt;@startuml
!theme aws-orange
用户 -&amp;gt; 认证中心: 登录操作
认证中心 -&amp;gt; 缓存: 存放(key=token+ip,value=token)token
用户 &amp;lt;- 认证中心 : 认证成功返回token
用户 -&amp;gt; 认证中心: 下次访问头部携带token认证
认证中心 &amp;lt;- 缓存: key=token+ip获取token
Casbin &amp;lt;- 认证中心: 存在且校验成功,则进入授权校验
Casbin -&amp;gt; 其他服务: 权限合规，则跳转到用户请求的其他服务
其他服务 -&amp;gt; 用户: 信息
@enduml
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="抽象模型"&gt;抽象模型&lt;a class="td-heading-self-link" href="#%e6%8a%bd%e8%b1%a1%e6%a8%a1%e5%9e%8b" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;正如上面提到的，要支持这么多的权限模型，，所以Casbin基于开头提到的PML（PERM modeling language）引入一种抽象的元模型控制，其中&lt;strong&gt;PERM&lt;/strong&gt;是指的&lt;strong&gt;Policy, Effect, Request, Matchers&lt;/strong&gt;，具体工作流如下：&lt;/p&gt;</description></item><item><title>镜像管理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</guid><description>&lt;p&gt;刚接触docker时，第一个接触到的应该就是镜像了，docker之所以如此火热，个人认为一大部分原因就是这个镜像的提出，极大的促进了DevOps推广和软件复用的能力。&lt;/p&gt;
&lt;p&gt;而openshift对镜像的管理非常强大，直到写这篇blog，我才真正意识到这点，甚至犹豫是不是要放到开发实战篇后再来写&lt;code&gt;镜像管理&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;简要说下openshift里使用镜像的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先openshift可以利用任何实现了&lt;code&gt;Docker registry API&lt;/code&gt;的镜像仓，比如，Vmware的Harbor项目，Docker hub以及集成镜像仓（ integrated registry）&lt;/li&gt;
&lt;li&gt;集成镜像仓，openshift内部的，可以动态生成，自动让用户编译的镜像有地方存， 其次它还负责通知openshift镜像的变动，然后openshift会根据策略去决定编译其他依赖镜像还是部署应用&lt;/li&gt;
&lt;li&gt;第三方镜像， 可通过命令&lt;code&gt;oc import-image &amp;lt;stream&amp;gt;&lt;/code&gt;来实时获取镜像tag信息并转换成镜像流，继而触发后续的编译或者部署。&lt;/li&gt;
&lt;li&gt;当然&lt;code&gt;oc new-app&lt;/code&gt;也支持直接从第三方镜像仓或者本地镜像里启动一个应用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文末有安装集成镜像仓的说明，先介绍image Streams 和 istag的概念和应用场景。&lt;/p&gt;
&lt;h2 id="镜像管理"&gt;镜像管理&lt;a class="td-heading-self-link" href="#%e9%95%9c%e5%83%8f%e7%ae%a1%e7%90%86" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;openshift基于docker的image概念又延伸出了Image Streams和Image Stream Tags概念&lt;/p&gt;
&lt;p&gt;默认openshift项目下会有一些镜像流，是供自带模板里用的，所以想加速部署模板的话，可以在改这里，通过istag指向本地镜像仓。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc get is -n openshift
oc get istag -n openshift
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;image，通俗讲就是对应用运行依赖（库，配置，运行环境）的一个打包。&lt;code&gt;docker pull push&lt;/code&gt;， 就是操作的镜像。
为什么openshift还要抽象出is和istag呢，主要是为了打通集成编译和部署环节（bc和dc），原生API就支持了DevOps理念。后面会细讲bc和dc&lt;/p&gt;
&lt;p&gt;is,开发人员可以理解成git的分支，每个分支都会编译很多临时版本出来，这个就是对应到is～=分支和istag～=版本号。
其实is和istag只是记录了一些映射关系，并不会存放实际镜像数据，比如is里记录了build后要output的镜像仓地址和所有tags，而istag里又记录了具体某个tag与image（可能是存于外部镜像仓，也能是某个is）的关系， 利用此实现了bc/dc和镜像的解耦。&lt;/p&gt;
&lt;p&gt;这里通过部署jenkins服务，来初步了解下具体的含义,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建ci项目&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc new-project ci
# 先拉取必要镜像
docker pull openshift/jenkins-1-centos7

#通过模板部署，下面一条命令就可以创建一个临时的jenkins服务的
#oc new-app jenkins-ephemeral
#跑之前我们先来注意几点
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;更改默认的is&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先来查看默认的is&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc get template jenkins-ephemeral -n openshift -o json
...
&amp;#34;triggers&amp;#34;: [
 {
 &amp;#34;imageChangeParams&amp;#34;: {
 &amp;#34;automatic&amp;#34;: true,
 &amp;#34;containerNames&amp;#34;: [
 &amp;#34;jenkins&amp;#34;
 ],
 &amp;#34;from&amp;#34;: {
 &amp;#34;kind&amp;#34;: &amp;#34;ImageStreamTag&amp;#34;,
 &amp;#34;name&amp;#34;: &amp;#34;${JENKINS_IMAGE_STREAM_TAG}&amp;#34;,
 &amp;#34;namespace&amp;#34;: &amp;#34;${NAMESPACE}&amp;#34;
 },
 &amp;#34;lastTriggeredImage&amp;#34;: &amp;#34;&amp;#34;
 },
 &amp;#34;type&amp;#34;: &amp;#34;ImageChange&amp;#34;
 },
 {
 &amp;#34;type&amp;#34;: &amp;#34;ConfigChange&amp;#34;
 }
 ]
...
{
 &amp;#34;name&amp;#34;: &amp;#34;NAMESPACE&amp;#34;,
 &amp;#34;displayName&amp;#34;: &amp;#34;Jenkins ImageStream Namespace&amp;#34;,
 &amp;#34;description&amp;#34;: &amp;#34;The OpenShift Namespace where the Jenkins ImageStream resides.&amp;#34;,
 &amp;#34;value&amp;#34;: &amp;#34;openshift&amp;#34;
},
{
 &amp;#34;name&amp;#34;: &amp;#34;JENKINS_IMAGE_STREAM_TAG&amp;#34;,
 &amp;#34;displayName&amp;#34;: &amp;#34;Jenkins ImageStreamTag&amp;#34;,
 &amp;#34;description&amp;#34;: &amp;#34;Name of the ImageStreamTag to be used for the Jenkins image.&amp;#34;,
 &amp;#34;value&amp;#34;: &amp;#34;jenkins:latest&amp;#34;
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到默认模板里部署jenkins时，会从openshfit的namespace里拉取jenkins:latest的镜像, 去openshift项目里找找看，确实存在对应的is&lt;/p&gt;</description></item><item><title>farbic-区块链的生产集群化</title><link>https://xiaoping378.github.io/docs/5-blockchain/farbic%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E9%9B%86%E7%BE%A4%E5%8C%96-kubernetes%E5%AE%9E%E6%88%98/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/5-blockchain/farbic%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E9%9B%86%E7%BE%A4%E5%8C%96-kubernetes%E5%AE%9E%E6%88%98/</guid><description>&lt;p&gt;默认社区的demo是基于docker-compose给出的，达到了“一键部署”的效果，但生产上考虑多节点的情况，还需要费些手脚，这里考虑用kompose结合k8s来做这件事。&lt;/p&gt;
&lt;h3 id="k8s集群-1-7的初始化"&gt;k8s集群 1.7的初始化&lt;a class="td-heading-self-link" href="#k8s%e9%9b%86%e7%be%a4-1-7%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;每个节点都要安装docker的步骤，此处略过不表，这里主要介绍利用kubeadm初始化k8s集群，这里不考虑k8s集群本身的高可用，以前有文章专门介绍过。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;apt-get update &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install -y apt-transport-https
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cat &lt;span style="color:#b44"&gt;&amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;deb http://apt.kubernetes.io/ kubernetes-xenial main
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;apt-get update
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;apt-get install -y kubelet kubeadm
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 默认会自动安装这些包 ebtables kubeadm kubectl kubelet kubernetes-cni socat&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你本机是centos的话，可以用如下命令安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cat &lt;span style="color:#b44"&gt;&amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;[kubernetes]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;name=Kubernetes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;enabled=1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;gpgcheck=1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;repo_gpgcheck=1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt; https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;setenforce &lt;span style="color:#666"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;yum install -y kubelet kubeadm
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;systemctl &lt;span style="color:#a2f"&gt;enable&lt;/span&gt; kubelet &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start kubelet
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的命令，需要翻墙才能跑通，没条件的可以去&lt;a href="https://github.com/kubernetes/release"&gt;release项目&lt;/a&gt;自己编译deb包或者rpm包，如下运行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git clone https://github.com/kubernetes/release.git &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style="color:#a2f"&gt;cd&lt;/span&gt; release
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# debian系如下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;docker build --tag&lt;span style="color:#666"&gt;=&lt;/span&gt;debian-packager debian
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;docker run --volume&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;$(&lt;/span&gt;&lt;span style="color:#a2f"&gt;pwd&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;)&lt;/span&gt;&lt;span style="color:#b44"&gt;/debian:/src&amp;#34;&lt;/span&gt; debian-packager
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# docker run -e &amp;#34;HTTPS_PROXY=127.0.0.1:8118&amp;#34; --net=host --volume=&amp;#34;$(pwd)/debian:/src&amp;#34; debian-packager&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 默认debs包在目录debian/bin/stable/xenial下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# centos系的如下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;cd&lt;/span&gt; rpm
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;./docker-build.sh
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;#默认rpm包在目录output/x86_64/下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;必要依赖搞到手后，就可以简单的利用kubeadm启动集群了
在master节点上如下执行初始化，此过程会启动 etcd，controller-manager，scheduler，api-server组件&lt;/p&gt;</description></item><item><title>Windows Terminal终端入坑指南</title><link>https://xiaoping378.github.io/docs/3-devops/9-windows-terminal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/9-windows-terminal/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;为了这个东西，重新安装了系统，目前是在windows LTSC 2021版本下的使用指南。
在IT界Terminal和Console差不多是一个意思，同属于界面层面的，不少人老和Shell搞混了，特此说明下Shell一般是指的Bash、zsh、PowerShell、cmd等。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="安装"&gt;安装&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为了使用Windows Terminal，在春节期间，重新安装了LTSC 2021版本的系统（之前一直用的LTSC 2019）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它对操作系统内部版本的最低要求为 &lt;code&gt;18362.0&lt;/code&gt;，通过&lt;code&gt;Win+R&lt;/code&gt;输入&lt;code&gt;winver&lt;/code&gt;可以确认本机系统是否支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前有三种办法安装（本人选用的第二种）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是在应用商店中搜索&lt;code&gt;Windows Terminal&lt;/code&gt;，安装即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;a href="https://github.com/microsoft/terminal/releases"&gt;Github release&lt;/a&gt;页面下载安装包，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-powershell" data-lang="powershell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;Add-AppxPackage&lt;/span&gt; Microsoft.WindowsTerminal_&amp;lt;versionNumber&amp;gt;.msixbundle
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;通过命令行&lt;a href="https://github.com/microsoft/winget-cli"&gt;winget&lt;/a&gt;、&lt;a href="https://chocolatey.org/"&gt;Chocolatey &lt;/a&gt;、&lt;a href="https://scoop.sh/"&gt;Scoop &lt;/a&gt;安装，下面以winget为例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-powershell" data-lang="powershell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;winget install --id=Microsoft.WindowsTerminal -e
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="配置"&gt;配置&lt;a class="td-heading-self-link" href="#%e9%85%8d%e7%bd%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;现在基本可以图形界面配置了，按照自己的习惯图形操作即可，网上一坨坨的教程，此处不表。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/windows-terminal-2022-01-30-12-53-50.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;默认配置保存在了&lt;code&gt;%LOCALAPPDATA%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="技巧"&gt;技巧&lt;a class="td-heading-self-link" href="#%e6%8a%80%e5%b7%a7" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;快捷键
&lt;ul&gt;
&lt;li&gt;新建终端 -- &lt;code&gt;Ctrl+Shift+t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;切换终端 -- &lt;code&gt;Alt + Num&lt;/code&gt; , （我这里修改过了）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Quake窗口
&lt;ul&gt;
&lt;li&gt;快捷键是&lt;strong&gt;Win + `&lt;/strong&gt; , 可以快速从屏幕上半区换出终端窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="gitbash"&gt;GitBash&lt;a class="td-heading-self-link" href="#gitbash" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/windows-terminal-2022-01-30-23-03-08.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;本人环境&lt;code&gt;VSCode&lt;/code&gt;和&lt;a href="https://git-scm.com/download/win"&gt;git-bash&lt;/a&gt;都是绿色版本了，免去了每次重装系统，都进行各种重复的配置操作.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有环境的可以自行通过上面的连接下载GitBash，后面有时间会尝试下&lt;code&gt;WSL&lt;/code&gt;和WSL2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="中文乱码"&gt;中文乱码&lt;a class="td-heading-self-link" href="#%e4%b8%ad%e6%96%87%e4%b9%b1%e7%a0%81" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;需要添加环境变量到&lt;code&gt;~/.bashrc&lt;/code&gt;或者&lt;code&gt;~/.zshrc&lt;/code&gt;中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;export&lt;/span&gt; &lt;span style="color:#b8860b"&gt;LANG&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;zh_CN.UTF-8
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="绿色改造"&gt;绿色改造&lt;a class="td-heading-self-link" href="#%e7%bb%bf%e8%89%b2%e6%94%b9%e9%80%a0" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;绿色改造的核心，一个是安装时不默认安装在C盘，另一个就是设置&lt;code&gt;HOME&lt;/code&gt;的系统环境变量，Git-Bash每次启动是可以根据&lt;code&gt;HOME&lt;/code&gt;变量，决定加载配置的路径的。&lt;/p&gt;</description></item><item><title>MaaS服务-强悍的gpustack介绍</title><link>https://xiaoping378.github.io/docs/7-ai/10-maas-gpustack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/7-ai/10-maas-gpustack/</guid><description>&lt;h1 id="maas服务-强悍的gpustack介绍"&gt;MaaS服务-强悍的gpustack介绍&lt;a class="td-heading-self-link" href="#maas%e6%9c%8d%e5%8a%a1-%e5%bc%ba%e6%82%8d%e7%9a%84gpustack%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;快速搭建私有MaaS平台并提供生产级的模型服务&lt;/p&gt;
&lt;pre class="mermaid"&gt;sequenceDiagram
 autonumber
 Docsy user-&amp;gt;&amp;gt;Discussion board: Ask question
 Discussion board-&amp;gt;&amp;gt;Community member: read question
 loop Different strategies
 Community member-&amp;gt;&amp;gt;Test instance: Investigate issue raised
 end
 Note right of Community member: After hours of investigation:
 Test instance--&amp;gt;&amp;gt;Community member: Come up with solution
 Community member--&amp;gt;&amp;gt;Discussion board: Propose solution
 Discussion board--&amp;gt;&amp;gt;Docsy user: check proposed solution
 Docsy user-&amp;gt;&amp;gt;Discussion board: Mark question as resolved
 Docsy user-&amp;gt;&amp;gt;Docsy user: Being happy&lt;/pre&gt;
&lt;p&gt;快速搭建私有MaaS平台并提供生产级的模型服务&lt;/p&gt;</description></item><item><title>Golang单仓monorepo协作的设计与实践</title><link>https://xiaoping378.github.io/docs/3-devops/10-golang-monorepo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/10-golang-monorepo/</guid><description>&lt;h2 id="什么是monorepo"&gt;什么是monorepo&lt;a class="td-heading-self-link" href="#%e4%bb%80%e4%b9%88%e6%98%afmonorepo" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;多代码仓合一就是nomorepo，目前在前端领域比较火热，国外大厂如Google、Facebook、Microsoft内也在公司级采用此模式，国内的浮躁，是个项目就上微服务架构的现状，导致代码仓动辄就上几十个，感觉也适合此模式。这东西说起来简单，实际运转起来，需要相应的支撑工具，如代码仓管理、CI/CD适配等，本文主要设计一套可行的方案及记录实践关键过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里说下背景：为什么要研究这个，最近接手一个项目，发现团队积累几乎没有、需求响应进度慢、新成员接手难度大，另外该项目竟然有上百个仓库，哪些和线上正在运行的服务对应，也没有说明，，，相应的协作管理手段也薄弱，总之就是乱，。个人是信服&lt;code&gt;康威定律&lt;/code&gt;（组织沟通方式会通过系统设计表达出来，反之亦成立）的，所以打算尝试下单仓的协作模式，一来可以梳理下以前的需求实现，二来促进组员交流沟通，制定些开发规范和统一框架之类的也好落地。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="代码目录结构"&gt;代码目录结构&lt;a class="td-heading-self-link" href="#%e4%bb%a3%e7%a0%81%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="codeowners机制"&gt;CODEOWNERS机制&lt;a class="td-heading-self-link" href="#codeowners%e6%9c%ba%e5%88%b6" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="ci-cd机制"&gt;CI/CD机制&lt;a class="td-heading-self-link" href="#ci-cd%e6%9c%ba%e5%88%b6" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="工具实践lighthouse"&gt;工具实践&lt;code&gt;Lighthouse&lt;/code&gt;&lt;a class="td-heading-self-link" href="#%e5%b7%a5%e5%85%b7%e5%ae%9e%e8%b7%b5lighthouse" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;</description></item><item><title>解读Consul</title><link>https://xiaoping378.github.io/docs/4-cloud/%E8%A7%A3%E8%AF%BBconsu-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/%E8%A7%A3%E8%AF%BBconsu-01/</guid><description>&lt;h2 id="概述"&gt;概述&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%bf%b0" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;介绍现在的Consul前，有必要先介绍下&lt;code&gt;Service Mesh&lt;/code&gt;的概念，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service Mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Service Mesh是一种面向服务间安全通信的基础设施层，俗称代理服务的东西向流量。 典型的实现包含控制面板和数据面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制面：跟踪记录所有的服务和访问地址，提供服务发现、健康检查、策略管理等。&lt;/li&gt;
&lt;li&gt;数据面：通过sidcar机制代理服务间的通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;传统 vs 微服务优势 :&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单体 -&amp;gt; 微服务架构&lt;/li&gt;
&lt;li&gt;函数调用 -&amp;gt; 服务发现（熔断、健康检查）&lt;/li&gt;
&lt;li&gt;配置文件 -&amp;gt; 配置中心&lt;/li&gt;
&lt;li&gt;防火墙 -&amp;gt; 访问策略&lt;/li&gt;
&lt;li&gt;DMZ、生产区 -&amp;gt; 零信任&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Consul&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consul是Service mesh中的控制面的实现，主要有一下几大特色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务发现：分为注册服务、发现服务、健康检查三大功能。&lt;/li&gt;
&lt;li&gt;K-V存储：&lt;a href="https://github.com/etcd-io/bbolt"&gt;BoltDB&lt;/a&gt;，支持 ACID 事务、无锁并发事务 MVCC，提供 B+Tree 索引。&lt;/li&gt;
&lt;li&gt;多数据中心：多中心Gossip数据同步&lt;/li&gt;
&lt;li&gt;Servie Mesh: 利用sidecar机制实现了端到端的认证和加密通信&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="部署架构"&gt;部署架构&lt;a class="td-heading-self-link" href="#%e9%83%a8%e7%bd%b2%e6%9e%b6%e6%9e%84" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;下图为经典的多中心consul集群配置。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/%E8%A7%A3%E8%AF%BBconsu-01-2022-02-16-15-57-53.png" alt=""&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个datacenter，都有N个Server和M个Client节点。因为网络延迟对Consul分布式一致性的性能影响，会出现节点越多，共识越慢的现象，server节点一般推荐为3~5个，但client节点没有限制。&lt;/li&gt;
&lt;li&gt;Client主要充当DNS server、负载均衡和健康检查的作用。&lt;/li&gt;
&lt;li&gt;Server实现数据的分布式存储一致性，一般用来存储节点状态、注册的服务信息、应用配置、通信策略等。&lt;/li&gt;
&lt;li&gt;Consul在选主和数据事务中都使用了Raft算法，但是其WAN(多个数据中心间)、LAN(节点间)通信、故障广播使用了Gossip算法（流行病协议）。&lt;/li&gt;
&lt;li&gt;在单集群内，Consul server默认的Follower节点收到读写请求后，会转发给Leader处理&lt;/li&gt;
&lt;li&gt;若查询的服务不在本集群，本地的Leader转发给远程集群的Leader处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="运维高可用管理"&gt;运维高可用管理&lt;a class="td-heading-self-link" href="#%e8%bf%90%e7%bb%b4%e9%ab%98%e5%8f%af%e7%94%a8%e7%ae%a1%e7%90%86" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目前分布式系统的高可靠实现，均受限于&lt;strong&gt;CAP&lt;/strong&gt;（一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance））理论，根据不同业务场景的会采取三者之间的平衡取舍。本文的Consul是采用Raft算法来实现的，采用此算法的还有EverDB、RocketDB、Etcd、Kafka3等系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Raft算法状态机&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/%E8%A7%A3%E8%AF%BBconsu-01-2022-02-16-14-50-29.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;主要有三种状态&lt;code&gt;Follower&lt;/code&gt;、&lt;code&gt;Candidate&lt;/code&gt;和&lt;code&gt;Leader&lt;/code&gt;，其中值得关注有以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次启动后，默认进入为&lt;code&gt;Follower&lt;/code&gt;，经过随机时间（Election Time）后，进入&lt;code&gt;Candidate&lt;/code&gt;状态，发起投票流程。&lt;/li&gt;
&lt;li&gt;收到大多数节点投票，可以成为&lt;code&gt;Leader&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非拜占庭环境，每进行一次选举，选举周期Term就回自加1，默认大家都遵从term高的节点&lt;/li&gt;
&lt;li&gt;选主成功后，Leader会发起心跳保活&lt;/li&gt;
&lt;li&gt;Follower可以根据CAP相性调整，一般是收到请求后转发给Leader处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情可查看&lt;a href="http://thesecretlivesofdata.com/raft/"&gt;动画&lt;/a&gt;展示。&lt;/p&gt;</description></item><item><title>解读Kafka</title><link>https://xiaoping378.github.io/docs/4-cloud/kafka-0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/kafka-0/</guid><description/></item><item><title>Agent智能体开发平台-BiSheng</title><link>https://xiaoping378.github.io/docs/7-ai/20-agent-bisheng/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/7-ai/20-agent-bisheng/</guid><description/></item><item><title>k3s实践-01</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/k3s-%E5%BC%80%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/k3s-%E5%BC%80%E7%AF%87/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;本文主要介绍k3s的安装和核心组件解读。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;k3s是all-in-one的轻量k8s发行版，把所有k8s组件打包成一个不到100M的二进制文件了。具备如下显著特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包成单一二进制&lt;/li&gt;
&lt;li&gt;默认集成了sqlite3来替代etcd，也可以指定其他数据库：etcd3、mysql、postgres。&lt;/li&gt;
&lt;li&gt;默认内置Coredns、Metrics Server、Flannel、Traefik ingress、Local-path-provisioner等&lt;/li&gt;
&lt;li&gt;默认启用了TLS加密通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="安装"&gt;安装&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;官方提供了一键安装脚本&lt;a href="https://get.k3s.io"&gt;install.sh&lt;/a&gt; ，执行&lt;code&gt;curl -sfL https://get.k3s.io | sh -&lt;/code&gt;可一键安装server端。此命令会从&lt;code&gt;https://update.k3s.io/v1-release/channels/stable&lt;/code&gt;取到最新的稳定版安装，可以通过&lt;code&gt;INSTALL_K3S_VERSION&lt;/code&gt;环境变量指定版本，本文将以1.19为例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动 k3s server端(master节点).&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;curl -sfL https://get.k3s.io | &lt;span style="color:#b8860b"&gt;INSTALL_K3S_VERSION&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;v1.19.16+k3s1 sh -
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;由于网络原因，可能会失败，自行想办法&lt;a href="https://github.com/k3s-io/k3s/releases/download/v1.19.16&amp;#43;k3s1/k3s"&gt;下载&lt;/a&gt;下来，放置 &lt;code&gt;/usr/local/bin/k3s&lt;/code&gt;，附上执行权限&lt;code&gt;chmod a+x /usr/local/bin/k3s&lt;/code&gt;, 然后上面的命令加上&lt;code&gt;INSTALL_K3S_SKIP_DOWNLOAD=true&lt;/code&gt;再执行一遍即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;安装里log里会输出一些重要信息: &lt;code&gt;kubectl、crictl、卸载脚本、systemd service&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不出意外，k3s server会被systemd启动，执行命令查看&lt;code&gt;systemctl status k3s&lt;/code&gt;或者通过软链的kubectl验证是否启动成功：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ kubectl get no
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;NAME STATUS ROLES AGE VERSION
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;gitlab-server Ready master 6m43s v1.19.16+k3s1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;(Optional)&lt;/strong&gt; 启动 k3s agent端 (添加worker节点).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;curl -sfL https://get.k3s.io | &lt;span style="color:#b8860b"&gt;K3S_URL&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;https://172.25.11.130:6443 &lt;span style="color:#b8860b"&gt;K3S_TOKEN&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;bulabula &lt;span style="color:#b8860b"&gt;INSTALL_K3S_VERSION&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;v1.19.16+k3s1 sh -
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;K3S_TOKEN&lt;/code&gt;内容需要从server端的&lt;code&gt;/var/lib/rancher/k3s/server/node-token&lt;/code&gt;文件取出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;K3S_URL&lt;/code&gt;中的IP是master节点的IP。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="集群访问"&gt;集群访问&lt;a class="td-heading-self-link" href="#%e9%9b%86%e7%be%a4%e8%ae%bf%e9%97%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;默认kubectl通过localhost访问本地集群，所以上文敲kubectl是没问题的，如果要被外部访问或者纳管的话，可以把kubeconfig文件拷走，默认路径是 &lt;code&gt;/etc/rancher/k3s/k3s.yaml&lt;/code&gt;
。记得修改文件内的server字段，改成外部可访问到的IP。&lt;/p&gt;</description></item><item><title>性能优化指南</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</guid><description>&lt;p&gt;主要参考的官方&lt;a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/3.5/html-single/scaling_and_performance_guide/"&gt;链接&lt;/a&gt;， 本文是基于openshift 3.5说的。&lt;/p&gt;
&lt;h2 id="概览"&gt;概览&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%a7%88" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本指南提供了如何提高OpenShift容器平台的集群性能和生产环境下的最佳实践。 主要包括建立，扩展和调优OpenShift集群的推荐做法。&lt;/p&gt;
&lt;p&gt;个人看法，其实性能这个东西是个权衡的过程，根据自身硬件条件和实际需求，选择适合自己的调优手段。&lt;/p&gt;
&lt;h2 id="安装实践"&gt;安装实践&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85%e5%ae%9e%e8%b7%b5" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="网络依赖"&gt;网络依赖&lt;a class="td-heading-self-link" href="#%e7%bd%91%e7%bb%9c%e4%be%9d%e8%b5%96" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;首先安装自然要选择官方的&lt;a href="https://github.com/openshift/openshift-ansible"&gt;openshift-ansible项目&lt;/a&gt;， 默认是rpm安装方式，需要依赖网络，比如要去联网下载&lt;code&gt;atomic-openshift-*, iptables, 和 docker&lt;/code&gt;包依赖，&lt;/p&gt;
&lt;p&gt;如果有不能联网的节点，可以参考我之前写的&lt;a href="https://github.com/xiaoping378/openshift-deploy"&gt;离线安装openshift&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="ansible优化"&gt;ansible优化&lt;a class="td-heading-self-link" href="#ansible%e4%bc%98%e5%8c%96" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;官方推荐使用ansible安装，这里说下针对ansible的优化，以提高安装效率，主要参考&lt;a href="https://www.ansible.com/blog/ansible-performance-tuning"&gt;ansible官方blog&lt;/a&gt;,&lt;/p&gt;
&lt;p&gt;如果参考上文离线安装的话，不建议跨外网连接rpm仓或者镜像仓，下面是推荐的ansible配置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# cat /etc/ansible/ansible.cfg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# config file for ansible -- http://ansible.com/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# ==============================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;defaults&lt;span style="color:#666"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;forks&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;20&lt;/span&gt; &lt;span style="color:#080;font-style:italic"&gt;# 20个并发是理想值，太高的话中间会有概率出错&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;host_key_checking&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; False
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;remote_user&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; root
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;roles_path&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; roles/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;gathering&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; smart
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;fact_caching&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; jsonfile
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;fact_caching_connection&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#b8860b"&gt;$HOME&lt;/span&gt;/ansible/facts
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;fact_caching_timeout&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;600&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;log_path&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#b8860b"&gt;$HOME&lt;/span&gt;/ansible.log
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;nocows&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;callback_whitelist&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; profile_tasks
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;privilege_escalation&lt;span style="color:#666"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;become&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; False
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;ssh_connection&lt;span style="color:#666"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;ssh_args&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; -o &lt;span style="color:#b8860b"&gt;ControlMaster&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;auto -o &lt;span style="color:#b8860b"&gt;ControlPersist&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;600s
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;control_path&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; %&lt;span style="color:#666"&gt;(&lt;/span&gt;directory&lt;span style="color:#666"&gt;)&lt;/span&gt;s/%%h-%%r
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;pipelining&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; True &lt;span style="color:#080;font-style:italic"&gt;# 多路复用，减少了控制机和目标间的连接次数，加速了性能。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;timeout&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="网络配置"&gt;网络配置&lt;a class="td-heading-self-link" href="#%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里必须要提下，一定要安装前做好网络规划，不然后面改起来很麻烦，&lt;/p&gt;</description></item><item><title>TiDB初体验</title><link>https://xiaoping378.github.io/docs/3-devops/tidb/tidb-%E5%88%9D%E4%BD%93%E9%AA%8C/</link><pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/tidb/tidb-%E5%88%9D%E4%BD%93%E9%AA%8C/</guid><description>&lt;h2 id="安装"&gt;安装&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;安装环境要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mac或者单机Linux环境&lt;/li&gt;
&lt;li&gt;可以连接外网&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;执行命令安装&lt;code&gt;TiUP&lt;/code&gt;工具，官方运维管理工具。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;curl --proto &lt;span style="color:#b44"&gt;&amp;#39;=https&amp;#39;&lt;/span&gt; --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh | sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;命令会有关键信息输出:添加了证书、修改了PATH变量等，需要声明下环境变量，以使&lt;code&gt;tiup&lt;/code&gt;命令能被找到。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;声明系统环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 因个人环境，此处会有差异&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a2f"&gt;source&lt;/span&gt; ~/.zshrc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以&lt;code&gt;echo $PATH&lt;/code&gt;下，看到&lt;code&gt;/root/.tiup/bin&lt;/code&gt;被加到了最前面。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;启动单实例集群&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直接执行&lt;code&gt;tiup playground&lt;/code&gt;命令默认会运行最新版本的TiDB集群，其中TiDB Server、TiKV、PD 和 TiFlash 实例各 1 个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;tiup playground
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体如下图所示，需要另开一个终端，使用mysql发起连接：
&lt;img src="https://xiaoping378.github.io/images/github-dev-2022-02-04-16-16-18.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;目前tidb playground默认启动监听在127的地址，可以通过--host参数更改，但还不能更改端口（经查代码是写死了端口）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他可修改参数，可通过&lt;code&gt;tiup playground -h&lt;/code&gt;查看。&lt;/li&gt;
&lt;li&gt;dashboard的默认root用户没有密码，如果是公网暴露了，建议如下添加密码(我这里设置了root密码为&lt;code&gt;tidb&lt;/code&gt;):&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mysql -h127.0.0.1 -P4000 -uroot
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;alter user &lt;span style="color:#b44"&gt;&amp;#39;root&amp;#39;&lt;/span&gt; identified by &lt;span style="color:#b44"&gt;&amp;#39;tidb&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;grafana的登录密码，默认为admin/admin&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tiup update --self&lt;/code&gt;可升级tiup命令&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql客户端可通过&lt;code&gt;yum install -y mysql&lt;/code&gt;或者&lt;code&gt;apt install mysql-client&lt;/code&gt;安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="集群"&gt;集群&lt;a class="td-heading-self-link" href="#%e9%9b%86%e7%be%a4" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;没有多节点的环境，折腾了一下，要单机玩这个模式的话，需要hack的东西太多，，，目前还不建议这么搞，等有时间看能不能提个PR.&lt;/p&gt;
&lt;h2 id="tidb-server"&gt;TIDB Server&lt;a class="td-heading-self-link" href="#tidb-server" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;处理client的SQL请求.&lt;/p&gt;
&lt;h2 id="pd"&gt;PD&lt;a class="td-heading-self-link" href="#pd" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;提供全局时钟和Region调度和管理（扩缩容）。&lt;/p&gt;</description></item><item><title>k8s controllers工程化实践</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/k8s-controlelrs%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/k8s-controlelrs%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BC%80%E5%8F%91/</guid><description>&lt;h1 id="controllers工程化"&gt;controllers工程化&lt;a class="td-heading-self-link" href="#controllers%e5%b7%a5%e7%a8%8b%e5%8c%96" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="工程化的目标"&gt;工程化的目标&lt;a class="td-heading-self-link" href="#%e5%b7%a5%e7%a8%8b%e5%8c%96%e7%9a%84%e7%9b%ae%e6%a0%87" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;controller工程化的定义，建立一个可持续迭代的工程，包括但不限于以下目标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多group资源（多个controller）&lt;/li&gt;
&lt;li&gt;更改CR字段后，可无缝升级（重新生产CR和API）&lt;/li&gt;
&lt;li&gt;API文档化&lt;/li&gt;
&lt;li&gt;CR部署初始化&lt;/li&gt;
&lt;li&gt;ARM多架构编译和镜像构建&lt;/li&gt;
&lt;li&gt;单元测试覆盖率，golang-ci代码扫描。&lt;/li&gt;
&lt;li&gt;暴露关键的监控指标和事件日志&lt;/li&gt;
&lt;li&gt;高可用&lt;/li&gt;
&lt;li&gt;关注规模性能&lt;/li&gt;
&lt;li&gt;安全问题
&lt;ul&gt;
&lt;li&gt;webhook证书，统一管理&lt;/li&gt;
&lt;li&gt;组件Token权限&lt;/li&gt;
&lt;li&gt;CR幂等性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="创建一个operator"&gt;创建一个Operator&lt;a class="td-heading-self-link" href="#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aaoperator" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;利用kubebuilder初始化一个Operator，背后依赖controller-runtime和controller-gen&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir -p ~/app &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style="color:#a2f"&gt;cd&lt;/span&gt; ~/app
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubebuilder init --domain cebpaas.io --repo cebpaas.io/appmanager
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Writing kustomize manifests for you to edit...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Writing scaffold for you to edit...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Get controller runtime:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# $ go get sigs.k8s.io/controller-runtime@v0.11.2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Update dependencies:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# $ go mod tidy&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Next: define a resource with:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# $ kubebuilder create api&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;#可选命令, 本处执行的话，可省略下文的“多个controller合并”&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;#kubebuilder edit --multigroup=true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubebuilder create api --group apps --version v1 --kind Application
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Create Resource [y/n]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Create Controller [y/n]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Writing kustomize manifests for you to edit...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Writing scaffold for you to edit...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# api/v1/application_types.go&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# controllers/application_controller.go&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Update dependencies:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# $ go mod tidy&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Running make:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# $ make generate&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# mkdir -p /root/app/bin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# GOBIN=/root/app/bin go install sigs.k8s.io/controller-tools/cmd/controller-gen@v0.8.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# /root/app/bin/controller-gen object:headerFile=&amp;#34;hack/boilerplate.go.txt&amp;#34; paths=&amp;#34;./...&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# Next: implement your new API and generate the manifests (e.g. CRDs,CRs) with:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# $ make manifests&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;make manifests
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# /root/app/bin/controller-gen rbac:roleName=manager-role crd webhook paths=&amp;#34;./...&amp;#34; output:crd:artifacts:config=config/crd/bases&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="多个group-controller合并"&gt;多个group controller合并&lt;a class="td-heading-self-link" href="#%e5%a4%9a%e4%b8%aagroup-controller%e5%90%88%e5%b9%b6" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;开启多controller操作，&lt;/p&gt;</description></item><item><title>DEIS 开源PAAS平台实践</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/deis-%E5%BC%80%E6%BA%90paas%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/deis-%E5%BC%80%E6%BA%90paas%E5%B9%B3%E5%8F%B0%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</guid><description>&lt;p&gt;DEIS（目前已被微软收购）的workflow是开源的Paas平台，基于kubernetes做了一层面向开发者的CLI和接口，做到了让开发者对容器无感知的情况下快速的开发和部署线上应用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;workflow是 on top of k8s的，所有组件默认全是跑在pod里的，不像openshift那样对k8s的侵入性很大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S2I(自动识别源码直接编译成镜像)&lt;/li&gt;
&lt;li&gt;日志聚合&lt;/li&gt;
&lt;li&gt;应用管理（发布，回滚）&lt;/li&gt;
&lt;li&gt;认证&amp;amp;授权机制&lt;/li&gt;
&lt;li&gt;边界路由&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/Workflow_Detail.png" alt="Workflow_Detail"&gt;&lt;/p&gt;
&lt;p&gt;下面从环境搭建，安装workflow及其基本使用做个梳理。&lt;/p&gt;
&lt;h3 id="初始化k8s集群"&gt;初始化k8s集群&lt;a class="td-heading-self-link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96k8s%e9%9b%86%e7%be%a4" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过&lt;a href="https://github.com/xiaoping378/k8s-deploy"&gt;k8s-deploy&lt;/a&gt;项目来离线安装高可用kubernetes集群，我这里是单机演示环境。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubeadm init --kubernetes-version v1.6.2 --pod-network-cidr 12.240.0.0/12
#方便命令自动补全
source &amp;lt;(kubectl completion zsh)

#安装cni网络
cp /etc/kubernetes/admin.conf $HOME/.kube/config
kubectl apply -f kube-flannel-rbac.yml
kubectl apply -f kube-flannel.yml

#使能master可以被调度
kubectl taint node --all node-role.kubernetes.io/master-

#安装ingress-controller, 边界路由作用
kubectl create -f ingress-traefik-rbac.yml
kubectl create -f ingress-traefik-deploy.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="初始化helm"&gt;初始化helm&lt;a class="td-heading-self-link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96helm" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;helm相当于kubernetes里的包管理器，类似yum和apt的作用，只不过它操作的是charts（各种k8s yaml文件的集合，额外还有Chart.yaml -- 包的描述文件）可以理解为基于k8s的应用模板管理类工具， 后面会用它来安装workflow到上面跑起来的k8s集群里。&lt;/p&gt;
&lt;p&gt;从k8s 1.6之后，kubeadm安装的集群，默认会开启RBAC机制，为了让helm可以安装任何应用，我们这里赋予tiller cluster-admin权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create serviceaccount helm --namespace kube-system
kubectl create clusterrolebinding cluster-admin-helm --clusterrole=cluster-admin --serviceaccount=kube-system:helm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化helm：&lt;/p&gt;</description></item><item><title>网络整理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</guid><description>&lt;p&gt;介绍利用openshift-ansible项目安装后的生产环境里的网络情况。&lt;/p&gt;
&lt;p&gt;待整理。。。&lt;/p&gt;</description></item><item><title>监控梳理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%9B%91%E6%8E%A7%E6%A2%B3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%9B%91%E6%8E%A7%E6%A2%B3%E7%90%86/</guid><description>&lt;p&gt;未完搞 ...&lt;/p&gt;</description></item><item><title>日志分析</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</guid><description>&lt;p&gt;未完搞 ...&lt;/p&gt;</description></item><item><title>kubeshere 自研-01</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/kubesphere-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/kubesphere-01/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;kubesphere 自研环境篇&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="心态"&gt;心态&lt;a class="td-heading-self-link" href="#%e5%bf%83%e6%80%81" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先调整心态，这是一个新的生态，秉承学习的心态。&lt;/p&gt;
&lt;h2 id="准备环境"&gt;准备环境&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%87%e7%8e%af%e5%a2%83" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;clone代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;git clone https://github.com/kubesphere/kubesphere.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;准备开发环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/kubesphere/community/blob/master/developer-guide/development/quickstart.md"&gt;启动快速开发环境&lt;/a&gt;&lt;/p&gt;</description></item><item><title>TKEStack all-in-one入坑指南</title><link>https://xiaoping378.github.io/docs/4-cloud/k8s/tkestack-allinone/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/k8s/tkestack-allinone/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;本文主要介绍当前最新版本TkeStack 1.8.1 的TKEStack的all-in-one安装、多租户和多集群管理功能解读。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="安装实录"&gt;安装实录&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85%e5%ae%9e%e5%bd%95" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;官方推荐至少需要2节点方可安装，配置如下，&lt;strong&gt;硬盘空间&lt;/strong&gt;一定要保障。也支持ALL-in-ONE的方式安装，但有BUG。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/TKEStack-allinone-2022-01-25-08-47-30.png" alt=""&gt;&lt;/p&gt;
&lt;h2 id="启动init服务"&gt;启动init服务&lt;a class="td-heading-self-link" href="#%e5%90%af%e5%8a%a8init%e6%9c%8d%e5%8a%a1" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;启动init服务，即安装tke-installer和registry服务，安装命令行如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;arch&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;amd64 &lt;span style="color:#b8860b"&gt;version&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;v1.8.1 &lt;span style="color:#b62;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b62;font-weight:bold"&gt;&lt;/span&gt; &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; wget https://tke-release-1251707795.cos.ap-guangzhou.myqcloud.com/tke-installer-linux-&lt;span style="color:#b8860b"&gt;$arch&lt;/span&gt;-&lt;span style="color:#b8860b"&gt;$version&lt;/span&gt;.run&lt;span style="color:#666"&gt;{&lt;/span&gt;,.sha256&lt;span style="color:#666"&gt;}&lt;/span&gt; &lt;span style="color:#b62;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b62;font-weight:bold"&gt;&lt;/span&gt; &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; sha256sum --check --status tke-installer-linux-&lt;span style="color:#b8860b"&gt;$arch&lt;/span&gt;-&lt;span style="color:#b8860b"&gt;$version&lt;/span&gt;.run.sha256 &lt;span style="color:#b62;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b62;font-weight:bold"&gt;&lt;/span&gt; &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; chmod +x tke-installer-linux-&lt;span style="color:#b8860b"&gt;$arch&lt;/span&gt;-&lt;span style="color:#b8860b"&gt;$version&lt;/span&gt;.run &lt;span style="color:#b62;font-weight:bold"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b62;font-weight:bold"&gt;&lt;/span&gt; &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./tke-installer-linux-&lt;span style="color:#b8860b"&gt;$arch&lt;/span&gt;-&lt;span style="color:#b8860b"&gt;$version&lt;/span&gt;.run  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上命令执行后，会下载8G左右的安装包，并执行解压后的install.sh脚本，启动3个容器：1个为tke-installer和另2个为registry仓，且为containerd容器，需要使用&lt;code&gt;nerdctl [images | ps]&lt;/code&gt;等命令查看相关信息。&lt;/p&gt;
&lt;p&gt;通过查看脚本，上文启动的本地registry的启动命令等效如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;nerdctl run --name registry-https -d --net&lt;span style="color:#666"&gt;=&lt;/span&gt;host --restart&lt;span style="color:#666"&gt;=&lt;/span&gt;always -p 443:443 &lt;span style="color:#b62;font-weight:bold"&gt;\ &lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -v /opt/tke-installer/registry:/var/lib/registry &lt;span style="color:#b62;font-weight:bold"&gt;\ &lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -v registry-certs:/certs &lt;span style="color:#b62;font-weight:bold"&gt;\ &lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -e &lt;span style="color:#b8860b"&gt;REGISTRY_HTTP_ADDR&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;0.0.0.0:443 &lt;span style="color:#b62;font-weight:bold"&gt;\ &lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -e &lt;span style="color:#b8860b"&gt;REGISTRY_HTTP_TLS_CERTIFICATE&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;/certs/server.crt &lt;span style="color:#b62;font-weight:bold"&gt;\ &lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; -e &lt;span style="color:#b8860b"&gt;REGISTRY_HTTP_TLS_KEY&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;/certs/server.key  &lt;span style="color:#b62;font-weight:bold"&gt;\ &lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; tkestack/registry-amd64:2.7.1  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还有个http 80的registry，这里不贴了，后面的部分坑，就是这里埋下的，预先占用了节点的80和443端口，后面tke的gateway pod会启动失败。&lt;/p&gt;
&lt;h2 id="启动tke集群"&gt;启动TKE集群&lt;a class="td-heading-self-link" href="#%e5%90%af%e5%8a%a8tke%e9%9b%86%e7%be%a4" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上章节执行完后，会启动tke-installer（一个web操作台），通过访问本地8080端口，可访问界面操作安装global集群。按照官方指引操作就行，此处不表。另外需要说明的是在安装过程中，如果要查看本地容器，不能使用&lt;code&gt;docker ps&lt;/code&gt;了，需要使用&lt;code&gt;nerdctl -n k8s.io ps&lt;/code&gt;。整个安装过程是使用ansible和kubeadm完成的，kubelet是通过systemd启动的，k8s组件为静态pod。&lt;/p&gt;
&lt;p&gt;因为我是使用的ALL-in-ONE安装，遇到了不少问题，可详见FAQ如何解决。安装成功后会提示如下指引：
&lt;img src="https://xiaoping378.github.io/images/TKEStack-allinone-2022-01-25-09-10-56.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;默认初始安装后，很多pod是双副本的，我这里仅是验证功能使用，全部改成了单副本。&lt;/p&gt;
&lt;h2 id="多租户管理"&gt;多租户管理&lt;a class="td-heading-self-link" href="#%e5%a4%9a%e7%a7%9f%e6%88%b7%e7%ae%a1%e7%90%86" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;tkestack采用&lt;a href="https://xiaoping378.github.io/docs/3-devops/casbin"&gt;Casbin框架&lt;/a&gt;实现的权限管理功能，默认集成的Model，查看&lt;a href="https://github.com/tkestack/tke/blob/a024c064880d9180dc8b6d615ffc58b64bb7f903/api/auth/types.go#L633"&gt;源码&lt;/a&gt;得知：&lt;/p&gt;</description></item><item><title>Go转Java万字总结, 要跨越哪些思维鸿沟</title><link>https://xiaoping378.github.io/docs/3-devops/javaer/1-go-to-java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/javaer/1-go-to-java/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;主要介绍Go和java间的设计思想、工程目录结构、典型框架使用上的对比&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="go转java的设计思想对比"&gt;Go转Java的设计思想对比&lt;a class="td-heading-self-link" href="#go%e8%bd%acjava%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3%e5%af%b9%e6%af%94" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="alert alert-primary" role="alert"&gt;&lt;div class="h4 alert-heading" role="heading"&gt;欲速则不达&lt;/div&gt;
&lt;p&gt;先看思想差异! &lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Go的心智模式是过程式 + 轻量级面向对象 + 并发，从接需求开始，要识别结构体和关键方法，先实现小而美的功能点，再通过组合演进式地实现复杂功能。
Java不用说了，主要是以重量级OOP为主的玩法，要从需求中先找实体，加行为，定关系，用设计模式实现更复杂的业务。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不过现代Java也在拥抱轻量级设计, 而Go里也有设计模式，不过更倾于使用函数、闭包和通道等语言特性来解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先从直观语法上，总结有以下几种差异情况（只总结差异，不做优劣评价）：&lt;/p&gt;
&lt;p&gt;Go: 极简主义​ - 少即是多, Go语法中有很多隐含的写法规则，在Java里则需要编写显式的修饰符（关键字）声明，比如某结构（类）中，首字母大写，是会暴露一个字段，在java则需要显示的使用public。&lt;/p&gt;
&lt;h3 id="隐式规则与显式声明的碰撞"&gt;隐式规则与显式声明的碰撞&lt;a class="td-heading-self-link" href="#%e9%9a%90%e5%bc%8f%e8%a7%84%e5%88%99%e4%b8%8e%e6%98%be%e5%bc%8f%e5%a3%b0%e6%98%8e%e7%9a%84%e7%a2%b0%e6%92%9e" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Go的&amp;quot;命名即契约&amp;quot;哲学：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-Go" data-lang="Go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 大小写决定可见性&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;type&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;User&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;struct&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;ID&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#0b0;font-weight:bold"&gt;int&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 公开&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;name&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#0b0;font-weight:bold"&gt;string&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 私有&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;func&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;(u&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;*&lt;/span&gt;User)&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#00a000"&gt;GetName&lt;/span&gt;()&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#0b0;font-weight:bold"&gt;string&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 公开方法&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;return&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;u.name&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;func&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;(u&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;*&lt;/span&gt;User)&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#00a000"&gt;setName&lt;/span&gt;(name&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#0b0;font-weight:bold"&gt;string&lt;/span&gt;)&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 私有方法&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;u.name&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;name&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Java语法层面的&amp;quot;显式声明&amp;quot;文化：&lt;/p&gt;</description></item><item><title>AI时代下，Java该如何起手项目开发</title><link>https://xiaoping378.github.io/docs/3-devops/javaer/2-java-starter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/javaer/2-java-starter/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;30多年来，开发者工具层面终于出现了革命者，本文主要结合人工智能在软件工程领域大行其道的当下，针对从零开始和迭代已有项目，介绍如何快速开启Java项目的设计开发。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;最近常听到一句话，&lt;code&gt;AI不会替代你，但熟练使用AI的人可以轻松干废你&lt;/code&gt;。 初听有点儿耸人听闻，实际却在发生中.... 甚至斯坦福大学最近也开设了&lt;a href="https://themodernsoftware.dev/"&gt;CS146S课程&lt;/a&gt;， 要求必须使用AI完成开发任务，作业是提交完成开发任务的提示词prompt。专门教授如何将大模型和AI工具（如编程智能体、AI IDE）集成到软件开发流程中，从而大幅提升开发者的生产力，并探讨了现代软件工程师的角色演变。课程大纲如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/2-java-starter-2025-12-18-08-58-40.png" alt=""&gt;&lt;/p&gt;
&lt;h2 id="工欲善其事必先利其器"&gt;工欲善其事必先利其器&lt;a class="td-heading-self-link" href="#%e5%b7%a5%e6%ac%b2%e5%96%84%e5%85%b6%e4%ba%8b%e5%bf%85%e5%85%88%e5%88%a9%e5%85%b6%e5%99%a8" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="传统开发-必备神器idea"&gt;传统开发，必备神器IDEA&lt;a class="td-heading-self-link" href="#%e4%bc%a0%e7%bb%9f%e5%bc%80%e5%8f%91-%e5%bf%85%e5%a4%87%e7%a5%9e%e5%99%a8idea" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;下图是2025.3版本，安装包大小1G，包括java生态的大量工具插件，还内置了教学引导，默认给30天的免费旗舰试用期。
&lt;img src="https://xiaoping378.github.io/images/2-java-starter-2025-12-17-15-11-08.png" alt="启动界面"&gt;
&lt;img src="https://xiaoping378.github.io/images/2-java-starter-2025-12-17-15-57-41.png" alt="教学导引"&gt;&lt;/p&gt;
&lt;p&gt;导引学习，主要介绍一些快捷键(包括any搜索、补全建议、重构)和调试技巧等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ctrl+Shift+A或者两次Shift按键，触发anything search。&lt;/li&gt;
&lt;li&gt;Alt + Enter， 万能修复/提示&lt;/li&gt;
&lt;li&gt;Ctrl + Shift + Space​，智能代码补全&lt;/li&gt;
&lt;li&gt;Ctrl + Alt + L​，代码格式化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统IDE中，补全是当初能让其迅速普及开的功能之一，而调试也是另一个极好的功能。在现代AI IDE中，调试似乎也不需要了，直接贴错误日志，就自动开始debug纠错了。&lt;/p&gt;
&lt;h3 id="使用ai开发的现状"&gt;使用AI开发的现状&lt;a class="td-heading-self-link" href="#%e4%bd%bf%e7%94%a8ai%e5%bc%80%e5%8f%91%e7%9a%84%e7%8e%b0%e7%8a%b6" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当下主流的使用AI开发模式有3种基本形态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种是传统IDE + &lt;strong&gt;编程插件助手&lt;/strong&gt;，代表有Lingma、Continue等，是属于渐进式拥抱AI辅助开发，从而提高生产力的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一种是基于开源IDE打造的&lt;strong&gt;AI原生IDE&lt;/strong&gt;, 提供更沉浸式的AI编程体验，由AI自主完成分析、设计、编码乃至测试的完整流程，一般需要订阅收费。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;国外：Cursor（基于VS Code）&lt;/li&gt;
&lt;li&gt;国内：Trae.CN（字节）、CodeBuddy（腾讯），Qoder（阿里.新加坡团队）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一种&lt;strong&gt;终端工具&lt;/strong&gt;，代表是Claude Code、Codex CLI等，可以灵活集成到以上两种模式和其他第三方CI/CD协作流水线中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在市场参与者，基本都在布局各形态的开发场景，本文发稿时，通义lingma也在公测IDE了，CodeBuddy已实现插件、IDE、CLI三端全形态覆盖。&lt;/p&gt;
&lt;p&gt;年初我个人也结合开源vscode+roocode插件，开发过一款自己的IDE，叫&lt;code&gt;aide&lt;/code&gt;，基本功能也都具备，后面有时间可以整理发出来一篇手把手打造自己的AI原生IDE。
&lt;img src="https://xiaoping378.github.io/images/2-java-starter-2025-12-18-18-37-35.png" alt=""&gt;
&lt;img src="https://xiaoping378.github.io/images/2-java-starter-2025-12-18-18-40-54.png" alt=""&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不过github Copilot在国内市场才是比较可惜的，背靠微软（VS生态），手里有github，竟然在市场上，没有国外初创企业Cursor等的声势浩大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这几种形态，反映了一个演进方向: 将AI集成到开发工具 ====&amp;gt; 将开发工具集成到AI中。人在其中的动手参与度逐步降低，后者看上去是最理想的终极形态，合理设置后，可以让AI把整个软件交付的全流程（需求分析-&amp;gt;设计-&amp;gt;编码-&amp;gt;测试-&amp;gt;部署上线）自动完成。&lt;/p&gt;
&lt;p&gt;不过这里不应该存在谁更好的说法，最终要看你的团队运作模式，是单人全栈还是严格‘瀑布模式’下的团队模式，毕竟康威定律还在生效（技术问题的背后，往往是人的问题和组织问题）。这类AI原生IDE现在也基本支持个人版和企业版了，不过从业内的实践来看，在单人全栈模式下，AI原生IDE的优势会更明显。&lt;/p&gt;
&lt;p&gt;由于本人工作行业限制，接触最多的是lingma，不过为了客观对比更高阶的形态，这里以Trae.CN为例&lt;/p&gt;
&lt;p&gt;安装包大小204M，内置前端工具链，如涉及其他技术栈，需要自行安装插件。 支持两种模式（IDE和solo模式），就是前面提到的IDE+插件助手模式和AI原生IDE的形态。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/2-java-starter-2025-12-18-18-26-52.png" alt="启动界面"&gt;
&lt;img src="https://xiaoping378.github.io/images/2-java-starter-2025-12-18-18-31-25.png" alt="solo模式"&gt;&lt;/p&gt;
&lt;p&gt;AI原生IDE，相对传统IDE，最大的区别是在软件工程中的参与阶段左移了，从需求分析开始就可以介入了，并且以AI为主导推理，自动调度集成MCP工具来推进工作。&lt;/p&gt;
&lt;h2 id="vibe-coding-氛围-ai结对编程"&gt;Vibe Coding 氛围/AI结对编程&lt;a class="td-heading-self-link" href="#vibe-coding-%e6%b0%9b%e5%9b%b4-ai%e7%bb%93%e5%af%b9%e7%bc%96%e7%a8%8b" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="零开项目-避免重复造轮子"&gt;零开项目（避免重复造轮子）&lt;a class="td-heading-self-link" href="#%e9%9b%b6%e5%bc%80%e9%a1%b9%e7%9b%ae-%e9%81%bf%e5%85%8d%e9%87%8d%e5%a4%8d%e9%80%a0%e8%bd%ae%e5%ad%90" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;java生态已经非常丰富，几乎每个领域都有对应成熟、经过验证的开源项目，遵循专业的事情找专业的工具干的原则（寻找轮子），避免让AI从零开始重复造轮子。&lt;/p&gt;</description></item><item><title>Goper直接撸java代码，真是操碎了心，tips总结①</title><link>https://xiaoping378.github.io/docs/3-devops/javaer/3-java-tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/3-devops/javaer/3-java-tips/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;Java发展的这些年，为了复杂大型项目的工程实践能傻瓜落地，真是封了一层又一层啊，C/C++型选手转过来，会感觉各种看不透，总结了一些tips，尽量追根问底，分享给大家。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="springbootapplication-注解"&gt;@SpringBootApplication 注解&lt;a class="td-heading-self-link" href="#springbootapplication-%e6%b3%a8%e8%a7%a3" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;java spring项目，第一个看到的基本就是这个注解，只能加到main方法所在的主类上，标识这是一个Spring Boot应用程序的main入口类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@(注解)的本质是给代码打标签，告诉需要处理注解的工具或框架: 这里的代码需要特殊处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“@SpringBootApplication”注解，是个组合注解，是表示要在程序启动运行阶段被特殊处理的(其实现完全依赖于Java的反射机制)，是spring框架的核心机制，依靠Spring容器的运行时处理能力，体现了「约定优于配置」的设计思想。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没点儿Java经验，「约定优于配置」的设计思想，会让学习成本增加，但是在大型项目中，会让开发效率大大提高。
spring 容器的运行时处理能力，是实现「约定优于配置」的关键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="spring-容器"&gt;Spring 容器&lt;a class="td-heading-self-link" href="#spring-%e5%ae%b9%e5%99%a8" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;spring 容器是一个IoC容器（简单理解为一个对象工厂），用于管理应用程序中的Bean对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bean的生命周期包括：实例化、依赖注入、初始化、使用、销毁。
依赖注入是指在运行时，通过容器自动将Bean的依赖对象注入到Bean中。
初始化是指在Bean实例化后，调用Bean的初始化方法。
使用是指在Bean初始化后，通过容器获取Bean实例，调用其方法。
销毁是指在应用程序关闭时，调用Bean的销毁方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你写好代码，贴上标签（注解）&lt;/li&gt;
&lt;li&gt;容器帮你管理这些代码（Bean）&lt;/li&gt;
&lt;li&gt;你需要什么，容器就给你什么（依赖注入）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="为什么要使用-spring-容器"&gt;为什么要使用 Spring 容器？&lt;a class="td-heading-self-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-spring-%e5%ae%b9%e5%99%a8" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;理由有一堆，还都是高大上的那种....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿用户注册功能对比，举例说明，对比「不用Spring容器」和「用Spring容器」的代码差异，直观展示Spring容器的价值：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景：用户注册功能（需要3层结构）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Controller ：接收注册请求&lt;/li&gt;
&lt;li&gt;Service ：处理注册业务逻辑（密码加密、保存用户）&lt;/li&gt;
&lt;li&gt;Repository ：操作数据库（保存用户信息）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方式1：不用Spring容器 → 传统Java开发&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 1. Repository层：操作数据库&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;public&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;class&lt;/span&gt; &lt;span style="color:#00f"&gt;UserRepository&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;public&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#0b0;font-weight:bold"&gt;void&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#00a000"&gt;save&lt;/span&gt;(User&lt;span style="color:#bbb"&gt; &lt;/span&gt;user)&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;System.&lt;span style="color:#b44"&gt;out&lt;/span&gt;.&lt;span style="color:#b44"&gt;println&lt;/span&gt;(&lt;span style="color:#b44"&gt;&amp;#34;保存用户到数据库：&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;+&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;user.&lt;span style="color:#b44"&gt;getName&lt;/span&gt;());&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 2. Service层：业务逻辑&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;public&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;class&lt;/span&gt; &lt;span style="color:#00f"&gt;UserService&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 必须手动创建依赖对象 → 「自己new」，初始化省略..&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;private&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;UserRepository&lt;span style="color:#bbb"&gt; &lt;/span&gt;userRepository&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;new&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;UserRepository();&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;public&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#0b0;font-weight:bold"&gt;void&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#00a000"&gt;registerUser&lt;/span&gt;(User&lt;span style="color:#bbb"&gt; &lt;/span&gt;user)&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 密码加密（业务逻辑）&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;user.&lt;span style="color:#b44"&gt;setPassword&lt;/span&gt;(encryptPassword(user.&lt;span style="color:#b44"&gt;getPassword&lt;/span&gt;()));&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 调用Repository保存&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;userRepository.&lt;span style="color:#b44"&gt;save&lt;/span&gt;(user);&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;private&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;String&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#00a000"&gt;encryptPassword&lt;/span&gt;(String&lt;span style="color:#bbb"&gt; &lt;/span&gt;password)&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;return&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;加密后的密码：&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;+&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;password;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 3. Controller层：接收请求&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;public&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;class&lt;/span&gt; &lt;span style="color:#00f"&gt;UserController&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 必须手动创建依赖对象 → 「自己new」&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;private&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;UserService&lt;span style="color:#bbb"&gt; &lt;/span&gt;userService&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;new&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;UserService();&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 可以改进为接收参数&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;public&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#0b0;font-weight:bold"&gt;void&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#00a000"&gt;handleRegisterRequest&lt;/span&gt;(String&lt;span style="color:#bbb"&gt; &lt;/span&gt;name,&lt;span style="color:#bbb"&gt; &lt;/span&gt;String&lt;span style="color:#bbb"&gt; &lt;/span&gt;password)&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;User&lt;span style="color:#bbb"&gt; &lt;/span&gt;user&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;new&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;User();&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;user.&lt;span style="color:#b44"&gt;setName&lt;/span&gt;(name);&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;user.&lt;span style="color:#b44"&gt;setPassword&lt;/span&gt;(password);&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;userService.&lt;span style="color:#b44"&gt;registerUser&lt;/span&gt;(user);&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 4. 启动类：手动创建所有对象&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;public&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;class&lt;/span&gt; &lt;span style="color:#00f"&gt;App&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;public&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;static&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#0b0;font-weight:bold"&gt;void&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#00a000"&gt;main&lt;/span&gt;(String&lt;span style="color:#666"&gt;[]&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;args)&lt;span style="color:#bbb"&gt; &lt;/span&gt;{&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 必须手动创建所有层的对象 → 「自己管理依赖」&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;UserController&lt;span style="color:#bbb"&gt; &lt;/span&gt;controller&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;new&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;UserController();&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// 调用注册接口&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;controller.&lt;span style="color:#b44"&gt;handleRegisterRequest&lt;/span&gt;(&lt;span style="color:#b44"&gt;&amp;#34;张三&amp;#34;&lt;/span&gt;,&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;123456&amp;#34;&lt;/span&gt;);&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;}&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有点儿偏面向过程的开发思路，需要自己管理各层依赖对象的创建初始化 ：&lt;/p&gt;</description></item><item><title>使用kind本地启动多集群</title><link>https://xiaoping378.github.io/docs/4-cloud/kubesphere/kind-multicluster-dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/kubesphere/kind-multicluster-dev/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;我本地4c/8G的小本儿，跑了两个集群，组建了多集群环境，还行，能玩动...&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="环境篇"&gt;环境篇&lt;a class="td-heading-self-link" href="#%e7%8e%af%e5%a2%83%e7%af%87" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;kind&lt;a href="https://kind.sigs.k8s.io/docs/user/quick-start/"&gt;安装&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;镜像准备&lt;/p&gt;
&lt;p&gt;视网络情况，可以把依赖镜像&lt;code&gt;kindest/node&lt;/code&gt;提起pull到本地&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker的data-root目录&lt;/p&gt;
&lt;p&gt;尽量不要放到/var目录下，kind起的集群容器会占用比较大的空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="实操"&gt;实操&lt;a class="td-heading-self-link" href="#%e5%ae%9e%e6%93%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建集群&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行完如下命令后，docker ps可以看到本地启动了两个容器，一个容器对应一个集群。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kind create cluster --image kindest/node:v1.19.16 --name host
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kind create cluster --image kindest/node:v1.19.16 --name member
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;kubectl config use-context [kind-host | kind-member]&lt;/code&gt;，可以切换kubecl执行的上下文&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;安装kubesphere&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分别在两个集群各自安装ks组件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 集群1安装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl config use-context kind-host
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.2.1/kubesphere-installer.yaml 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.2.1/cluster-configuration.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# 集群2安装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl config use-context kind-member
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.2.1/kubesphere-installer.yaml 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.2.1/cluster-configuration.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="3"&gt;
&lt;li&gt;纳管集群&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以在上面的初始化阶段直接改好主和成员集群的关系，这里参考&lt;a href="https://kubesphere.com.cn/docs/multicluster-management/enable-multicluster/direct-connection/"&gt;官文&lt;/a&gt;即可&lt;/p&gt;</description></item><item><title>论Kubesphere的异地多活方案</title><link>https://xiaoping378.github.io/docs/4-cloud/kubesphere/multihosts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/kubesphere/multihosts/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;遇到这样一个场景，在同一套环境中需要存在多个host控制面集群...bulabula... 因此想探索下kubesphere的异地多活混合容器云管理方案&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="集群角色介绍"&gt;集群角色介绍&lt;a class="td-heading-self-link" href="#%e9%9b%86%e7%be%a4%e8%a7%92%e8%89%b2%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一个兼容原生的k8s集群，可通过&lt;code&gt;ks-installer&lt;/code&gt;来初始化完成安装，成为一个QKE集群。QKE集群分为多种角色，默认是none角色（standalone模式），开启多集群功能时，可以设置为host或者member角色。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/kcp-%E5%A4%9A%E9%9B%86%E7%BE%A4.png" alt="多集群"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;none角色，是最小化安装的默认模式，会安装必要的ks-apiserver, ks-controller-manager, ks-console和其他组件
&lt;ul&gt;
&lt;li&gt;ks-apiserver, kcp的API网关，包含审计、认证、权限校验等功能&lt;/li&gt;
&lt;li&gt;ks-controller, 各类自定义crd的控制器和平台管理逻辑的实现&lt;/li&gt;
&lt;li&gt;ks-console, 前端界面UI&lt;/li&gt;
&lt;li&gt;ks-installer, 初始化安装和变更QKE集群的工具，由shell-operator触发ansible-playbooks来工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;member角色，承载工作负载的业务集群，和none模式的组件安装情况一致&lt;/li&gt;
&lt;li&gt;host角色，整个混合云管理平台的控制面，会在none的基础上，再额外安装tower，kubefed-controller-manager， kubefed-admission-webhook等组件
&lt;ul&gt;
&lt;li&gt;tower，代理业务集群通信的server端，常用于不能直连member集群api-server的情况&lt;/li&gt;
&lt;li&gt;kubefed-controller-manager，社区的&lt;a href="https://github.com/kubernetes-sigs/kubefed"&gt;kubefed&lt;/a&gt;联邦资源的控制器&lt;/li&gt;
&lt;li&gt;kubefed-admission-webhook， 社区的kubefed联邦资源的动态准入校验器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="多集群管理原理"&gt;多集群管理原理&lt;a class="td-heading-self-link" href="#%e5%a4%9a%e9%9b%86%e7%be%a4%e7%ae%a1%e7%90%86%e5%8e%9f%e7%90%86" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上段提到QKE有3种角色，可通过修改&lt;code&gt;cc&lt;/code&gt;配置文件的&lt;code&gt;clusterRole&lt;/code&gt;来使能, ks-installer监听到配置变化的事件，会初始化对应集群角色的功能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;kubectl edit cc ks-installer -n kubesphere-system
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;角色不要改来改去，会出现莫名问题，主要是背后ansible维护的逻辑有疏漏，没闭环&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="host集群"&gt;host集群&lt;a class="td-heading-self-link" href="#host%e9%9b%86%e7%be%a4" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;host角色的主集群会被创建25种联邦资源类型Kind，如下命令可查看，还会额外安装kubefed stack组件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ kubectl get FederatedTypeConfig -A
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此外api-server被重启后，会根据配置内容的变化，做两件事，注册多集群相关的路由和缓存同步部分联邦资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加url里包含&lt;code&gt;clusters/{cluster}&lt;/code&gt;路径的agent路由和转发的功能，要访问业务集群的信息，这样可以直接转发过去。&lt;/li&gt;
&lt;li&gt;cacheSync，缓存同步联邦资源，这里是个同步的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当开启多集群后，如果某个member出现异常导致不可通信，那host的api-server此时遇到故障要重启，会卡在cacheSync这一步，导致无法启动，进而整个平台无法访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;controller-manager被重启后，同样会根据配置的变化，把部分资源类型自动转化成联邦资源的逻辑，也就是说，在host集群创建的这部分资源会自动同步到所有成员集群，实际的多集群同步靠kubefed-controller-manager来执行。以下资源会被自动创建联邦资源下发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;users.iam.kubesphere.io -&amp;gt; federatedusers.types.kubefed.io&lt;/li&gt;
&lt;li&gt;workspacetemplates.tenant.kubesphere.io -&amp;gt; federatedworkspaces.types.kubefed.io&lt;/li&gt;
&lt;li&gt;workspaceroles.iam.kubesphere.io -&amp;gt; federatedworkspaceroles.types.kubefed.io&lt;/li&gt;
&lt;li&gt;workspacerolebindings.iam.kubesphere.io -&amp;gt; federatedworkspacerolebindings.types.kubefed.io&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外还会启动cluster、group和一些globalRole*相关资源的控制器逻辑，同上也会通过kubefed自动下发到所有集群，&lt;code&gt;clusters.cluster.kubesphere.io&lt;/code&gt;资源除外。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果以上资源包含了&lt;code&gt;kubefed.io/managed: false&lt;/code&gt;标签，kubefed就不会再做下发同步，而host集群下发完以上资源后，都会自动加上该标签，防止进入死循环&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="member集群"&gt;member集群&lt;a class="td-heading-self-link" href="#member%e9%9b%86%e7%be%a4" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;修改为member集群时，需要cc中的&lt;strong&gt;jwtSecret&lt;/strong&gt;与host集群的保持一致(若该值为空的话，ks-installer默认会随机生成)，提取host集群的该值时，需要去cm里找，如下：&lt;/p&gt;</description></item><item><title>搭建kubesphere的开发调试环境</title><link>https://xiaoping378.github.io/docs/4-cloud/kubesphere/kcp-dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/kubesphere/kcp-dev/</guid><description>&lt;h2 id="依赖工具介绍"&gt;依赖工具介绍&lt;a class="td-heading-self-link" href="#%e4%be%9d%e8%b5%96%e5%b7%a5%e5%85%b7%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;vscode，个人日常使用vscode开发，标配&lt;code&gt;Remote Development&lt;/code&gt;插件&lt;/li&gt;
&lt;li&gt;kt-connect，本地开发使用的流量代理工具，可以双向代理，本地可以直接访问pod和svc，也可以转发访问pod的流量到本地，相关&lt;a href="https://github.com/alibaba/kt-connect/blob/master/docs/zh-cn/reference/mechanism.md"&gt;原理介绍&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="准备调试环境"&gt;准备调试环境&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%87%e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="连接集群网络"&gt;连接集群网络&lt;a class="td-heading-self-link" href="#%e8%bf%9e%e6%8e%a5%e9%9b%86%e7%be%a4%e7%bd%91%e7%bb%9c" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;使用kt-connect，打通网络，本地可直接访问Kubernetes集群内网&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo ktctl connect --context kind-host --portForwardTimeout &lt;span style="color:#666"&gt;300&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ktctl&lt;/code&gt;采用本地&lt;code&gt;kubectl&lt;/code&gt;工具的集群配置，默认为~/.kube/config文件中配置的集群。&lt;/li&gt;
&lt;li&gt;如果kubeconfig有多个集群，可以通过&lt;code&gt;--context&lt;/code&gt;指定要连接的具体集群&lt;/li&gt;
&lt;li&gt;如果本地环境是&lt;code&gt;kind&lt;/code&gt;集群，需要修改kubeconfig中server的127地址为&lt;code&gt;容器IP:6443&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果网络比较差，会遇到错误&lt;code&gt;ERR Exit: pod kt-rectifier-tcxjk failed to start&lt;/code&gt;，可适当增加等待时间&lt;code&gt;portForwardTimeout&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;另外注意的是，kt-connect需要root权限，上条命令会默认读取&lt;code&gt;/root/.kube/config&lt;/code&gt;文件，自行copy或者另通过&lt;code&gt;-c&lt;/code&gt;指定文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="clone代码"&gt;clone代码&lt;a class="td-heading-self-link" href="#clone%e4%bb%a3%e7%a0%81" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;不表.&lt;/p&gt;
&lt;h3 id="编辑调试的配置文件"&gt;编辑调试的配置文件&lt;a class="td-heading-self-link" href="#%e7%bc%96%e8%be%91%e8%b0%83%e8%af%95%e7%9a%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;首先编辑vscode的调试配置文件, 我是如下配置的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ kubesphere git:&lt;span style="color:#666"&gt;(&lt;/span&gt;master&lt;span style="color:#666"&gt;)&lt;/span&gt; cat .vscode/launch.json
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; // Use IntelliSense to learn about possible attributes.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; // Hover to view descriptions of existing attributes.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; // For more information, visit: https://go.microsoft.com/fwlink/?linkid&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#666"&gt;830387&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;configurations&amp;#34;&lt;/span&gt;: &lt;span style="color:#666"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#666"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;ks-apiserver&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;go&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;request&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;mode&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;auto&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;program&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;workspaceFolder&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt;&lt;span style="color:#b44"&gt;/cmd/ks-apiserver/apiserver.go&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#666"&gt;}&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#666"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;controller-manager&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;go&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;request&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;mode&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;auto&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b44"&gt;&amp;#34;program&amp;#34;&lt;/span&gt;: &lt;span style="color:#b44"&gt;&amp;#34;&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;${&lt;/span&gt;&lt;span style="color:#b8860b"&gt;workspaceFolder&lt;/span&gt;&lt;span style="color:#b68;font-weight:bold"&gt;}&lt;/span&gt;&lt;span style="color:#b44"&gt;/cmd/controller-manager/controller-manager.go&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#666"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#666"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="准备调试环境-1"&gt;准备调试环境&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%87%e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83-1" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;按F5，启动调试，左上角选择要调试的组件，我这里以controller-manager举例（需要hack的注意点比较多）。&lt;/p&gt;</description></item><item><title>老祖宗的面子工程与现代软件工程</title><link>https://xiaoping378.github.io/blog/2026/01/11/%E8%80%81%E7%A5%96%E5%AE%97%E7%9A%84%E9%9D%A2%E5%AD%90%E5%B7%A5%E7%A8%8B%E4%B8%8E%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/blog/2026/01/11/%E8%80%81%E7%A5%96%E5%AE%97%E7%9A%84%E9%9D%A2%E5%AD%90%E5%B7%A5%E7%A8%8B%E4%B8%8E%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</guid><description>&lt;h1 id="老祖宗的面子工程与现代软件工程"&gt;老祖宗的面子工程与现代软件工程&lt;a class="td-heading-self-link" href="#%e8%80%81%e7%a5%96%e5%ae%97%e7%9a%84%e9%9d%a2%e5%ad%90%e5%b7%a5%e7%a8%8b%e4%b8%8e%e7%8e%b0%e4%bb%a3%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;一提“面子工程”，不少人会先想到形式主义，但老祖宗留下的“面子智慧”，其实藏着不少正向逻辑——比如传统礼仪的规范流程、古建筑的规制章法、文书典籍的规整体例，这些看似“讲排场”的“面子”，本质是为了建立秩序、传递信息、达成共识。把这份智慧用到现代软件工程里，重新定义“面子工程”为“让沟通载体标准化、可视化、场景化”的实用手段，就能打破跨角色认知壁垒，让协作更顺畅，最终让产品、研发、测试、运维等各环节伙伴都能更好地实现自身价值。这种“有用的面子工程”核心逻辑古今相通：用专业又好懂的外在呈现，把核心信息讲透彻，让不同背景的人快速抓重点，同时让每个人的专业能力和贡献都被看见。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;老祖宗早就懂，“面子”是沟通的敲门砖——古人见面向来讲究礼仪分寸，不同场合的着装、话术有明确规范，就是为了快速建立身份认知、减少沟通摩擦。这和现代软件工程的沟通困境不谋而合：全流程中沟通难的核心问题就两个：一是大家&lt;strong&gt;语言体系不一样&lt;/strong&gt;，二是&lt;strong&gt;信息不对等&lt;/strong&gt;。产品经理关注业务价值与用户体验，研发同学聚焦技术可行性与稳定性，测试人员紧盯质量风险，运维则看重系统运维成本与稳定性——每个人的核心诉求不同，若只靠口头沟通或冗长文字传递信息，很容易出现理解偏差。而传承老祖宗正向“面子智慧”的&lt;strong&gt;正向的面子工程&lt;/strong&gt;，正是通过标准化可视化工具、场景化呈现方式，为所有人搭建起统一的&lt;strong&gt;沟通语言&lt;/strong&gt;，从根源上降低沟通成本。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;核心价值：古今相通的“共识搭建术”——把抽象需求具象化，快速对齐各方认知&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老祖宗做大事前，常会画“蓝图”、定“章程”，这就是古代版的“需求可视化”。放到现在软件工程里，这里的“面子”，就是结构清晰的需求文档、直观的用户旅程地图，或是需求优先级矩阵。比如产品经理不用只说“优化注册流程”这种模糊表述，而是通过用户旅程地图，清晰呈现用户从进入页面到完成注册的全流程、核心痛点与情绪变化，再用优先级矩阵明确“简化表单字段”“优化验证逻辑”等具体任务的先后顺序。这样一来，研发、测试同学能快速get到需求背后的业务意义，产品经理的规划思路也能直观体现，既避免了后续因需求模糊导致的返工，也让大家提前明确工作方向，提升参与感——就像古人靠“章程”统一众人行动，现代靠可视化需求统一团队认知。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;核心价值：传承“规制智慧”——助力跨团队协同，沉淀可复用的技术知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老祖宗的“营造法式”“匠作规范”，是工匠群体的“技术沟通手册”，靠统一的规制让不同工匠协作造殿宇、修水利。研发团队输出的架构图、接口定义文档、数据库ER图等，就是现代软件工程的“匠作规范”，也是典型的“有用的面子工程”——它们不是多余形式，而是把抽象的技术逻辑转化为直观易懂的图形。比如一张清晰的微服务架构图，能帮前端同学明确接口调用关系，让测试同学精准锁定测试重点，也能让运维同学提前规划部署方案；规范的代码注释与开发文档，还能降低团队内部知识传递成本，帮新成员快速融入。这种“面子”不仅能提升研发协作效率，还能让研发同学的技术思考与架构设计能力被看见，同时让测试、运维同学提前参与技术方案讨论，凸显其前置风险把控的价值。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;核心价值：借鉴“案牍规范”——清晰呈现问题与进度，提升协作效率与决策精准度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;古代官府办案讲究“案牍分明”，每份卷宗都要清晰记录案情、证据、进度，方便同僚协同、上级决策——这就是老祖宗的“进度与问题可视化”智慧。测试同学反馈bug、团队跟进项目进度，正需要这份智慧。测试同学反馈bug时，若只说“某个页面有问题”，研发同学得花大量时间重现问题；但用标准化bug报告模板，附上清晰的操作步骤截图、异常现象录屏与影响范围说明，研发同学就能快速定位问题根源——这就是测试阶段“面子工程”的价值。此外，项目进度看板、燃尽图等可视化工具，能实时展示任务状态（待办/进行中/已完成）、负责人与阻塞点，让项目经理、产品经理及各执行角色随时掌握项目进度，及时协调资源解决问题。这种透明化呈现，不仅能加快bug修复效率，还能凸显测试同学的严谨性与运维同学的部署规划能力，让项目决策更精准，保障交付目标顺利达成。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;核心价值：延续“传帮带”传统——保障系统稳定运行，推动团队持续迭代进步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老祖宗靠“手札”“心法”传承技艺，靠“复盘纪事”总结经验，让技艺不断精进。运维同学输出的部署架构图、监控面板、故障处理手册等，就是现代的“技术手札”，能帮团队快速响应线上问题——比如一张清晰的部署架构图，可助力研发同学快速定位线上故障的模块范围，监控面板的可视化数据也能凸显运维同学的风险预警能力。而迭代复盘时的冲刺回顾图、绩效指标看板，就是现代的“复盘纪事”，能直观展示本迭代周期的成果、问题与改进方向，让产品、研发、测试、运维每个人的贡献都被量化，同时明确后续优化重点。这种“面子”不仅能保障系统长期稳定运行，还能让每个人的价值被清晰感知，增强团队凝聚力，推动团队持续改进，延续老祖宗“传帮带”“常复盘”的进步智慧。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;关键区分：正向“面子工程”≠形式主义，古今都重“里子”与“面子”双到位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老祖宗的正向“面子”从不是空架子：礼仪背后是尊重与秩序，规制背后是技艺与安全，案牍背后是效率与责任。这和现代正向“面子工程”的逻辑一致，两者与形式主义的核心区别，在于是否服务于实际目标：正向“面子工程”是为了提升沟通效率、凸显价值贡献，形式主义则是脱离实际的无用功。比如古代若只讲礼仪不办实事、现代为追求文档美观而忽略核心信息，都是要规避的“坏面子工程”。真正有用的“面子”，必然是“里子”与“面子”兼具：“面子”是直观专业的呈现形式，“里子”是清晰的核心信息与明确的目标导向，古今智慧一脉相承。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;老祖宗的“面子智慧”，本质是一套成熟的沟通与协作方法论。把这份智慧转化为现代软件工程的正向“面子工程”，就是掌握了高效沟通的方法与价值呈现的技巧。它通过标准化、可视化载体统一沟通语言，解决信息不对等问题；通过场景化呈现让各角色专业价值被看见，提升成就感与参与感。最终，这种融合古今智慧的“面子工程”，不仅能让项目推进更顺畅，还能实现产品、研发、测试、运维等所有伙伴的价值协同提升，成为软件工程高质量推进的实用助力。&lt;/p&gt;</description></item><item><title>我天！Go消失在前十，Java也滑到老四了</title><link>https://xiaoping378.github.io/blog/2025/12/11/%E6%88%91%E5%A4%A9go%E6%B6%88%E5%A4%B1%E5%9C%A8%E5%89%8D%E5%8D%81java%E4%B9%9F%E6%BB%91%E5%88%B0%E8%80%81%E5%9B%9B%E4%BA%86/</link><pubDate>Thu, 11 Dec 2025 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/blog/2025/12/11/%E6%88%91%E5%A4%A9go%E6%B6%88%E5%A4%B1%E5%9C%A8%E5%89%8D%E5%8D%81java%E4%B9%9F%E6%BB%91%E5%88%B0%E8%80%81%E5%9B%9B%E4%BA%86/</guid><description>&lt;h2 id="top15语言排行"&gt;Top15语言排行&lt;a class="td-heading-self-link" href="#top15%e8%af%ad%e8%a8%80%e6%8e%92%e8%a1%8c" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;下图是2025.12月的编程语言排行榜，&lt;strong&gt;人工智能的到来，已经造成了二十年未有之大变局呀&lt;/strong&gt;。
&lt;img src="https://xiaoping378.github.io/blog/2025/12/11/%E6%88%91%E5%A4%A9go%E6%B6%88%E5%A4%B1%E5%9C%A8%E5%89%8D%E5%8D%81java%E4%B9%9F%E6%BB%91%E5%88%B0%E8%80%81%E5%9B%9B%E4%BA%86/all-top15-rank.png" alt="alt text"&gt;&lt;/p&gt;
&lt;h3 id="java-的持续下滑"&gt;Java 的持续下滑&lt;a class="td-heading-self-link" href="#java-%e7%9a%84%e6%8c%81%e7%bb%ad%e4%b8%8b%e6%bb%91" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Java自从2001年登顶后，终于滑到老四了，这是二十多年来的最低排行了，延续了Java份额近年来被其他语言侵蚀的趋势。虽然它仍是企业级和安卓开发的中坚力量，但其主导地位（占比份额）确实在减弱，和整个互联网行业的走势何其相似。不过大伙儿倒不用担心饭碗问题，没看delphi和Fortan还活跃着呢&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/blog/2025/12/11/%E6%88%91%E5%A4%A9go%E6%B6%88%E5%A4%B1%E5%9C%A8%E5%89%8D%E5%8D%81java%E4%B9%9F%E6%BB%91%E5%88%B0%E8%80%81%E5%9B%9B%E4%BA%86/2025-12-java-tobie.png" alt="alt text"&gt;&lt;/p&gt;
&lt;h3 id="go-的-消失"&gt;Go 的“消失”&lt;a class="td-heading-self-link" href="#go-%e7%9a%84-%e6%b6%88%e5%a4%b1" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;未进前十! 在榜单前十名中，完全没有看到 Go 语言的身影。甚至低于第10名R语言的1.96%。&lt;/p&gt;
&lt;p&gt;Go已成为云原生、微服务、分布式系统基础设施领域的事实标准语言（Docker, Kubernetes, etcd, Prometheus等核心云原生工具均用Go编写）。在这个极其关键但相对专业和底层的赛道里，Go是绝对的统治者。但TIOBE指数基于全球搜索引擎流量，更偏向于反映广泛学习、讨论和使用的广度。Go在基础设施层的“隐形冠军”地位，意味着它被大量用于构建系统，但直接使用它编写业务应用的人数，相比Python、Java、C#等还是少。&lt;/p&gt;
&lt;p&gt;这说明Go虽成功定义了一个新时代的基础设施层，但还是没大规模渗透到更广泛的应用开发层呀，我辈Goper仍需努力啊。&lt;/p&gt;
&lt;h3 id="榜单其他看点"&gt;榜单其他看点&lt;a class="td-heading-self-link" href="#%e6%a6%9c%e5%8d%95%e5%85%b6%e4%bb%96%e7%9c%8b%e7%82%b9" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Python 的统治力：以23.64%​ 的份额稳居第一，几乎是第二名C语言的两倍多，其领先地位极为稳固。&lt;/p&gt;
&lt;p&gt;Python高达23.64%​ 的份额，算是人工智能、机器学习、数据科学和自动化成为过去几年乃至未来最核心发展方向的直接证明了。Python庞大的科学生态（NumPy, Pandas）和AI框架（TensorFlow, PyTorch）使其成为这些领域的“普通话”。&lt;/p&gt;
&lt;p&gt;另外，企业正在无脑开展“数据驱动”和“AI赋能”的转型。无论是做应用开发、金融分析还是生物信息，学习和使用Python来处理数据、调用模型都成为了必备技能。已从一个编程语言演变为新时代的基础工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 语言的强势回归：从第4名跃升至第2名，份额增长超过1个百分点，是前五名中上升势头最猛的语言。&lt;/p&gt;
&lt;p&gt;C语言跃居第二，份额增长，应该是行业面临算力瓶颈、追求极致性能和能效的体现。在AI推理、边缘计算、物联网、汽车电子、操作系统、新兴硬件（如RISC-V）驱动等领域，当摩尔定律放缓，软件优化必须更贴近硬件。同时，在AI推理部署、嵌入式AI、高性能网络设备等关键领域，C仍是不可替代的基石。这说明，硬件和基础软件的创新正迎来新一轮热潮。&lt;/p&gt;
&lt;p&gt;外加全球纷纷选择制造业护国的战略，这个表现也算理所当然了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C# 的显著增长：份额大幅上涨+2.39%，是前十名中增幅最大的语言，显示其强劲活力。&lt;/p&gt;
&lt;p&gt;这直接归功于微软的全面转型成功。.NET Core/.NET 5+​ 的跨平台、高性能特性，加上微软云（Azure）的深度集成，使其成为企业，特别是原有Windows生态企业进行云原生现代化改造的黄金路径。估计国内游戏开发（Unity引擎）的持续火爆也贡献了力量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Perl 的意外飙升：从第26名暴升至第9名，份额增长1.33%，是最大的“黑马”。&lt;/p&gt;
&lt;p&gt;Perl（第9名！）和R语言的排名飙升是“工具属性”的胜利。它们在特定领域（Perl在生物信息、系统管理、文本处理；R在统计学、生物统计、学术研究）有着成熟的库和即用脚本。当这些领域因AI、生物科技等产业发展而数据处理任务激增时，这些“老牌利器”的需求就快速反弹。&lt;/p&gt;
&lt;p&gt;在专业垂直领域，&lt;strong&gt;解决具体问题的最佳工具&lt;/strong&gt;​ 往往比最流行的通用语言更重要。这也反映了特定行业（如生物信息学）的繁荣。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="总结"&gt;总结&lt;a class="td-heading-self-link" href="#%e6%80%bb%e7%bb%93" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 410px"&gt;
&lt;img class="card-img-top" src="https://xiaoping378.github.io/blog/2025/12/11/%E6%88%91%E5%A4%A9go%E6%B6%88%E5%A4%B1%E5%9C%A8%E5%89%8D%E5%8D%81java%E4%B9%9F%E6%BB%91%E5%88%B0%E8%80%81%E5%9B%9B%E4%BA%86/future_hu_a2472823b38358ff.png" width="400" height="400"&gt;
&lt;figcaption class="card-body px-0 pt-2 pb-0"&gt;
&lt;p class="card-text"&gt;


未来架构指引
&lt;small class="text-body-secondary"&gt;&lt;br/&gt;来源：xiaoping378 / CC-BY-CA&lt;/small&gt;
&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;这张榜单是近年来行业发展的一张完美的“压力分布图”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶层（AI/数据）​ 被Python统治，代表未来热门方向。&lt;/li&gt;
&lt;li&gt;底层（硬件/系统）​ 由C/C++把持，代表对性能的永恒追求。&lt;/li&gt;
&lt;li&gt;中间层（企业应用）​ 正从Java一家独大，向C#、Go等多元化栈演变，代表企业上云和技术架构的深刻变革。&lt;/li&gt;
&lt;li&gt;垂直领域​ 则因特定产业（如生物科技）的爆发，让Perl、R等工具语言重获新生。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们不应该只看到简单的排名游戏，而应看到AI革命、硬件创新、企业上云、垂直行业深化这四大技术浪潮，在编程语言生态上投射出的清晰影像。做好后续项目架构规划和未来投资，才是关键。&lt;/p&gt;</description></item><item><title>解读SRE行业2025调查报告</title><link>https://xiaoping378.github.io/blog/2025/12/09/%E8%A7%A3%E8%AF%BBsre%E8%A1%8C%E4%B8%9A2025%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/</link><pubDate>Tue, 09 Dec 2025 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/blog/2025/12/09/%E8%A7%A3%E8%AF%BBsre%E8%A1%8C%E4%B8%9A2025%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/</guid><description>&lt;h2 id="报告统计源说明"&gt;报告统计源说明&lt;a class="td-heading-self-link" href="#%e6%8a%a5%e5%91%8a%e7%bb%9f%e8%ae%a1%e6%ba%90%e8%af%b4%e6%98%8e" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;报告所依据的SRE调查，是从2024年7月开始，花了6周的时间，收到来自全球各地、涵盖各类可靠性岗位及职级的301份&lt;strong&gt;有效&lt;/strong&gt;回复。&lt;/p&gt;
&lt;p&gt;调查者大部分源自美欧中，国内有墙的情况下，还能有这等占比，其实中国占比很高了。&lt;/p&gt;
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 1110px"&gt;
&lt;img class="card-img-top" src="https://xiaoping378.github.io/blog/2025/12/09/%E8%A7%A3%E8%AF%BBsre%E8%A1%8C%E4%B8%9A2025%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/global-site_hu_c4c9d9ea18c8cb4e.png" width="1100" height="600"&gt;
&lt;figcaption class="card-body px-0 pt-2 pb-0"&gt;
&lt;p class="card-text"&gt;


全球地域分布情况
&lt;small class="text-body-secondary"&gt;&lt;br/&gt;来源：The SRE Report 2025, Catchpoint&lt;/small&gt;
&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;其中企业分类性质的占比如下：
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 410px"&gt;
&lt;img class="card-img-top" src="https://xiaoping378.github.io/blog/2025/12/09/%E8%A7%A3%E8%AF%BBsre%E8%A1%8C%E4%B8%9A2025%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/qiye-zhanbi_hu_8a01ec102ac4ec90.png" width="400" height="400"&gt;
&lt;figcaption class="card-body px-0 pt-2 pb-0"&gt;
&lt;p class="card-text"&gt;


企业类型占比
&lt;small class="text-body-secondary"&gt;&lt;br/&gt;来源：The SRE Report 2025, Catchpoint&lt;/small&gt;
&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;40%，技术平台或“即服务”提供商，(钉钉或者Salesforce这类)&lt;/li&gt;
&lt;li&gt;19%，其他（制造业、医疗等）&lt;/li&gt;
&lt;li&gt;17%，金融服务&lt;/li&gt;
&lt;li&gt;11%，零售/电子商务&lt;/li&gt;
&lt;li&gt;11%，大型集团：跨多个领域运营&lt;/li&gt;
&lt;li&gt;10%，高等教育&lt;/li&gt;
&lt;li&gt;7%，政府&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公司规模占比，上千人的公司占比超过51%。
&lt;figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 1110px"&gt;
&lt;img class="card-img-top" src="https://xiaoping378.github.io/blog/2025/12/09/%E8%A7%A3%E8%AF%BBsre%E8%A1%8C%E4%B8%9A2025%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/qiye-guimo_hu_4b257a56c08acd32.png" width="1100" height="250"&gt;
&lt;figcaption class="card-body px-0 pt-2 pb-0"&gt;
&lt;p class="card-text"&gt;


企业规模占比
&lt;small class="text-body-secondary"&gt;&lt;br/&gt;来源：The SRE Report 2025, Catchpoint&lt;/small&gt;
&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id="趋势观点"&gt;趋势观点&lt;a class="td-heading-self-link" href="#%e8%b6%8b%e5%8a%bf%e8%a7%82%e7%82%b9" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;报告揭示了几个核心趋势，我结合自身经历用大白话来解释一下&lt;/p&gt;
&lt;h3 id="慢即宕机-slow-is-the-new-down"&gt;慢即宕机（Slow is the New Down）&lt;a class="td-heading-self-link" href="#%e6%85%a2%e5%8d%b3%e5%ae%95%e6%9c%ba-slow-is-the-new-down" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个观点讲的是，一个服务响应很慢和完全宕机的危害一样大。想象一下，在网购时页面转圈十几秒才加载出来，你很可能就直接关掉走人了。所以，性能好坏直接关系到用户体验和业务收入。&lt;/p&gt;
&lt;p&gt;性能优化，首屏响应之类的词汇，其实在国内也早有相应的需求讨论，这里将其上升到了&lt;code&gt;宕机&lt;/code&gt;的危害程度，调查中也有53%的人认可这一说法，另一个有意思的是，44%人认为还应该把这一指标作为SLO目标。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;SLO目标&lt;/strong&gt;：SLO（Service Level Objective，服务水平目标）​ 简单来说，就是你为一项服务设定的、可量化的可靠性目标。它不再是以往被动运维的底线保障思维，如保障系统可用性几个9的承诺，而是一个具体、可测量的指标，用于明确回答：“对用户而言，这个服务怎样才算是‘真好用’”
例如，一个视频流服务的SLO可以是：“99.9%的用户请求应在1秒内得到成功响应。”
类似的还有，首页网页加载时间小与200ms&lt;/p&gt;</description></item><item><title>IT技术人员在人工智能时代如何自救</title><link>https://xiaoping378.github.io/blog/2025/12/08/it%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E5%9C%A8%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%E5%A6%82%E4%BD%95%E8%87%AA%E6%95%91/</link><pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/blog/2025/12/08/it%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E5%9C%A8%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%E5%A6%82%E4%BD%95%E8%87%AA%E6%95%91/</guid><description>&lt;h2 id="背景"&gt;背景&lt;a class="td-heading-self-link" href="#%e8%83%8c%e6%99%af" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在大模型人工智能技术深刻改变软件工程领域的当下，可以初步总结为，初级人员入场门槛高了，高级人员的经验优势弱化了，岗位角色职责模糊了。面对这种趋势，我们的应对思路需要更务实，更聚焦于“人”究竟能守住和创造什么独特价值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在当前这个“充满不确定性”的时代，企业不愿投资软件IT。存量的更多需求，在老板看来，有了AI的加持，也不需要更多人员，“似乎”人月神话失效了。
但AI如何安全可控的融入现有软件工程体系，仍在探索中，这是一个令人兴奋的过程，目前看不会是成为“昙花一现”的工具，是能够普世的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="关于初级门槛抬高"&gt;关于初级门槛抬高&lt;a class="td-heading-self-link" href="#%e5%85%b3%e4%ba%8e%e5%88%9d%e7%ba%a7%e9%97%a8%e6%a7%9b%e6%8a%ac%e9%ab%98" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;新人不能再靠“听话照做”入场。过去，新人通过完成明确的、重复性的任务来学习和证明自己，比如写一个简单的接口，执行一组测试用例。但现在，这类任务AI完成得更快。这迫使新人的成长路径必须改变。关键在于，必须从一开始就培养“定义问题”和“判断结果”的能力，而不仅仅是“执行操作”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对开发新人而言，重点不再是背熟API，而是拿到一个模糊需求后，能利用AI工具快速探索多种实现方案，并能说出每种方案在性能、可维护性、成本上的权衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对测试新人来说，核心不是会写更多用例，而是要能设计出那些AI容易忽略的、涉及复杂业务场景交互和极端用户体验的“刁钻”场景，去考验AI生成的用例是否可靠。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对所有人，深入理解业务变得空前重要。因为只有懂了业务，你给AI的指令和对你产出的判断，才不会流于表面，才能发现逻辑深处的矛盾。新人需要主动把自己浸泡在业务会议、用户反馈和产品数据里，哪怕一开始听不懂。&lt;/p&gt;
&lt;h2 id="关于高级经验优势弱化"&gt;关于高级经验优势弱化&lt;a class="td-heading-self-link" href="#%e5%85%b3%e4%ba%8e%e9%ab%98%e7%ba%a7%e7%bb%8f%e9%aa%8c%e4%bc%98%e5%8a%bf%e5%bc%b1%e5%8c%96" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;资深者的价值必须从“知道答案”升级为“在复杂情境中做出更优决策”。我们过去引以为傲的“我遇到过”“我知道怎么解决”，其知识部分正被AI快速吸收。但经验中真正难以被编码的部分，是其背后的上下文、权衡的智慧和承担的责任。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个资深架构师，AI能给出十种技术选型方案。但他的价值在于，能基于对团队技能、历史债务、未来业务方向、老板的耐心和预算的全盘理解，选择（甚至组合出）第十一种最可行的路径，并能为这个选择可能的风险准备预案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个运维专家，AI能预测故障。但他的价值在于，当多个预警同时发生、信息矛盾时，能凭借对系统“脾气”的直觉，判断哪里是真正要害，并能在压力下协调各方，执行一个可能不完美但能最快止血的恢复方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种“在混沌中导航”的能力，建立在大量试错（探知AI能力边界）、人际关系和感性认知之上，是AI目前无法习得的。因此，资深人员需要有意识地总结和输出自己的“决策模型”和“权衡框架”，而不仅仅是解决方案本身，这将成为你新的专业壁垒。&lt;/p&gt;
&lt;h2 id="关于岗位职责模糊"&gt;关于岗位职责模糊&lt;a class="td-heading-self-link" href="#%e5%85%b3%e4%ba%8e%e5%b2%97%e4%bd%8d%e8%81%8c%e8%b4%a3%e6%a8%a1%e7%b3%8a" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在边界溶解时，要重新锚定自己的“内核”，并主动拓展影响范围。当工具让跨界协作变得异常容易时，固守原来的职责范围会让自己边缘化。正确的姿态是：以自己不可替代的核心能力为“根”，主动向关联领域生长“枝蔓”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于产品经理，核心不是写文档，而是持续探索和定义“什么是有价值的事”。现在，你可以用AI快速生成原型甚至部分代码，那么你的工作重心就更应前移：深入用户场景，定义AI能力的边界，思考模型可能带来的偏见和风险，并协调设计、开发、法务一起解决。你的角色更像一个“产品创造者”而不仅是“需求翻译者”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于测试人员，核心不是找bug，而是作为产品质量和风险的“最终守门人”。你需要利用AI完成海量常规检查，从而将精力投向更深处：设计评估AI输出结果可信度的体系，关注安全、性能、伦理等非功能需求，并从用户体验的完整性出发进行测试。你的工作正在与安全、运维、产品体验深度交融。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种模糊化，本质上是要求每个人都更具“全局思维”。一个开发需要理解自己写的模块对运维的意味；一个运维需要知道某个部署对业务指标的影响。理解你上下游的工作，并用你的专业能力为他们赋能，将成为新的常态。&lt;/p&gt;
&lt;h2 id="在价值重构中定位新坐标"&gt;在价值重构中定位新坐标&lt;a class="td-heading-self-link" href="#%e5%9c%a8%e4%bb%b7%e5%80%bc%e9%87%8d%e6%9e%84%e4%b8%ad%e5%ae%9a%e4%bd%8d%e6%96%b0%e5%9d%90%e6%a0%87" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;自救与规划发展的核心，在于认识到：AI处理的是“已知”模式，而人的价值将愈发体现在应对“未知”情境。​ 我们的自救之路，就是不断将自己推向那些需要深度理解、复杂判断、人际协调和承担责任的领域。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动成为“人机协同”的枢纽：不排斥AI，而是研究如何最高效安全地使用它，并把节省下来的时间，投入到更需要人类智慧的思考、沟通和创新中去。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如何高效安全的使用AI，本身就是一个话题了，后面单开一个专题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;打造“解决问题”的元能力：无论岗位如何变化，&lt;code&gt;定义问题&lt;/code&gt;、&lt;code&gt;拆解问题&lt;/code&gt;、&lt;code&gt;整合资源&lt;/code&gt;、&lt;code&gt;推动解决&lt;/code&gt;这一核心能力永不过时。刻意训练自己解决模糊、开放、跨域的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立你的“人性化”护城河：对用户的共情、对团队的信任构建、对商业本质的洞察、对伦理风险的审慎，这些高度人性化的特质，是技术无法模拟的，也是你长期价值的基石。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这场变革并非要取代我们，而是逼迫我们放弃那些重复的、机械的“操作工”角色，去成为真正的“思考者”和“负责人”。&lt;/p&gt;</description></item><item><title>现代技能栈</title><link>https://xiaoping378.github.io/blog/2025/12/08/%E7%8E%B0%E4%BB%A3%E6%8A%80%E8%83%BD%E6%A0%88/</link><pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/blog/2025/12/08/%E7%8E%B0%E4%BB%A3%E6%8A%80%E8%83%BD%E6%A0%88/</guid><description>&lt;h1 id="现代技能栈"&gt;&lt;a href="https://xiaoping378.github.io/docs/"&gt;现代技能栈&lt;/a&gt;&lt;a class="td-heading-self-link" href="#%e7%8e%b0%e4%bb%a3%e6%8a%80%e8%83%bd%e6%a0%88" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h1&gt;</description></item><item><title>从零开始构建智能体系统原理与实践教程</title><link>https://xiaoping378.github.io/blog/2025/12/08/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E6%99%BA%E8%83%BD%E4%BD%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/blog/2025/12/08/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E6%99%BA%E8%83%BD%E4%BD%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/</guid><description>&lt;p&gt;大模型只能算是静态知识库，无法主动与现实环境交互，需要借助于智能体Agent。&lt;/p&gt;
&lt;p&gt;智能体的构建可以分为两大流派，一种是流程驱动大模型，另一种是大模型驱动流程。具体可&lt;/p&gt;
&lt;h1 id="在线阅读"&gt;&lt;a href="https://datawhalechina.github.io/hello-agents/"&gt;在线阅读&lt;/a&gt;&lt;a class="td-heading-self-link" href="#%e5%9c%a8%e7%ba%bf%e9%98%85%e8%af%bb" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h1&gt;</description></item><item><title>Centos7 配置记录</title><link>https://xiaoping378.github.io/docs/2-infra/linux/centos/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/2-infra/linux/centos/</guid><description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;sshd&lt;/strong&gt; 禁用DNS反向解析和GSSAPI认证，以完成快速登陆&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo sed -i &lt;span style="color:#b44"&gt;&amp;#39;s/#UseDNS yes/UseDNS no/g&amp;#39;&lt;/span&gt; /etc/ssh/sshd_config
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo sed -i &lt;span style="color:#b44"&gt;&amp;#39;s/GSSAPIAuthentication yes/GSSAPIAuthentication no/g&amp;#39;&lt;/span&gt; /etc/ssh/sshd_config
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo systemctl restart sshd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;添加本地dvd源&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;mkdir -p /media/dvd &lt;span style="color:#666"&gt;&amp;amp;&amp;amp;&lt;/span&gt; mount -t auto /dev/cdrom /media/dvd
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cat &lt;span style="color:#b44"&gt;&amp;lt;&amp;lt;EOF &amp;gt;/etc/yum.repos.d/CentOS-Base.repo
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;[c7-dvd]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;name=Centos-7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;baseurl=file:///media/dvd
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;enabled=1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;gpgcheck=1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;gpgkey=file:///media/dvd/RPM-GPG-KEY-CentOS-7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;yum clean all
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装docker&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加yum源&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo tee /etc/yum.repos.d/docker.repo &lt;span style="color:#b44"&gt;&amp;lt;&amp;lt;-&amp;#39;EOF&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;[dockerrepo]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;name=Docker Repository
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;baseurl=https://yum.dockerproject.org/repo/main/centos/7/
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;enabled=1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;gpgcheck=1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;gpgkey=https://yum.dockerproject.org/gpg
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b44"&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="2"&gt;
&lt;li&gt;安装docker-engine&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sudo yum install -y docker
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者下载离线rpm包（供网络环境差的环境使用）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; sudo yum install docker --downloadonly --downloaddir&lt;span style="color:#666"&gt;=&lt;/span&gt;./
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; sudo yum localinstall ./*.rpm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;del&gt;3. 修改必要的docker daemon配置参数&lt;/del&gt; 现在不需要了，主要是devicemapper需要改下&lt;/p&gt;</description></item><item><title>优秀文集</title><link>https://xiaoping378.github.io/docs/reference/%E4%BC%98%E7%A7%80%E6%96%87%E9%9B%86/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/reference/%E4%BC%98%E7%A7%80%E6%96%87%E9%9B%86/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;TODO 待整理&lt;/p&gt;

&lt;/div&gt;</description></item><item><title>裁剪内核-BootLoader</title><link>https://xiaoping378.github.io/docs/2-infra/linux/kernel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/2-infra/linux/kernel/</guid><description>&lt;p&gt;.TODO&lt;/p&gt;</description></item><item><title>搜索结果</title><link>https://xiaoping378.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/search/</guid><description/></item></channel></rss>