<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Openshift on 现代技能栈</title><link>https://xiaoping378.github.io/tags/openshift/</link><description>Recent content in Openshift on 现代技能栈</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://xiaoping378.github.io/tags/openshift/index.xml" rel="self" type="application/rss+xml"/><item><title>快速安装</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85/</guid><description>&lt;p&gt;不知道为什么openshift在国内热度这么低，那些要做自己容器云的公司，不知道有openshift项目的存在么？完全满足我的需求。&lt;/p&gt;
&lt;p&gt;docker负责应用的隔离打包，k8s提供集群管理和容器的编排服务，而openshfit则负责整个应用的生命周期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码管理，CI&amp;amp;CD能力&lt;/li&gt;
&lt;li&gt;多租户管理, 支持LDAP和Oauth&lt;/li&gt;
&lt;li&gt;集成监控日志于web console&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先说下自接触到openshift项目就遇到的一个困惑，就是openshift origin/enterprise /online/dedicated/ocp之间的关系： &lt;code&gt;orgin相当于Fedora， 其他的相当于RHEL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来谈下我用自己的笔记本实践的过程与感受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本人日常基于ubuntu16.04办公，所以用oc直接上, oc相当于kubectl&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/openshift/origin/releases"&gt;这里&lt;/a&gt;直接下载oc客户端，或者自行编译, 编译结果在_output目录下&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;git clone --depth=1 https://github.com/openshift/origin.git
cd origin &amp;amp;&amp;amp; make
mv _output/local/bin/linux/amd64/oc /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动openshift, 默认开启监控并初始安装自最新版本，当前是v1.5.0-alpha.2&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc cluster up --metrics=true --version=latest --insecure-skip-tls-verify=true --public-hostname=air13
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;过程中会拉取所需镜像, 我这里显示比较多，之前已经做了些实验&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;➜ ~ docker images | grep openshift | awk &amp;#39;{print $1}&amp;#39;
openshift/node
openshift/origin-sti-builder
openshift/origin-docker-builder
openshift/origin-deployer
openshift/origin-gitserver
openshift/origin-docker-registry
openshift/origin-haproxy-router
openshift/origin
openshift/hello-openshift
openshift/openvswitch
openshift/origin-pod
openshift/origin-metrics-cassandra
openshift/origin-metrics-hawkular-metrics
openshift/origin-metrics-heapster
openshift/origin-metrics-deployer
openshift/mysql-55-centos7
openshift/origin-logging-curator
openshift/origin-logging-fluentd
openshift/origin-logging-deployment
openshift/origin-logging-elasticsearch
openshift/origin-logging-kibana
openshift/origin-logging-auth-proxy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动后，会打印如下信息&lt;/p&gt;</description></item><item><title>权限资源管理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%9D%83%E9%99%90%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%9D%83%E9%99%90%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</guid><description>&lt;p&gt;重点介绍 project，limitRange，resourceQuta和 user, group, rule，role，policy，policybinding的关系,
我刚接触时，这几个概念老搞不太清楚，这里梳理下&lt;/p&gt;
&lt;h2 id="资源管理说明"&gt;资源管理说明&lt;a class="td-heading-self-link" href="#%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e8%af%b4%e6%98%8e" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以对计算资源的大小和对象类型的数量来进行配额限制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ResourceQuota&lt;/code&gt;是面向project（namespace的基础上加了些注解）层面的，只有集群管理员可以基于namespace设置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;limtRange&lt;/code&gt;是面向pod和container级别的，openshift额外还可以限制 image， imageStream和pvc，
也是只有集群管理员才可以基于project设置，而开发人员只能基于pod（container）设置cpu和内存的requests/limits。&lt;/p&gt;
&lt;h3 id="resourcequota"&gt;ResourceQuota&lt;a class="td-heading-self-link" href="#resourcequota" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;看看具体可以管理哪些资源，期待网络相关的也加进来.简单来讲，可以基于project来限制可消耗的内存大小和可创建的pods数量&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;// The following identify resource constants for Kubernetes object types&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;&lt;span style="color:#a2f;font-weight:bold"&gt;const&lt;/span&gt;&lt;span style="color:#bbb"&gt; &lt;/span&gt;(&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Pods, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourcePods&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Services, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceServices&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;services&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ReplicationControllers, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceReplicationControllers&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;replicationcontrollers&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceQuotas, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceQuotas&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;resourcequotas&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceSecrets, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceSecrets&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;secrets&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceConfigMaps, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceConfigMaps&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;configmaps&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourcePersistentVolumeClaims, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourcePersistentVolumeClaims&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;persistentvolumeclaims&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceServicesNodePorts, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceServicesNodePorts&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;services.nodeports&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// ResourceServicesLoadBalancers, number&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceServicesLoadBalancers&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;services.loadbalancers&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// CPU request, in cores. (500m = .5 cores)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceRequestsCPU&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;requests.cpu&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Memory request, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceRequestsMemory&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;requests.memory&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Storage request, in bytes&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceRequestsStorage&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;requests.storage&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// CPU limit, in cores. (500m = .5 cores)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceLimitsCPU&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;limits.cpu&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;&lt;span style="color:#080;font-style:italic"&gt;// Memory limit, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;	&lt;/span&gt;ResourceLimitsMemory&lt;span style="color:#bbb"&gt; &lt;/span&gt;ResourceName&lt;span style="color:#bbb"&gt; &lt;/span&gt;=&lt;span style="color:#bbb"&gt; &lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;limits.memory&amp;#34;&lt;/span&gt;&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#bbb"&gt;&lt;/span&gt;)&lt;span style="color:#bbb"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;openshift额外支持的images相关的限制策略&lt;/p&gt;</description></item><item><title>项目开发实战</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</guid><description>&lt;p&gt;下面的所有操作，都可以通过cli，web console，RestFul API实现，默认使用cli说明&lt;/p&gt;
&lt;h3 id="创建项目"&gt;创建项目&lt;a class="td-heading-self-link" href="#%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里是接着oc cluster up后，来说的， 默认&lt;code&gt;oc whoami&lt;/code&gt;是 developer,拥有admin的Role角色，俗称项目经理（管理员）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除默认创建的项目，并创建一个实际中的项目&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;oc delete project myproject
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;oc new-project eshop --display-name&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;电商项目&amp;#34;&lt;/span&gt; --description&lt;span style="color:#666"&gt;=&lt;/span&gt;&lt;span style="color:#b44"&gt;&amp;#34;一个神奇的网站&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在项目管理员可以创建任意多个项目，从前面的源码可以看到目前是没法针对项目管理员去限制可创建项目上限的。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;查看项目状态&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;#oc status
In project 电商项目 (eshop) on server https://192.168.31.49:8443

You have no services, deployment configs, or build configs.
Run &amp;#39;oc new-app&amp;#39; to create an application.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空空如也，有提示语句提示可通过&lt;code&gt;oc new-app&lt;/code&gt;去创建具体应用的&lt;/p&gt;
&lt;h3 id="创建应用"&gt;创建应用&lt;a class="td-heading-self-link" href="#%e5%88%9b%e5%bb%ba%e5%ba%94%e7%94%a8" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前面也说过，openshift的核心就是围绕应用的整个生命周期来的，所以从new-app说起&lt;/p&gt;
&lt;p&gt;new-app的入口是&lt;code&gt;NewCmdNewApplication()&lt;/code&gt;, 大部分实现是 &lt;code&gt;func (c *AppConfig) Run() (*AppResult, error)&lt;/code&gt; 感兴趣的可以根据源码来理解openshift的devops理念。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建应用的方式
现在可以通过3种方式（源码， docker镜像， 模板）来创建一个应用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# oc new-app -h
#此处省略。。。
Usage:
 oc new-app (IMAGE | IMAGESTREAM | TEMPLATE | PATH | URL ...) [options]
#此处省略。。。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有很多灵活简便的方式来创建应用，甚至可以直接&lt;code&gt;oc new-app mysql&lt;/code&gt;来创建一个mysql服务&lt;/p&gt;</description></item><item><title>DevOps实战-0</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0/</guid><description>&lt;p&gt;主要涉及到&lt;code&gt;一键发布&lt;/code&gt;，&lt;code&gt;快速回滚&lt;/code&gt;，&lt;code&gt;弹性伸缩&lt;/code&gt;，&lt;code&gt;蓝绿部署&lt;/code&gt;方面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动openshift&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;oc cluster up --version=v1.5.0-rc.0 --metrics --use-existing-config=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认负责监控的pods占用资源太大了，可以这样限制下，或者cluster up时不加 &lt;code&gt;--metrics&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;oc login -u system:admin
oc env rc hawkular-cassandra-1 MAX_HEAP_SIZE=1024M -n openshift-infra

#重建下,变量才会生效
oc scale rc hawkular-cassandra-1 --replicas 0 -n openshift-infra
oc scale rc hawkular-cassandra-1 --replicas 1 -n openshift-infra
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立本地Git仓&lt;/p&gt;
&lt;p&gt;默认官方给出的例子基本都需要和Github结合，实在不好本地实战演示，所以本地要来一个&lt;code&gt;gogs&lt;/code&gt;代码仓。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;oc login -u devloper
oc new-project ci

#先拉取所依赖镜像
docker pull openshiftdemos/gogs:0.9.97
docker pull centos/postgresql-94-centos7

#创建gogs服务，并禁用webhook时的TLS校验，不然无法触发build
oc new-app -f https://raw.githubusercontent.com/xiaoping378/gogs-openshift-docker/master/openshift/gogs-persistent-template.yaml -p SKIP_TLS_VERIFY=true -p HOSTNAME=gogs-ci.192.168.31.49.xip.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的HOSTNAME，注意要换成自己宿主机的IPv4地址，默认创建的其他服务的路由都是这个形式的，&lt;/p&gt;
&lt;p&gt;有个有意思的地方，为什么默认路由会是这种 &lt;code&gt;name+IP+xip.io&lt;/code&gt; 形式呢，奥秘在 &lt;a href="http://xip.io"&gt;http://xip.io&lt;/a&gt; 的公共服务上。
这其实是个特殊的域DNS server，比如我们查询域名&lt;code&gt;gogs-ci.192.168.31.49.xip.io&lt;/code&gt;时 ，会返回192.168.31.49的地址回来，
而这个地址恰好是我们Router的地址，这样子Router会根据route的配置负责负载到对应的POD上。自己试验下就知道怎么回事了。&lt;/p&gt;</description></item><item><title>DevOps实战-1</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-1/</guid><description>&lt;p&gt;本文主要介绍基于openshift如何完成&lt;code&gt;开发-&amp;gt;测试-&amp;gt;线上&lt;/code&gt;场景的变更，这是一个典型的应用生产流程，来看看openshift是如何利用容器优雅的完成整个过程的吧&lt;/p&gt;
&lt;p&gt;下文基于上篇&lt;a href="../openshift%E5%AE%9E%E8%B7%B5-devops%E5%AE%9E%E6%88%98-0"&gt;DevOps实战-0&lt;/a&gt; 的&lt;code&gt;nodejs-ex&lt;/code&gt;项目来说, 假设到这里，你本地已经有了nodejs-ex项目&lt;/p&gt;
&lt;h3 id="准备3个project"&gt;准备3个project&lt;a class="td-heading-self-link" href="#%e5%87%86%e5%a4%873%e4%b8%aaproject" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;用这3个project来模拟开发，测试，线上环境&lt;/p&gt;
&lt;p&gt;现实中一般各个场景的服务器都是物理隔离的，这里可以利用&lt;code&gt;--node-selector&lt;/code&gt;，来指定项目可以跑在哪些节点上。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc login -u sysetm:admin

#晚上在笔记本上写此blog，没合适的环境，单机模拟多台 -- start
oc label node 192.168.31.49 web-prod=true web-dev=true web-test=true
#晚上在笔记本上写此blog，没合适的环境，单机模拟多台 -- end

#1.创建web-dev项目
#2.授权developer为开发组项目管理员
#3.授权测试和运维人员可以从开发组拉取镜像
oc adm new-project web-dev --node-selector=&amp;#39;web-dev=true&amp;#39;
oc policy add-role-to-user admin developer
oc policy add-role-to-group system:image-puller system:serviceaccounts:web-test -n web-dev
oc policy add-role-to-group system:image-puller system:serviceaccounts:web-prod -n web-dev

oc adm new-project web-test --node-selector=&amp;#39;web-test=true&amp;#39;
oc policy add-role-to-user admin tester

oc adm new-project web-prod --node-selector=&amp;#39;web-prod=true&amp;#39;
oc policy add-role-to-user admin ops
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你可能会注意到，这里用的&lt;code&gt;new-project&lt;/code&gt; 前面还加了adm， 其实&lt;code&gt;oc adm&lt;/code&gt;等效于&lt;code&gt;oadm&lt;/code&gt;， 一般管理集群相关的用这个命令，这里是因为需要读取节点的标签（label）信息。&lt;/p&gt;</description></item><item><title> 编译和目录结构介绍</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E6%BA%90%E7%A0%81-%E7%BC%96%E8%AF%91%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E6%BA%90%E7%A0%81-%E7%BC%96%E8%AF%91%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid><description>&lt;p&gt;介绍openshift的源码编译和目录结构组织，为了方便代码调试和了解大型Golang项目的构建方式&lt;/p&gt;
&lt;h3 id="编译"&gt;编译&lt;a class="td-heading-self-link" href="#%e7%bc%96%e8%af%91" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;无论是openshift还是Kubernetes等大型Golang项目都用到了&lt;code&gt;Makefile&lt;/code&gt;, 所以有必要从此开始说起，这里只说项目里用到的makefile特性，想了解更多的可以参考&lt;a href="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf"&gt;跟我一起写Makefile&lt;/a&gt;&lt;/p&gt;
&lt;h4 id="makefile介绍"&gt;Makefile介绍&lt;a class="td-heading-self-link" href="#makefile%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、
模块分别放在若干个目录中，makefile 定义了一系列的规则来指定，哪些文件需要先编译，
哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为
makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。 makefile 带来的好
处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，
极大的提高了软件开发的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Makefile里的规则，就在做两件事，一个是指明依赖关系，另一个是生成目标的方法&lt;/p&gt;
&lt;p&gt;Golang项目里用到的Makefile规则比较简单，基本就是定义一个目标的生成方法，下面的示例是Openshift项目里makefile中定义的第一个目标。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#00a000"&gt;all build&lt;/span&gt;&lt;span style="color:#666"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	hack/build-go.sh &lt;span style="color:#a2f;font-weight:bold"&gt;$(&lt;/span&gt;WHAT&lt;span style="color:#a2f;font-weight:bold"&gt;)&lt;/span&gt; &lt;span style="color:#a2f;font-weight:bold"&gt;$(&lt;/span&gt;GOFLAGS&lt;span style="color:#a2f;font-weight:bold"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#00a000"&gt;.PHONY&lt;/span&gt;&lt;span style="color:#666"&gt;:&lt;/span&gt; all build
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;all build&lt;/code&gt;，是定义的目标，看到这个就知道可以在源码的根目录上执行&lt;code&gt;make all build&lt;/code&gt;来编译了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二行说明生成目标的方法，就是去hack目录下执行build-go.sh脚本，这里还支持传入一些参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三行 &lt;code&gt;.PHONY&lt;/code&gt;，起到一个标识的作用，没什么实际意义，是用来告诉make命令，这里是个伪目标，也可以说成是默认目标，所以在openshift的根目录上直接执行&lt;code&gt;make&lt;/code&gt;, 等效于&lt;code&gt;make all build&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还可以自己决定是否编译出镜像或者rpm包（make release, make build-rpms）&lt;/p&gt;
&lt;h4 id="编译openshift"&gt;编译openshift&lt;a class="td-heading-self-link" href="#%e7%bc%96%e8%af%91openshift" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;上边介绍了，直接敲&lt;code&gt;make&lt;/code&gt;就可以自动编译出所有平台（linux, mac, windows）的二进制，编译前介绍两个hack方法，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在hack/build-go.sh的第二行加上&lt;code&gt;set -x&lt;/code&gt;， 这样的话，shell脚本在运行时，里面的所有变量和执行路径会全部打印出来，一目了然，不用自己一行一行的加echo debug了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如下修改hack/build-cross.sh，不然会编译出多平台的二进制，花的时间略长啊。。。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# by default, build for these platforms
platforms=(
 linux/amd64
 # darwin/amd64
 # windows/amd64
 # linux/386
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简易说下执行make后，都发生了什么，只会捡关键点说。&lt;/p&gt;</description></item><item><title>多负载均衡方案</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-router%E5%92%8Chaproxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-router%E5%92%8Chaproxy/</guid><description>&lt;p&gt;haproxy在openshift里默认有两种用处，一个种负责master的高可用，一种是负责外部对内服务的访问（ingress controller）&lt;/p&gt;
&lt;p&gt;平台部署情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3台master，etcd&lt;/li&gt;
&lt;li&gt;1台node&lt;/li&gt;
&lt;li&gt;1台lb（haproxy）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="haproxy负载均衡master的高可用"&gt;haproxy负载均衡master的高可用&lt;a class="td-heading-self-link" href="#haproxy%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1master%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;lb负责master间的负载均衡，其实负载没那么大，更多得是用来避免单点故障&lt;/p&gt;
&lt;h3 id="debug介绍"&gt;Debug介绍&lt;a class="td-heading-self-link" href="#debug%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认安装haproxy1.5.18版本，开启debug方法&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;# 默认systemd对haproxy做了封装，会以-Ds后台形式启动，debug信息是看不到的
systemctl stop harproxy

# vi /etc/haproxy/haproxy.cfg
 log 127.0.0.1 local3 debug

# 手动启动haproxy
haproxy -f /etc/haproxy/haproxy.cfg -p /run/haproxy.pid -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不知道是不是哪里还需要设置，打印出来的日志，信息并不是不太多&lt;/p&gt;
&lt;p&gt;另外浏览&lt;code&gt;https://lbIP:9000&lt;/code&gt;, 可以看到统计信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="配置介绍"&gt;配置介绍&lt;a class="td-heading-self-link" href="#%e9%85%8d%e7%bd%ae%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;a href="https://github.com/xiaoping378/openshift-deploy"&gt;openshift-ansible&lt;/a&gt;部署后，harpxy的配置如下&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;[root@node4 ~]# cat /etc/haproxy/haproxy.cfg
# Global settings
#---------------------------------------------------------------------
global
 chroot /var/lib/haproxy
 pidfile /var/run/haproxy.pid
 maxconn 20000
 user haproxy
 group haproxy
 daemon
 log /dev/log local0 info #定义debug级别

 # turn on stats unix socket
 stats socket /var/lib/haproxy/stats

#---------------------------------------------------------------------
# common defaults that all the &amp;#39;listen&amp;#39; and &amp;#39;backend&amp;#39; sections will
# use if not designated in their block
#---------------------------------------------------------------------
defaults #默认配置，后面同KEY的设置会覆盖此处
 mode http #工作在七层代理，客户端请求在转发至后端服务器之前将会被深度分板，所有不与RFC格式兼容的请求都会被拒绝，一些七层的过滤处理手段，可以使用。
 log global #默认启用gloabl的日志设置
 option httplog #默认日志类别为http日志格式
 option dontlognull #不记录健康检查日志信息（端口扫描，空信息）
# option http-server-close
 option forwardfor except 127.0.0.0/8 #如果上游服务器上的应用程序想记录客户端的真实IP地址，haproxy会把客户端的IP信息发送给上游服务器，在HTTP请求中添加”X-Forwarded-For”字段,但当是haproxy自身的健康检测机制去访问上游服务器时是不应该把这样的访问日志记录到日志中的，所以用except来排除127.0.0.0，即haproxy自身
 option redispatch #代理的服务器挂掉后，强制定向到其他健康的服务器，避免cookie信息过时，仍可正常访问
 retries 3 #3次连接失败就认为后端服务器不可用
 timeout http-request 10s #默认客户端发送http请求的超时时间， 防DDOS攻击手段
 timeout queue 1m #当后台服务器maxconn满了后，haproxy会把client发送来的请求放进一个队列中，一旦事件超过timeout queue，还没被处理，haproxy会自动返回503错误。
 timeout connect 10s #haproxy与后端服务器连接超时时间，如果在同一个局域网可设置较小的时间
 timeout client 300s #默认客户端与haproxy连接后，数据传输完毕，不再有数据传输，即非活动连接的超时时间
 timeout server 300s #定义haproxy与后台服务器非活动连接的超时时间
 timeout http-keep-alive 10s #默认新的http请求建立连接的超时时间，时间较短时可以尽快释放出资源，节约资源。和http-request配合使用
 timeout check 10s #健康检测的时间的最大超时时间
 maxconn 20000 #最大连接数

listen stats :9000
 mode http
 stats enable
 stats uri /

frontend atomic-openshift-api
 bind *:8443
 default_backend atomic-openshift-api
 mode tcp #在此模式下，客户端和服务器端之前将建立一个全双工的连接，不会对七层（http）报文做任何检查
 option tcplog

backend atomic-openshift-api
 balance source #是基于请求源IP的算法，此算法对请求的源IP时行hash运算，然后将结果除以后端服务器的权重总和，来判断转发至哪台后端服务器，这种方法可保证同一客户端IP的请求始终转发到固定定的后端服务器。
 mode tcp
 server master0 192.168.56.100:8443 check
 server master1 192.168.56.101:8443 check
 server master2 192.168.56.102:8443 check
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href="http://cbonte.github.io/haproxy-dconv/1.5/configuration.html"&gt;官方文档&lt;/a&gt;介绍的非常详细，感兴趣的可以继续深入研究&lt;/p&gt;</description></item><item><title>镜像管理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</guid><description>&lt;p&gt;刚接触docker时，第一个接触到的应该就是镜像了，docker之所以如此火热，个人认为一大部分原因就是这个镜像的提出，极大的促进了DevOps推广和软件复用的能力。&lt;/p&gt;
&lt;p&gt;而openshift对镜像的管理非常强大，直到写这篇blog，我才真正意识到这点，甚至犹豫是不是要放到开发实战篇后再来写&lt;code&gt;镜像管理&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;简要说下openshift里使用镜像的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先openshift可以利用任何实现了&lt;code&gt;Docker registry API&lt;/code&gt;的镜像仓，比如，Vmware的Harbor项目，Docker hub以及集成镜像仓（ integrated registry）&lt;/li&gt;
&lt;li&gt;集成镜像仓，openshift内部的，可以动态生成，自动让用户编译的镜像有地方存， 其次它还负责通知openshift镜像的变动，然后openshift会根据策略去决定编译其他依赖镜像还是部署应用&lt;/li&gt;
&lt;li&gt;第三方镜像， 可通过命令&lt;code&gt;oc import-image &amp;lt;stream&amp;gt;&lt;/code&gt;来实时获取镜像tag信息并转换成镜像流，继而触发后续的编译或者部署。&lt;/li&gt;
&lt;li&gt;当然&lt;code&gt;oc new-app&lt;/code&gt;也支持直接从第三方镜像仓或者本地镜像里启动一个应用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文末有安装集成镜像仓的说明，先介绍image Streams 和 istag的概念和应用场景。&lt;/p&gt;
&lt;h2 id="镜像管理"&gt;镜像管理&lt;a class="td-heading-self-link" href="#%e9%95%9c%e5%83%8f%e7%ae%a1%e7%90%86" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;openshift基于docker的image概念又延伸出了Image Streams和Image Stream Tags概念&lt;/p&gt;
&lt;p&gt;默认openshift项目下会有一些镜像流，是供自带模板里用的，所以想加速部署模板的话，可以在改这里，通过istag指向本地镜像仓。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc get is -n openshift
oc get istag -n openshift
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;image，通俗讲就是对应用运行依赖（库，配置，运行环境）的一个打包。&lt;code&gt;docker pull push&lt;/code&gt;， 就是操作的镜像。
为什么openshift还要抽象出is和istag呢，主要是为了打通集成编译和部署环节（bc和dc），原生API就支持了DevOps理念。后面会细讲bc和dc&lt;/p&gt;
&lt;p&gt;is,开发人员可以理解成git的分支，每个分支都会编译很多临时版本出来，这个就是对应到is～=分支和istag～=版本号。
其实is和istag只是记录了一些映射关系，并不会存放实际镜像数据，比如is里记录了build后要output的镜像仓地址和所有tags，而istag里又记录了具体某个tag与image（可能是存于外部镜像仓，也能是某个is）的关系， 利用此实现了bc/dc和镜像的解耦。&lt;/p&gt;
&lt;p&gt;这里通过部署jenkins服务，来初步了解下具体的含义,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建ci项目&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc new-project ci
# 先拉取必要镜像
docker pull openshift/jenkins-1-centos7

#通过模板部署，下面一条命令就可以创建一个临时的jenkins服务的
#oc new-app jenkins-ephemeral
#跑之前我们先来注意几点
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;更改默认的is&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先来查看默认的is&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;oc get template jenkins-ephemeral -n openshift -o json
...
&amp;#34;triggers&amp;#34;: [
 {
 &amp;#34;imageChangeParams&amp;#34;: {
 &amp;#34;automatic&amp;#34;: true,
 &amp;#34;containerNames&amp;#34;: [
 &amp;#34;jenkins&amp;#34;
 ],
 &amp;#34;from&amp;#34;: {
 &amp;#34;kind&amp;#34;: &amp;#34;ImageStreamTag&amp;#34;,
 &amp;#34;name&amp;#34;: &amp;#34;${JENKINS_IMAGE_STREAM_TAG}&amp;#34;,
 &amp;#34;namespace&amp;#34;: &amp;#34;${NAMESPACE}&amp;#34;
 },
 &amp;#34;lastTriggeredImage&amp;#34;: &amp;#34;&amp;#34;
 },
 &amp;#34;type&amp;#34;: &amp;#34;ImageChange&amp;#34;
 },
 {
 &amp;#34;type&amp;#34;: &amp;#34;ConfigChange&amp;#34;
 }
 ]
...
{
 &amp;#34;name&amp;#34;: &amp;#34;NAMESPACE&amp;#34;,
 &amp;#34;displayName&amp;#34;: &amp;#34;Jenkins ImageStream Namespace&amp;#34;,
 &amp;#34;description&amp;#34;: &amp;#34;The OpenShift Namespace where the Jenkins ImageStream resides.&amp;#34;,
 &amp;#34;value&amp;#34;: &amp;#34;openshift&amp;#34;
},
{
 &amp;#34;name&amp;#34;: &amp;#34;JENKINS_IMAGE_STREAM_TAG&amp;#34;,
 &amp;#34;displayName&amp;#34;: &amp;#34;Jenkins ImageStreamTag&amp;#34;,
 &amp;#34;description&amp;#34;: &amp;#34;Name of the ImageStreamTag to be used for the Jenkins image.&amp;#34;,
 &amp;#34;value&amp;#34;: &amp;#34;jenkins:latest&amp;#34;
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到默认模板里部署jenkins时，会从openshfit的namespace里拉取jenkins:latest的镜像, 去openshift项目里找找看，确实存在对应的is&lt;/p&gt;</description></item><item><title>性能优化指南</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</guid><description>&lt;p&gt;主要参考的官方&lt;a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/3.5/html-single/scaling_and_performance_guide/"&gt;链接&lt;/a&gt;， 本文是基于openshift 3.5说的。&lt;/p&gt;
&lt;h2 id="概览"&gt;概览&lt;a class="td-heading-self-link" href="#%e6%a6%82%e8%a7%88" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本指南提供了如何提高OpenShift容器平台的集群性能和生产环境下的最佳实践。 主要包括建立，扩展和调优OpenShift集群的推荐做法。&lt;/p&gt;
&lt;p&gt;个人看法，其实性能这个东西是个权衡的过程，根据自身硬件条件和实际需求，选择适合自己的调优手段。&lt;/p&gt;
&lt;h2 id="安装实践"&gt;安装实践&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85%e5%ae%9e%e8%b7%b5" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="网络依赖"&gt;网络依赖&lt;a class="td-heading-self-link" href="#%e7%bd%91%e7%bb%9c%e4%be%9d%e8%b5%96" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;首先安装自然要选择官方的&lt;a href="https://github.com/openshift/openshift-ansible"&gt;openshift-ansible项目&lt;/a&gt;， 默认是rpm安装方式，需要依赖网络，比如要去联网下载&lt;code&gt;atomic-openshift-*, iptables, 和 docker&lt;/code&gt;包依赖，&lt;/p&gt;
&lt;p&gt;如果有不能联网的节点，可以参考我之前写的&lt;a href="https://github.com/xiaoping378/openshift-deploy"&gt;离线安装openshift&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="ansible优化"&gt;ansible优化&lt;a class="td-heading-self-link" href="#ansible%e4%bc%98%e5%8c%96" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;官方推荐使用ansible安装，这里说下针对ansible的优化，以提高安装效率，主要参考&lt;a href="https://www.ansible.com/blog/ansible-performance-tuning"&gt;ansible官方blog&lt;/a&gt;,&lt;/p&gt;
&lt;p&gt;如果参考上文离线安装的话，不建议跨外网连接rpm仓或者镜像仓，下面是推荐的ansible配置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# cat /etc/ansible/ansible.cfg&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# config file for ansible -- http://ansible.com/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#080;font-style:italic"&gt;# ==============================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;defaults&lt;span style="color:#666"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;forks&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;20&lt;/span&gt; &lt;span style="color:#080;font-style:italic"&gt;# 20个并发是理想值，太高的话中间会有概率出错&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;host_key_checking&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; False
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;remote_user&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; root
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;roles_path&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; roles/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;gathering&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; smart
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;fact_caching&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; jsonfile
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;fact_caching_connection&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#b8860b"&gt;$HOME&lt;/span&gt;/ansible/facts
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;fact_caching_timeout&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;600&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;log_path&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#b8860b"&gt;$HOME&lt;/span&gt;/ansible.log
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;nocows&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;callback_whitelist&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; profile_tasks
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;privilege_escalation&lt;span style="color:#666"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;become&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; False
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;ssh_connection&lt;span style="color:#666"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;ssh_args&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; -o &lt;span style="color:#b8860b"&gt;ControlMaster&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;auto -o &lt;span style="color:#b8860b"&gt;ControlPersist&lt;/span&gt;&lt;span style="color:#666"&gt;=&lt;/span&gt;600s
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;control_path&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; %&lt;span style="color:#666"&gt;(&lt;/span&gt;directory&lt;span style="color:#666"&gt;)&lt;/span&gt;s/%%h-%%r
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;pipelining&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; True &lt;span style="color:#080;font-style:italic"&gt;# 多路复用，减少了控制机和目标间的连接次数，加速了性能。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#b8860b"&gt;timeout&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="网络配置"&gt;网络配置&lt;a class="td-heading-self-link" href="#%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里必须要提下，一定要安装前做好网络规划，不然后面改起来很麻烦，&lt;/p&gt;</description></item><item><title>网络整理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</guid><description>&lt;p&gt;介绍利用openshift-ansible项目安装后的生产环境里的网络情况。&lt;/p&gt;
&lt;p&gt;待整理。。。&lt;/p&gt;</description></item><item><title>监控梳理</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%9B%91%E6%8E%A7%E6%A2%B3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E7%9B%91%E6%8E%A7%E6%A2%B3%E7%90%86/</guid><description>&lt;p&gt;未完搞 ...&lt;/p&gt;</description></item><item><title>日志分析</title><link>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/openshift/openshift%E5%AE%9E%E8%B7%B5-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</guid><description>&lt;p&gt;未完搞 ...&lt;/p&gt;</description></item></channel></rss>