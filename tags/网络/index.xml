<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络 on 现代技能栈</title><link>https://xiaoping378.github.io/tags/%E7%BD%91%E7%BB%9C/</link><description>Recent content in 网络 on 现代技能栈</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://xiaoping378.github.io/tags/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>内网机穿透开发</title><link>https://xiaoping378.github.io/docs/2-infra/network/frp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/2-infra/network/frp/</guid><description>&lt;div class="pageinfo pageinfo-primary"&gt;
&lt;p&gt;充分利用外网开隧道代理到本地服务，演示或者内网开发的利器，自己具备公网服务器的可以使用frp，不具备的可以使用ngrok。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id="frp介绍"&gt;FRP介绍&lt;a class="td-heading-self-link" href="#frp%e4%bb%8b%e7%bb%8d" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;frp 是国人开源的一种快速反向代理，可将 NAT 或防火墙后面的本地服务器暴露到互联网上。目前，它支持暴露 TCP 和 UDP，以及 HTTP 和 HTTPS 协议，也可以通过域名将请求转发到内部服务。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://xiaoping378.github.io/images/frp-2022-03-06-20-21-49.png" alt=""&gt;&lt;/p&gt;
&lt;h2 id="安装"&gt;安装&lt;a class="td-heading-self-link" href="#%e5%ae%89%e8%a3%85" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;二进制下载&lt;a href="https://github.com/fatedier/frp/releases"&gt;地址&lt;/a&gt;, 解压后内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ frp_0.39.1_linux_amd64 tree
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frpc
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frpc_full.ini
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frpc.ini
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frps
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frps_full.ini
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── frps.ini
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── LICENSE
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── systemd
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ├── frpc.service
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ├── frpc@.service
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ├── frps.service
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; └── frps@.service
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;1&lt;/span&gt; directory, &lt;span style="color:#666"&gt;11&lt;/span&gt; files
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可将其中的 frpc 拷贝到内网服务所在的机器上，将 frps 拷贝到具有公网 IP 的机器上，放置在任意目录。&lt;/p&gt;
&lt;p&gt;后续使用思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写配置文件，先通过 ./frps -c ./frps.ini 启动服务端，&lt;/li&gt;
&lt;li&gt;再通过 ./frpc -c ./frpc.ini 启动客户端。&lt;/li&gt;
&lt;li&gt;如果需要在后台长期运行，可使用压缩包内写好的的systemd服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="代理ssh"&gt;代理ssh&lt;a class="td-heading-self-link" href="#%e4%bb%a3%e7%90%86ssh" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本人日常开发使用vsocde，众所周知，其&lt;a href="https://code.visualstudio.com/docs/remote/ssh"&gt;remote SSH开发&lt;/a&gt;的特性非常惊艳，可以提供本地开发的体验，背后需要通过ssh连接到远端服务器，高配云主机价格不菲，公司电脑长期荒废中，，，，遂有了此想法，只购买一个低配的云主机用来代理到内网的公司电脑（已安装linux）上，然后利用vscode实现内网穿透开发。&lt;/p&gt;</description></item><item><title>docker网络</title><link>https://xiaoping378.github.io/docs/4-cloud/containers/docker-network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/4-cloud/containers/docker-network/</guid><description>&lt;p&gt;自去年就开始推动公司业务使用docker了， 至今也一年多了，但对docker网络的认知一直一知半解。。。&lt;/p&gt;
&lt;p&gt;主要是太忙，加上线上业务也没出过关于网络吞吐性能方面的问题，就没太大动力去搞明白， 现在闲下来了，搞之！&lt;/p&gt;
&lt;h3 id="环境声明"&gt;环境声明&lt;a class="td-heading-self-link" href="#%e7%8e%af%e5%a2%83%e5%a3%b0%e6%98%8e" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以下内容只针对OS: Ubuntu16.04 docker: 1.10.3的环境， 写本文时docker最新的release版本是1.11.2，还有什么CoreOS，Unikernel 之类的（表示都没玩过）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;docker更新迭代速度太快了，公司业务只用到基本功能，所以没动力跟进它的更新了
各种新时代下的产物频出啊， CoreOS为linux的发行版， 没需求，好遗憾.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="docker的网络模式"&gt;docker的网络模式&lt;a class="td-heading-self-link" href="#docker%e7%9a%84%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8f" aria-label="Heading self-link"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一开始安装完docker， 它就会默认创建3个网络， 使用__docker network ls__查看&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ blog git:&lt;span style="color:#666"&gt;(&lt;/span&gt;master&lt;span style="color:#666"&gt;)&lt;/span&gt; docker network ls
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;NETWORK ID NAME DRIVER
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;46416a43fbc6 bridge bridge 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;45398901e9f0 none null 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;9440a8140e68 host host
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当启动一个容器时， 默认使用bridge模式， 可以通过 --net 指定其它模式。&lt;/p&gt;
&lt;p&gt;下面先简要说明下各自的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bridge 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器间之所以能通信，就靠宿主机上的docker0了， docker0就是bridge模式下默认创建的虚拟设备名称&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;➜ blog git:&lt;span style="color:#666"&gt;(&lt;/span&gt;master&lt;span style="color:#666"&gt;)&lt;/span&gt; ✗ ifconfig docker0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;docker0 Link encap:Ethernet HWaddr 02:42:49:56:7c:3b 
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; inet addr:172.17.0.1 Bcast:0.0.0.0 Mask:255.255.0.0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; inet6 addr: fe80::42:49ff:fe56:7c3b/64 Scope:Link
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; RX packets:78103 errors:0 dropped:0 overruns:0 frame:0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; TX packets:47578 errors:0 dropped:0 overruns:0 carrier:0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; collisions:0 txqueuelen:0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; RX bytes:17485434 &lt;span style="color:#666"&gt;(&lt;/span&gt;17.4 MB&lt;span style="color:#666"&gt;)&lt;/span&gt; TX bytes:82163889 &lt;span style="color:#666"&gt;(&lt;/span&gt;82.1 MB&lt;span style="color:#666"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ifocnfig可以看到很多信息， mac地址，IP等这些也可以通过参数指定成别的。&lt;/p&gt;</description></item><item><title>网络TCP/IP协议栈</title><link>https://xiaoping378.github.io/docs/2-infra/network/tcpip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xiaoping378.github.io/docs/2-infra/network/tcpip/</guid><description>&lt;p&gt;.TODO&lt;/p&gt;</description></item></channel></rss>